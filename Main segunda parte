-- // Fantasma
-- ========================================
-- FANTASMA
-- ========================================

-- // Servicios
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- // Variables de jugador
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local camera = workspace.CurrentCamera

-- // Variables de ghost
local isGhostMode = false
local ghostPart = nil
local platform = nil
local lastPosition = nil

-- Tabla para guardar las transparencias originales
local originalTransparencies = {}

-- // Movimiento móvil flags
local moveFlags = {
	W = false,
	A = false,
	S = false,
	D = false,
	Space = false,
	LeftControl = false,
}

-- // Variables globales para GUI
local screenGui = nil
local buttons = {}

-- // Conexión del loop de movimiento (SE ACTIVA SOLO CUANDO SE USA)
local heartbeatConnection = nil

-- // Función para crear la GUI móvil (SOLO cuando se activa ghost)
local function createMobileGui()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		buttons = {}
	end

	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "GhostMobileControls"
	screenGui.Parent = player:WaitForChild("PlayerGui")
	screenGui.Enabled = false

	local directions = {{"W", "↑"}, {"S", "↓"}, {"A", "←"}, {"D", "→"}, {"Space", "⎵"}, {"LeftControl", "C"}}

	for i, dir in ipairs(directions) do
		local button = Instance.new("TextButton")
		button.Size = UDim2.new(0, 60, 0, 60)
		button.Position = UDim2.new(0, 10 + (i-1)*65, 1, -70)
		button.Text = dir[2]
		button.BackgroundTransparency = 0.3
		button.TextScaled = true
		button.Name = dir[1]
		button.Parent = screenGui
		buttons[dir[1]] = button

		button.MouseButton1Down:Connect(function()
			moveFlags[dir[1]] = true
		end)
		button.MouseButton1Up:Connect(function()
			moveFlags[dir[1]] = false
		end)
	end
end

-- // Función para limpiar la GUI móvil
local function cleanupMobileGui()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		buttons = {}
	end
end

-- // Funciones originales
local function createPlatform(position)
	if platform then platform:Destroy() end
	platform = Instance.new("Part")
	platform.Name = "PlayerPlatform"
	platform.Size = Vector3.new(10, 1, 10)
	platform.Position = position - Vector3.new(0, 3.5, 0)
	platform.Anchored = true
	platform.BrickColor = BrickColor.new("Really black")
	platform.Transparency = 1
	platform.CanCollide = true
	platform.CastShadow = false
	platform.Parent = workspace
end

local function createGhostPart(position)
	if workspace:FindFirstChild("GhostPart") then
		workspace.GhostPart:Destroy()
	end
	if ghostPart then ghostPart:Destroy() end

	ghostPart = Instance.new("Part")
	ghostPart.Name = "GhostPart"
	ghostPart.Size = Vector3.new(2, 2, 2)
	ghostPart.Position = position.Position + Vector3.new(0, 2, 0)
	ghostPart.Transparency = 0.5
	ghostPart.BrickColor = BrickColor.new("Really white")
	ghostPart.CanCollide = false
	ghostPart.Anchored = false
	ghostPart.Parent = workspace

	local mesh = Instance.new("SpecialMesh")
	mesh.MeshType = Enum.MeshType.FileMesh
	mesh.MeshId = "rbxassetid://11003401773"
	mesh.Scale = Vector3.new(0.15, 0.15, 0.15)
	mesh.Parent = ghostPart

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.Parent = ghostPart

	local bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyGyro.CFrame = CFrame.new(ghostPart.Position)
	bodyGyro.Parent = ghostPart

	camera.CameraSubject = ghostPart
	camera.CameraType = Enum.CameraType.Custom
end

local function updateGhostPartMovement()
	if not isGhostMode or not ghostPart then return end
	local moveDirection = Vector3.new(0, 0, 0)
	local speed = 60
	local cameraCFrame = camera.CFrame

	if UserInputService:IsKeyDown(Enum.KeyCode.W) or moveFlags.W then
		moveDirection += cameraCFrame.LookVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) or moveFlags.S then
		moveDirection -= cameraCFrame.LookVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) or moveFlags.A then
		moveDirection -= cameraCFrame.RightVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) or moveFlags.D then
		moveDirection += cameraCFrame.RightVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.Space) or moveFlags.Space then
		moveDirection += Vector3.new(0, speed, 0)
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or moveFlags.LeftControl then
		moveDirection -= Vector3.new(0, speed, 0)
	end

	local bodyVelocity = ghostPart:FindFirstChildOfClass("BodyVelocity")
	if bodyVelocity then
		bodyVelocity.Velocity = moveDirection
	end
end

-- Función para activar el loop de movimiento
local function connectHeartbeat()
	if heartbeatConnection then return end
	heartbeatConnection = RunService.Heartbeat:Connect(function()
		updateGhostPartMovement()
	end)
end

-- Función para desactivar el loop de movimiento
local function disconnectHeartbeat()
	if heartbeatConnection then
		heartbeatConnection:Disconnect()
		heartbeatConnection = nil
	end
end

-- Función para guardar transparencias originales
local function saveOriginalTransparencies()
	originalTransparencies = {}
	
	for _, obj in pairs(character:GetDescendants()) do
		if obj:IsA("BasePart") or obj:IsA("MeshPart") then
			-- Solo guardar partes que son del cuerpo original del personaje
			-- Ignorar partes que el juego pueda haber añadido
			if obj.Parent == character or (obj.Parent and obj.Parent:IsA("Accessory")) then
				originalTransparencies[obj] = obj.Transparency
			end
		elseif obj:IsA("Decal") then
			if obj.Parent and (obj.Parent.Parent == character or obj.Parent.Name == "Head") then
				originalTransparencies[obj] = obj.Transparency
			end
		end
	end
end

-- Función para restaurar transparencias originales
local function restoreOriginalTransparencies()
	for obj, transparency in pairs(originalTransparencies) do
		if obj and obj.Parent then
			obj.Transparency = transparency
		end
	end
	
	-- Mantener HumanoidRootPart invisible siempre
	if humanoidRootPart then
		humanoidRootPart.Transparency = 1
	end
	
	-- Mantener CollisionPart invisible si existe
	local collidePart = character:FindFirstChild("CollisionPart", true)
	if collidePart and collidePart:IsA("BasePart") then
		collidePart.Transparency = 1
	end
	
	originalTransparencies = {}
end

local function teleportAndGhost()
	if isGhostMode then
		-- DESACTIVAR GHOST MODE
		humanoidRootPart.CFrame = ghostPart and CFrame.new(ghostPart.Position + Vector3.new(0, 3, 0)) or CFrame.new(0, 100, 0)
		character.Humanoid.WalkSpeed = 16
		character.Humanoid.JumpPower = 50

		-- Restaurar transparencias originales
		restoreOriginalTransparencies()

		camera.CameraSubject = character:FindFirstChildOfClass("Humanoid") or character
		camera.CameraType = Enum.CameraType.Custom

		if ghostPart then ghostPart:Destroy() ghostPart = nil end
		if platform then platform:Destroy() platform = nil end

		-- Limpiar GUI y desconectar loop
		cleanupMobileGui()
		disconnectHeartbeat()

		isGhostMode = false
	else
		-- ACTIVAR GHOST MODE
		lastPosition = humanoidRootPart.CFrame
		local teleportPosition = Vector3.new(math.random(-1000, 1000), 100, math.random(-1000, 1000))
		
		-- Guardar transparencias antes de modificar
		saveOriginalTransparencies()
		
		createPlatform(teleportPosition)
		humanoidRootPart.CFrame = CFrame.new(teleportPosition)
		createGhostPart(lastPosition)
		character.Humanoid.WalkSpeed = 0
		character.Humanoid.JumpPower = 0

		-- Hacer invisibles SOLO las partes del personaje original
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") or part:IsA("MeshPart") then
				-- Solo afectar partes del cuerpo y accesorios
				if part.Parent == character or (part.Parent and part.Parent:IsA("Accessory")) then
					part.Transparency = 1
				end
			elseif part:IsA("Decal") then
				-- Mantener decals visibles (cara)
				if part.Parent and (part.Parent.Parent == character or part.Parent.Name == "Head") then
					part.Transparency = 0
				end
			end
		end

		-- Crear GUI solo si es móvil
		if UserInputService.TouchEnabled then
			createMobileGui()
			if screenGui then
				screenGui.Enabled = true
			end
		end

		-- Conectar el loop de movimiento
		connectHeartbeat()

		isGhostMode = true
	end
end

-- // Manejo de respawn
player.CharacterAdded:Connect(function(char)
	character = char
	humanoidRootPart = char:WaitForChild("HumanoidRootPart")

	if isGhostMode then
		if ghostPart then ghostPart:Destroy() ghostPart = nil end
		if platform then platform:Destroy() platform = nil end
		camera.CameraSubject = character:WaitForChild("Humanoid")
		camera.CameraType = Enum.CameraType.Custom
		isGhostMode = false
		cleanupMobileGui()
		disconnectHeartbeat()
	end

	if platform then platform:Destroy() platform = nil end

	local collidePart = character:FindFirstChild("CollisionPart", true)
	if collidePart then
		collidePart.Transparency = 1
	end
end)

-- // Toggle Rayfield
MainTab:CreateToggle({
	Name = "Fantasma",
	CurrentValue = false,
	Flag = "InvincibilityToggle",
	Callback = function(Value)
		if Value and not isGhostMode then
			teleportAndGhost()
		elseif not Value and isGhostMode then
			teleportAndGhost()
		end
	end,
})


-- ========================================
-- ========================================
-- SHIFTLOCK LIMPIO Y FUNCIONAL - MÓVIL CORREGIDO
-- ========================================

-- Servicios
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = game.Players.LocalPlayer
local camera2 = workspace.CurrentCamera
local character2 = player.Character or player.CharacterAdded:Wait()
local humanoid2 = character2:WaitForChild("Humanoid")
local root2 = character2:WaitForChild("HumanoidRootPart")

-- Variables del Shiftlock
local shiftlockEnabled = false
local shiftlockKeybind = Enum.KeyCode.Q
local isActive = false
local cameraConnection = nil

-- Elementos de la GUI
local ShiftlockGui = nil
local Button = nil
local StateLabelFrame = nil
local StateLabel = nil
local Crosshair = nil

-- Conexión de input
local inputBeganConnection = nil

-- ========================================
-- FUNCIONES DE GUI
-- ========================================

local function createShiftlockGui()
	if ShiftlockGui then
		ShiftlockGui:Destroy()
	end

	ShiftlockGui = Instance.new("ScreenGui")
	ShiftlockGui.Name = "ShiftlockGUI"
	ShiftlockGui.ResetOnSpawn = false
	ShiftlockGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ShiftlockGui.IgnoreGuiInset = false
	ShiftlockGui.Parent = player:WaitForChild("PlayerGui")

	-- Botón principal - CORRECCIONES CRÍTICAS PARA MÓVIL
	Button = Instance.new("ImageButton")
	Button.Name = "ShiftlockButton"
	Button.Parent = ShiftlockGui
	Button.BackgroundTransparency = 1
	Button.Size = UDim2.new(0.0636, 0, 0.0661, 0)
	Button.Position = UDim2.new(0.9219, 0, 0.5523, 0)
	Button.SizeConstraint = Enum.SizeConstraint.RelativeXX
	Button.Visible = UserInputService.TouchEnabled
	Button.Active = true -- CRÍTICO: Permite interacción
	Button.Modal = false -- No bloquea otros inputs
	Button.ZIndex = 10 -- Asegura que esté por encima
	Button.ImageTransparency = 1 -- Imagen transparente

	-- Fondo del botón
	StateLabelFrame = Instance.new("Frame")
	StateLabelFrame.Parent = Button
	StateLabelFrame.Size = UDim2.new(1, 0, 1, 0)
	StateLabelFrame.BackgroundTransparency = 0.5
	StateLabelFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	StateLabelFrame.ZIndex = 9
	StateLabelFrame.Active = false -- NO debe interceptar toques

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(0.2, 0)
	UICorner.Parent = StateLabelFrame

	-- Etiqueta de estado
	StateLabel = Instance.new("TextLabel")
	StateLabel.Parent = StateLabelFrame
	StateLabel.Size = UDim2.new(1, 0, 1, 0)
	StateLabel.BackgroundTransparency = 1
	StateLabel.Text = "OFF"
	StateLabel.TextColor3 = Color3.new(1, 1, 1)
	StateLabel.TextScaled = true
	StateLabel.Font = Enum.Font.SourceSansBold
	StateLabel.ZIndex = 9
	StateLabel.Active = false -- NO debe interceptar toques

	-- Crosshair
	Crosshair = Instance.new("TextLabel")
	Crosshair.Parent = ShiftlockGui
	Crosshair.Size = UDim2.new(0, 30, 0, 30)
	Crosshair.Position = UDim2.new(0.5, -15, 0.5, -15)
	Crosshair.BackgroundTransparency = 1
	Crosshair.Text = "⊕"
	Crosshair.TextScaled = true
	Crosshair.TextColor3 = Color3.new(1, 1, 1)
	Crosshair.TextStrokeTransparency = 0.5
	Crosshair.Visible = false
	Crosshair.ZIndex = 5
	Crosshair.Active = false

	-- EVENTOS DEL BOTÓN - TODOS LOS POSIBLES
	-- MouseButton1Click para PC
	Button.MouseButton1Click:Connect(function()
	--	print("MouseButton1Click detectado")
		if shiftlockEnabled then
			ShiftLockToggle()
		end
	end)
	
	-- Activated para móvil y consolas
	Button.Activated:Connect(function(inputObject)
	--	print("Activated detectado:", inputObject.UserInputType)
		if shiftlockEnabled then
			ShiftLockToggle()
		end
	end)
	
	-- InputBegan como respaldo adicional
	Button.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch or 
		   input.UserInputType == Enum.UserInputType.MouseButton1 then
		--	print("InputBegan Touch detectado")
			if shiftlockEnabled then
				ShiftLockToggle()
			end
		end
	end)
	
	-- TouchTap específico para móvil
	Button.TouchTap:Connect(function(touchPositions, gameProcessedEvent)
		--print("TouchTap detectado")
		if shiftlockEnabled and not gameProcessedEvent then
			ShiftLockToggle()
		end
	end)
end

local function cleanupShiftlockGui()
	if ShiftlockGui then
		ShiftlockGui:Destroy()
		ShiftlockGui = nil
		Button = nil
		StateLabelFrame = nil
		StateLabel = nil
		Crosshair = nil
	end
end

-- ========================================
-- FUNCIONES DEL SHIFTLOCK
-- ========================================

local function UpdateImage(state)
	if StateLabel then
		StateLabel.Text = state
		if state == "ON" then
			StateLabel.TextColor3 = Color3.new(0, 1, 0)
		else
			StateLabel.TextColor3 = Color3.new(1, 1, 1)
		end
	end
end

local function UpdateAutoRotate(state)
	if humanoid2 then
		humanoid2.AutoRotate = state
	end
end

local function AnimateButtonPress()
	if not Button then return end
	local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local originalSize = UDim2.new(0.0636, 0, 0.0661, 0)
	local shrinkSize = Button.Size - UDim2.new(0.01, 0, 0.01, 0)
	
	local tweenShrink = TweenService:Create(Button, tweenInfo, { Size = shrinkSize })
	local tweenGrow = TweenService:Create(Button, tweenInfo, { Size = originalSize })
	
	tweenShrink:Play()
	tweenShrink.Completed:Connect(function()
		tweenGrow:Play()
	end)
end

function ShiftLockToggle()
--	print("ShiftLockToggle ejecutado - Estado actual:", isActive)
	
	if not ((camera2.CameraSubject == humanoid2 or camera2.CameraSubject == root2) and camera2.CameraType == Enum.CameraType.Custom) then
		--print("Condiciones de cámara no cumplidas")
		return
	end

	AnimateButtonPress()

	if not isActive then
		isActive = true
		UpdateAutoRotate(false)
		UpdateImage("ON")
		
		if Crosshair then 
			Crosshair.Visible = true 
		end
		
		UserInputService.MouseIconEnabled = false
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter

		cameraConnection = RunService.RenderStepped:Connect(function()
			if character2 and root2 and camera2 then
				local direction = camera2.CFrame.LookVector
				local flatDirection = Vector3.new(direction.X, 0, direction.Z)
				if flatDirection.Magnitude > 0 then
					root2.CFrame = CFrame.new(root2.Position, root2.Position + flatDirection)
				end
			end
		end)
		
		--print("Shiftlock ACTIVADO")
	else
		isActive = false
		UpdateAutoRotate(true)
		UpdateImage("OFF")
		
		if Crosshair then 
			Crosshair.Visible = false 
		end
		
		UserInputService.MouseIconEnabled = true
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default

		if cameraConnection then
			cameraConnection:Disconnect()
			cameraConnection = nil
		end
		
		--print("Shiftlock DESACTIVADO")
	end
end

-- ========================================
-- CONEXIÓN DE INPUTS (SOLO TECLADO)
-- ========================================

local function connectInput()
	if inputBeganConnection then return end
	
	inputBeganConnection = UserInputService.InputBegan:Connect(function(input, gp)
		if gp then return end
		
		-- SOLO tecla Q para PC, el botón maneja sus propios eventos
		if input.KeyCode == shiftlockKeybind and shiftlockEnabled then
			--print("Tecla Q presionada")
			ShiftLockToggle()
		end
	end)
end

local function disconnectInput()
	if inputBeganConnection then
		inputBeganConnection:Disconnect()
		inputBeganConnection = nil
	end
end

-- ========================================
-- EVENTOS DEL PERSONAJE
-- ========================================

player.CharacterAdded:Connect(function(char)
	character2 = char
	humanoid2 = character2:WaitForChild("Humanoid")
	root2 = character2:WaitForChild("HumanoidRootPart")
	
	if isActive then
		UpdateAutoRotate(false)
	end
end)

-- ========================================
-- FUNCIÓN TOGGLE PARA TU GUI
-- ========================================

function ToggleShiftlock(Value)
	--print("ToggleShiftlock llamado con valor:", Value)
	shiftlockEnabled = Value
	
	if Value then
		createShiftlockGui()
		connectInput()
		--print("Shiftlock GUI creado - Botón visible:", Button and Button.Visible or "nil")
		--print("Es dispositivo táctil:", UserInputService.TouchEnabled)
	else
		if isActive then
			isActive = false
			UpdateAutoRotate(true)
			UpdateImage("OFF")
			
			if Crosshair then 
				Crosshair.Visible = false 
			end
			
			UserInputService.MouseIconEnabled = true
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			
			if cameraConnection then
				cameraConnection:Disconnect()
				cameraConnection = nil
			end
		end
		
		cleanupShiftlockGui()
		disconnectInput()
	end
end

-- ========================================
-- INTEGRACIÓN CON TU GUI
-- ========================================

if MainTab and MainTab.CreateToggle then
	MainTab:CreateToggle({
		Name = "Shiftlock Activar Q",
		CurrentValue = false,
		Flag = "ShiftlockToggle",
		Callback = function(Value)
			ToggleShiftlock(Value)
		end
	})
end








-- Caminar en el aire
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local isWalkingInAir = false
local floorPart = nil
local heartbeatConnection = nil

-- Detectar si está tocando suelo REAL (no nuestra plataforma)
local function isTouchingRealGround()
    local character = player.Character
    if not character then return false end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not root or not humanoid then return false end
    
    -- Raycast para detectar suelo real
    local rayOrigin = root.Position
    local rayDirection = Vector3.new(0, -4, 0)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character, floorPart}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.IgnoreWater = true
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    -- Verificar si hay suelo real colisionable
    if raycastResult and raycastResult.Instance then
        local hitPart = raycastResult.Instance
        -- Ignorar nuestra plataforma
        if hitPart ~= floorPart and hitPart.CanCollide then
            return true
        end
    end
    
    return false
end

-- Crear el piso invisible
local function createFloor()
    if floorPart then
        floorPart:Destroy()
    end
    
    floorPart = Instance.new("Part")
    floorPart.Name = "InvisibleFloor_JmodsUniversal"
    floorPart.Size = Vector3.new(10, 0.5, 10)
    floorPart.Anchored = true
    floorPart.CanCollide = true
    floorPart.Transparency = 1
    floorPart.Material = Enum.Material.SmoothPlastic
    floorPart.CastShadow = false
    floorPart.Parent = workspace
    
    -- Posición inicial debajo del jugador
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local root = character.HumanoidRootPart
        floorPart.CFrame = CFrame.new(root.Position.X, root.Position.Y - 3, root.Position.Z)
    end
end

-- Limpiar el piso
local function destroyFloor()
    if floorPart then
        floorPart:Destroy()
        floorPart = nil
    end
end

-- Limpiar la conexión
local function disconnectHeartbeat()
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
end

MainTab:CreateToggle({
    Name = "Caminar en el aire",
    CurrentValue = false,
    Flag = "walkInAirToggle",
    Callback = function(Value)
        isWalkingInAir = Value

        if isWalkingInAir then
            -- Activar caminar en el aire
            createFloor()
            disconnectHeartbeat()
            
            heartbeatConnection = RunService.Heartbeat:Connect(function()
                if not isWalkingInAir then
                    disconnectHeartbeat()
                    destroyFloor()
                    return
                end
                
                local character = player.Character
                if not character then return end
                
                local root = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if not root or not floorPart or not humanoid then return end
                
                -- Verificar si está en suelo real
                local onRealGround = isTouchingRealGround()
                
                if onRealGround then
                    -- Si está en suelo real, mover la plataforma lejos
                    floorPart.CFrame = CFrame.new(root.Position.X, root.Position.Y - 1000, root.Position.Z)
                else
                    -- Si está en el aire, mantener la plataforma debajo
                    -- La plataforma sigue al jugador horizontalmente pero mantiene altura relativa
                    local targetY = root.Position.Y - 3
                    
                    -- Si la plataforma está muy lejos verticalmente, reposicionarla
                    local distance = math.abs(floorPart.Position.Y - targetY)
                    if distance > 5 then
                        floorPart.CFrame = CFrame.new(root.Position.X, targetY, root.Position.Z)
                    else
                        -- Solo actualizar posición horizontal para mantener estabilidad
                        floorPart.CFrame = CFrame.new(root.Position.X, floorPart.Position.Y, root.Position.Z)
                    end
                end
            end)
            
        else
            -- Desactivar caminar en el aire
            disconnectHeartbeat()
            destroyFloor()
        end
    end,
})

-- Limpiar al morir o cambiar de personaje
player.CharacterAdded:Connect(function(newChar)
    task.wait(0.3)
    
    if isWalkingInAir then
        destroyFloor()
        disconnectHeartbeat()
        task.wait(0.2)
        createFloor()
    end
end)

-- Limpiar al salir del juego
game:GetService("Players").PlayerRemoving:Connect(function(playerWhoLeft)
    if playerWhoLeft == player then
        disconnectHeartbeat()
        destroyFloor()
    end
end)



-- Mutear sonidos excepto voz
local mutedSounds = {}
local toggleActive = false

local function isVoiceSound(sound)
	if sound:IsDescendantOf(VoiceChatService) then return true end
	local name = sound.Name:lower()
	return name:find("voice") or name:find("vc")
end

local function muteAllExceptVoice()
	for _, sound in ipairs(game:GetDescendants()) do
		if sound:IsA("Sound") and not isVoiceSound(sound) then
			if sound.Playing and sound.Volume > 0 then
				mutedSounds[sound] = sound.Volume
				sound.Volume = 0
			end
		end
	end
end

local function unmuteAll()
	for sound, vol in pairs(mutedSounds) do
		if sound and sound.Parent then
			sound.Volume = vol
		end
	end
	mutedSounds = {}
end

game.DescendantAdded:Connect(function(sound)
	if toggleActive and sound:IsA("Sound") and not isVoiceSound(sound) then
		mutedSounds[sound] = sound.Volume
		sound.Volume = 0
	end
end)

MainTab:CreateToggle({
	Name = "Mutear sonidos (voz no)",
	CurrentValue = false,
	Flag = "MuteAudios",
	Callback = function(Value)
		toggleActive = Value
		if Value then
			muteAllExceptVoice()
		else
			unmuteAll()
		end
	end
})




---Fullbright

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local originalSettings = {}
local connection

MainTab:CreateToggle({
	Name = "Fullbright",
	Flag = "Fullbright",
	CurrentValue = false,
	Callback = function(enabled)
		if enabled then
			-- Guardar valores originales
			originalSettings.Brightness = Lighting.Brightness
			originalSettings.ClockTime = Lighting.ClockTime
			originalSettings.Ambient = Lighting.Ambient
			originalSettings.OutdoorAmbient = Lighting.OutdoorAmbient
			originalSettings.GlobalShadows = Lighting.GlobalShadows

			-- Conexión para forzar iluminación
			if not connection then
				connection = RunService.RenderStepped:Connect(function()
					Lighting.Brightness = 1.5
					Lighting.ClockTime = 12
					Lighting.Ambient = Color3.new(1, 1, 1)
					Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
					Lighting.GlobalShadows = false
				end)
			end
		else
			-- Restaurar valores
			if connection then
				connection:Disconnect()
				connection = nil
			end
			for prop, value in pairs(originalSettings) do
				Lighting[prop] = value
			end
		end
	end
})





-- Servicios y variables necesarias
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local unlockCameraConnection
local cameraUnlocked = false -- INICIALMENTE FALSO
local originalCameraSettings = {}

-- Función para forzar el control de cámara
local function enableCameraControl()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	-- Guardar estado original una sola vez
	if not originalCameraSettings.saved then
		originalCameraSettings.CameraType = Camera.CameraType
		originalCameraSettings.CameraSubject = Camera.CameraSubject
		originalCameraSettings.CameraMode = LocalPlayer.CameraMode
		originalCameraSettings.MaxZoom = LocalPlayer.CameraMaxZoomDistance
		originalCameraSettings.MinZoom = LocalPlayer.CameraMinZoomDistance
		originalCameraSettings.saved = true
	end

	-- Desconectar si ya había una conexión previa
	if unlockCameraConnection then
		unlockCameraConnection:Disconnect()
	end

	unlockCameraConnection = RunService.RenderStepped:Connect(function()
		if not cameraUnlocked then return end

		if Camera.CameraType ~= Enum.CameraType.Custom then
			Camera.CameraType = Enum.CameraType.Custom
		end

		if Camera.CameraSubject ~= humanoid then
			Camera.CameraSubject = humanoid
		end

		LocalPlayer.CameraMode = Enum.CameraMode.Classic
		LocalPlayer.CameraMaxZoomDistance = 128
		LocalPlayer.CameraMinZoomDistance = 0.5
	end)
end

-- TOGGLE: Unlock Camera
MainTab:CreateToggle({
	Name = "Desbloquear Camara",
	Flag = "unlockCam",
	CurrentValue = false,
	Callback = function(enabled)
		cameraUnlocked = enabled

		if enabled then
			enableCameraControl()
		else
			-- Desconectar render loop
			if unlockCameraConnection then
				unlockCameraConnection:Disconnect()
				unlockCameraConnection = nil
			end

			-- Restaurar valores originales si estaban guardados
			if originalCameraSettings.saved then
				Camera.CameraType = originalCameraSettings.CameraType
				Camera.CameraSubject = originalCameraSettings.CameraSubject
				LocalPlayer.CameraMode = originalCameraSettings.CameraMode
				LocalPlayer.CameraMaxZoomDistance = originalCameraSettings.MaxZoom
				LocalPlayer.CameraMinZoomDistance = originalCameraSettings.MinZoom
			end
		end
	end
})

-- Ejecutar enableCameraControl() solo si el toggle está activado al cargar (opcional)
if cameraUnlocked then
	enableCameraControl()
end

-- Reaplicar si reaparece el personaje, pero solo si está activado
LocalPlayer.CharacterAdded:Connect(function()
	if cameraUnlocked then
		enableCameraControl()
	end
end)











-- Asegúrate de que estas variables están definidas
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Variables de control
local boostEnabled = false
local boostStrength = 100
local baseWalkSpeed = 16
local baseJumpPower = 50
local originalStats = {}

-- Función para aplicar boost
local function applyBoost()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid then
		-- Guardar valores originales una vez
		if not originalStats.saved then
			originalStats.WalkSpeed = humanoid.WalkSpeed
			originalStats.JumpPower = humanoid.JumpPower
			originalStats.saved = true
		end

		humanoid.UseJumpPower = true
		local speedMultiplier = (boostStrength * 0.1) / 100
		local jumpMultiplier = (boostStrength * 0.4) / 100
		humanoid.WalkSpeed = baseWalkSpeed * (1 + speedMultiplier)
		humanoid.JumpPower = baseJumpPower * (1 + jumpMultiplier)
	end
end

-- Restaurar valores originales
local function restoreStats()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid and originalStats.saved then
		humanoid.WalkSpeed = originalStats.WalkSpeed
		humanoid.JumpPower = originalStats.JumpPower
	end
end

-- Toggle en MainTab
MainTab:CreateToggle({
	Name = "Salto y Velocidad Indetectable",
	Flag = "movementBoost",
	CurrentValue = false,
	Callback = function(value)
		boostEnabled = value
		if boostEnabled then
			applyBoost()
		else
			restoreStats()
		end
	end
})

-- Slider en MainTab
MainTab:CreateSlider({
	Name = "Aumento Velocidad Indetectable",
	Flag = "boostStrength",
	Range = {0, 100},
	Increment = 5,
	CurrentValue = boostStrength,
	Suffix = "+",
	Callback = function(value)
		boostStrength = value
		if boostEnabled then
			applyBoost()
		end
	end
})








-----







local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local antiFlingEnabled = false
local characterConnections = {}
local collisionLoop

local function SetNoCollision(character)
	for _, item in pairs(character:GetDescendants()) do
		if item:IsA("BasePart") and item.CanCollide then
			item.CanCollide = false
		end
	end
end

local function OnCharacterAdded(player, character)
	if not antiFlingEnabled or player == LocalPlayer then return end
	SetNoCollision(character)

	-- Nuevas partes
	local conn = character.DescendantAdded:Connect(function(desc)
		if desc:IsA("BasePart") then
			desc.CanCollide = false
		end
	end)

	characterConnections[player] = conn
end

local function EnableAntiFling()
	-- Inicial
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			if player.Character then
				OnCharacterAdded(player, player.Character)
			end
			characterConnections[player] = player.CharacterAdded:Connect(function(char)
				OnCharacterAdded(player, char)
			end)
		end
	end

	-- Nuevos jugadores
	characterConnections["_PlayerAdded"] = Players.PlayerAdded:Connect(function(player)
		if player == LocalPlayer then return end
		characterConnections[player] = player.CharacterAdded:Connect(function(char)
			OnCharacterAdded(player, char)
		end)
	end)

	-- Loop seguro cada 0.25s para mantener colisión desactivada
	local timer = 0
	collisionLoop = RunService.Stepped:Connect(function(_, dt)
		timer += dt
		if timer >= 0.25 then
			timer = 0
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character then
					SetNoCollision(player.Character)
				end
			end
		end
	end)
end

local function DisableAntiFling()
	for _, conn in pairs(characterConnections) do
		if typeof(conn) == "RBXScriptConnection" then
			conn:Disconnect()
		end
	end
	characterConnections = {}

	if collisionLoop then
		collisionLoop:Disconnect()
		collisionLoop = nil
	end

	-- Restaurar colisión
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			for _, part in pairs(player.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
				end
			end
		end
	end
end

MainTab:CreateToggle({
	Name = "Anti-Fling",
	CurrentValue = false,
	Callback = function(state)
		antiFlingEnabled = state
		if state then
			EnableAntiFling()
		else
			DisableAntiFling()
		end
	end,
})



-----Anti AFK



local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

local AntiAfkEnabled = false
local AntiAfkThread

MainTab:CreateToggle({
    Name = "Anti-AFK OP",
    CurrentValue = false,
    Flag = "AntiAfkToggle",
    Callback = function(Value)
        AntiAfkEnabled = Value

        if AntiAfkEnabled then
            AntiAfkThread = task.spawn(function()
                while AntiAfkEnabled do
                    -- Simular salto
                    if humanoid and humanoid.Health > 0 then
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end

                    -- Simular rotación de cámara
                    local camCF = camera.CFrame
                    local rotation = CFrame.Angles(0, math.rad(1), 0) -- gira un poco a la derecha
                    camera.CFrame = camCF * rotation

                    task.wait(60) -- cada 60 segundos
                end
            end)
        else
            if AntiAfkThread then
                task.cancel(AntiAfkThread)
                AntiAfkThread = nil
            end
        end
    end,
})




------Cargar guardar posicion

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local savedCFrame = nil
local systemEnabled = false 

MainTab:CreateToggle({
    Name = "Activar Guardar/Cargar",
    CurrentValue = false,
    Flag = "ToggleSistemaPos",
    Callback = function(value)
        systemEnabled = value
    end,
})

MainTab:CreateButton({
    Name = "Guardar Posición",
    Callback = function()
        if not systemEnabled then
            Rayfield:Notify({
                Title = "Sistema Desactivado",
                Content = "Activa el toggle para usar Guardar Posición.",
                Duration = 3,
            })
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            savedCFrame = rootPart.CFrame
        end
    end,
})

MainTab:CreateButton({
    Name = "Cargar Posición",
    Callback = function()
        if not systemEnabled then
            Rayfield:Notify({
                Title = "Sistema Desactivado",
                Content = "Activa el toggle para usar Cargar Posición.",
                Duration = 3,
            })
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if savedCFrame and rootPart then
            rootPart.CFrame = savedCFrame
        end
    end,
})

MainTab:CreateKeybind({
    Name = "Cargar Posición",
    CurrentKeybind = "Q", 
    HoldToInteract = false,
    Flag = "KeybindTP",
    Callback = function()
        if not systemEnabled then return end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if savedCFrame and rootPart then
            rootPart.CFrame = savedCFrame
        end
    end,
})




