-- // Fantasma
-- ========================================
-- FANTASMA
-- ========================================

-- // Servicios
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- // Variables de jugador
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local camera = workspace.CurrentCamera

-- // Variables de ghost
local isGhostMode = false
local ghostPart = nil
local platform = nil
local lastPosition = nil

-- Tabla para guardar las transparencias originales
local originalTransparencies = {}

-- // Movimiento móvil flags
local moveFlags = {
	W = false,
	A = false,
	S = false,
	D = false,
	Space = false,
	LeftControl = false,
}

-- // Variables globales para GUI
local screenGui = nil
local buttons = {}

-- // Conexión del loop de movimiento (SE ACTIVA SOLO CUANDO SE USA)
local heartbeatConnection = nil

-- // Función para crear la GUI móvil (SOLO cuando se activa ghost)
local function createMobileGui()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		buttons = {}
	end

	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "GhostMobileControls"
	screenGui.Parent = player:WaitForChild("PlayerGui")
	screenGui.Enabled = false

	local directions = {{"W", "↑"}, {"S", "↓"}, {"A", "←"}, {"D", "→"}, {"Space", "⎵"}, {"LeftControl", "C"}}

	for i, dir in ipairs(directions) do
		local button = Instance.new("TextButton")
		button.Size = UDim2.new(0, 60, 0, 60)
		button.Position = UDim2.new(0, 10 + (i-1)*65, 1, -70)
		button.Text = dir[2]
		button.BackgroundTransparency = 0.3
		button.TextScaled = true
		button.Name = dir[1]
		button.Parent = screenGui
		buttons[dir[1]] = button

		button.MouseButton1Down:Connect(function()
			moveFlags[dir[1]] = true
		end)
		button.MouseButton1Up:Connect(function()
			moveFlags[dir[1]] = false
		end)
	end
end

-- // Función para limpiar la GUI móvil
local function cleanupMobileGui()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		buttons = {}
	end
end

-- // Funciones originales
local function createPlatform(position)
	if platform then platform:Destroy() end
	platform = Instance.new("Part")
	platform.Name = "PlayerPlatform"
	platform.Size = Vector3.new(10, 1, 10)
	platform.Position = position - Vector3.new(0, 3.5, 0)
	platform.Anchored = true
	platform.BrickColor = BrickColor.new("Really black")
	platform.Transparency = 1
	platform.CanCollide = true
	platform.CastShadow = false
	platform.Parent = workspace
end

local function createGhostPart(position)
	if workspace:FindFirstChild("GhostPart") then
		workspace.GhostPart:Destroy()
	end
	if ghostPart then ghostPart:Destroy() end

	ghostPart = Instance.new("Part")
	ghostPart.Name = "GhostPart"
	ghostPart.Size = Vector3.new(2, 2, 2)
	ghostPart.Position = position.Position + Vector3.new(0, 2, 0)
	ghostPart.Transparency = 0.5
	ghostPart.BrickColor = BrickColor.new("Really white")
	ghostPart.CanCollide = false
	ghostPart.Anchored = false
	ghostPart.Parent = workspace

	local mesh = Instance.new("SpecialMesh")
	mesh.MeshType = Enum.MeshType.FileMesh
	mesh.MeshId = "rbxassetid://11003401773"
	mesh.Scale = Vector3.new(0.15, 0.15, 0.15)
	mesh.Parent = ghostPart

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.Parent = ghostPart

	local bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyGyro.CFrame = CFrame.new(ghostPart.Position)
	bodyGyro.Parent = ghostPart

	camera.CameraSubject = ghostPart
	camera.CameraType = Enum.CameraType.Custom
end

local function updateGhostPartMovement()
	if not isGhostMode or not ghostPart then return end
	local moveDirection = Vector3.new(0, 0, 0)
	local speed = 60
	local cameraCFrame = camera.CFrame

	if UserInputService:IsKeyDown(Enum.KeyCode.W) or moveFlags.W then
		moveDirection += cameraCFrame.LookVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) or moveFlags.S then
		moveDirection -= cameraCFrame.LookVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) or moveFlags.A then
		moveDirection -= cameraCFrame.RightVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) or moveFlags.D then
		moveDirection += cameraCFrame.RightVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.Space) or moveFlags.Space then
		moveDirection += Vector3.new(0, speed, 0)
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or moveFlags.LeftControl then
		moveDirection -= Vector3.new(0, speed, 0)
	end

	local bodyVelocity = ghostPart:FindFirstChildOfClass("BodyVelocity")
	if bodyVelocity then
		bodyVelocity.Velocity = moveDirection
	end
end

-- Función para activar el loop de movimiento
local function connectHeartbeat()
	if heartbeatConnection then return end
	heartbeatConnection = RunService.Heartbeat:Connect(function()
		updateGhostPartMovement()
	end)
end

-- Función para desactivar el loop de movimiento
local function disconnectHeartbeat()
	if heartbeatConnection then
		heartbeatConnection:Disconnect()
		heartbeatConnection = nil
	end
end

-- Función para guardar transparencias originales
local function saveOriginalTransparencies()
	originalTransparencies = {}
	
	for _, obj in pairs(character:GetDescendants()) do
		if obj:IsA("BasePart") or obj:IsA("MeshPart") then
			-- Solo guardar partes que son del cuerpo original del personaje
			-- Ignorar partes que el juego pueda haber añadido
			if obj.Parent == character or (obj.Parent and obj.Parent:IsA("Accessory")) then
				originalTransparencies[obj] = obj.Transparency
			end
		elseif obj:IsA("Decal") then
			if obj.Parent and (obj.Parent.Parent == character or obj.Parent.Name == "Head") then
				originalTransparencies[obj] = obj.Transparency
			end
		end
	end
end

-- Función para restaurar transparencias originales
local function restoreOriginalTransparencies()
	for obj, transparency in pairs(originalTransparencies) do
		if obj and obj.Parent then
			obj.Transparency = transparency
		end
	end
	
	-- Mantener HumanoidRootPart invisible siempre
	if humanoidRootPart then
		humanoidRootPart.Transparency = 1
	end
	
	-- Mantener CollisionPart invisible si existe
	local collidePart = character:FindFirstChild("CollisionPart", true)
	if collidePart and collidePart:IsA("BasePart") then
		collidePart.Transparency = 1
	end
	
	originalTransparencies = {}
end

local function teleportAndGhost()
	if isGhostMode then
		-- DESACTIVAR GHOST MODE
		humanoidRootPart.CFrame = ghostPart and CFrame.new(ghostPart.Position + Vector3.new(0, 3, 0)) or CFrame.new(0, 100, 0)
		character.Humanoid.WalkSpeed = 16
		character.Humanoid.JumpPower = 50

		-- Restaurar transparencias originales
		restoreOriginalTransparencies()

		camera.CameraSubject = character:FindFirstChildOfClass("Humanoid") or character
		camera.CameraType = Enum.CameraType.Custom

		if ghostPart then ghostPart:Destroy() ghostPart = nil end
		if platform then platform:Destroy() platform = nil end

		-- Limpiar GUI y desconectar loop
		cleanupMobileGui()
		disconnectHeartbeat()

		isGhostMode = false
	else
		-- ACTIVAR GHOST MODE
		lastPosition = humanoidRootPart.CFrame
		local teleportPosition = Vector3.new(math.random(-1000, 1000), 100, math.random(-1000, 1000))
		
		-- Guardar transparencias antes de modificar
		saveOriginalTransparencies()
		
		createPlatform(teleportPosition)
		humanoidRootPart.CFrame = CFrame.new(teleportPosition)
		createGhostPart(lastPosition)
		character.Humanoid.WalkSpeed = 0
		character.Humanoid.JumpPower = 0

		-- Hacer invisibles SOLO las partes del personaje original
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") or part:IsA("MeshPart") then
				-- Solo afectar partes del cuerpo y accesorios
				if part.Parent == character or (part.Parent and part.Parent:IsA("Accessory")) then
					part.Transparency = 1
				end
			elseif part:IsA("Decal") then
				-- Mantener decals visibles (cara)
				if part.Parent and (part.Parent.Parent == character or part.Parent.Name == "Head") then
					part.Transparency = 0
				end
			end
		end

		-- Crear GUI solo si es móvil
		if UserInputService.TouchEnabled then
			createMobileGui()
			if screenGui then
				screenGui.Enabled = true
			end
		end

		-- Conectar el loop de movimiento
		connectHeartbeat()

		isGhostMode = true
	end
end

-- // Manejo de respawn
player.CharacterAdded:Connect(function(char)
	character = char
	humanoidRootPart = char:WaitForChild("HumanoidRootPart")

	if isGhostMode then
		if ghostPart then ghostPart:Destroy() ghostPart = nil end
		if platform then platform:Destroy() platform = nil end
		camera.CameraSubject = character:WaitForChild("Humanoid")
		camera.CameraType = Enum.CameraType.Custom
		isGhostMode = false
		cleanupMobileGui()
		disconnectHeartbeat()
	end

	if platform then platform:Destroy() platform = nil end

	local collidePart = character:FindFirstChild("CollisionPart", true)
	if collidePart then
		collidePart.Transparency = 1
	end
end)

-- // Toggle Rayfield
MainTab:CreateToggle({
	Name = "Fantasma",
	CurrentValue = false,
	Flag = "InvincibilityToggle",
	Callback = function(Value)
		if Value and not isGhostMode then
			teleportAndGhost()
		elseif not Value and isGhostMode then
			teleportAndGhost()
		end
	end,
})







-- ========================================
-- SHIFTLOCK NUEVO - INTEGRACIÓN INMEDIATA
-- Se crea exactamente donde lo colocas en el código
-- ========================================

-- ========================================
-- MÓDULO DE SERVICIOS
-- ========================================
local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService")
}

-- ========================================
-- MÓDULO DE ESTADO
-- ========================================
local State = {
    enabled = false,
    active = false,
    player = Services.Players.LocalPlayer,
    camera = workspace.CurrentCamera,
    character = nil,
    humanoid = nil,
    rootPart = nil,
    connections = {},
    uiElements = {}
}

-- ========================================
-- MÓDULO DE CONFIGURACIÓN
-- ========================================
local Config = {
    keybind = Enum.KeyCode.Q,
    crosshairSymbol = "⊕",
    crosshairSize = 30,
    buttonPosition = UDim2.new(0.92, 0, 0.55, 0),
    buttonSize = UDim2.new(0.06, 0, 0.065, 0),
    showMobileButton = true
}

-- ========================================
-- MÓDULO DE UTILIDADES
-- ========================================
local Utils = {}

function Utils.cleanupConnections()
    for name, connection in pairs(State.connections) do
        if connection then
            connection:Disconnect()
        end
        State.connections[name] = nil
    end
end

function Utils.updateCharacterReferences()
    State.character = State.player.Character
    if State.character then
        State.humanoid = State.character:WaitForChild("Humanoid", 5)
        State.rootPart = State.character:WaitForChild("HumanoidRootPart", 5)
        return true
    end
    return false
end

function Utils.isValidForShiftlock()
    if not State.camera or not State.humanoid or not State.rootPart then
        return false
    end
    
    local validSubject = (State.camera.CameraSubject == State.humanoid or 
                         State.camera.CameraSubject == State.rootPart)
    local validType = State.camera.CameraType == Enum.CameraType.Custom
    
    return validSubject and validType
end

-- ========================================
-- MÓDULO DE INTERFAZ
-- ========================================
local UI = {}

function UI.create()
    UI.destroy()
    
    local playerGui = State.player:WaitForChild("PlayerGui")
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "NewShiftlockUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = playerGui
    
    State.uiElements.screenGui = screenGui
    
    if Services.UserInputService.TouchEnabled and Config.showMobileButton then
        UI.createMobileButton(screenGui)
    end
    
    UI.createCrosshair(screenGui)
    
    return true
end

function UI.createMobileButton(parent)
    local button = Instance.new("TextButton")
    button.Name = "MobileShiftlockBtn"
    button.Size = Config.buttonSize
    button.Position = Config.buttonPosition
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BackgroundTransparency = 0.3
    button.BorderSizePixel = 0
    button.Text = "OFF"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextScaled = true
    button.Font = Enum.Font.GothamBold
    button.ZIndex = 10
    button.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.25, 0)
    corner.Parent = button
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Thickness = 2
    stroke.Transparency = 0.5
    stroke.Parent = button
    
    State.uiElements.button = button
    State.uiElements.stroke = stroke
    
    button.Activated:Connect(function()
        ShiftlockCore.toggle()
    end)
    
    button.MouseButton1Click:Connect(function()
        ShiftlockCore.toggle()
    end)
end

function UI.createCrosshair(parent)
    local crosshair = Instance.new("TextLabel")
    crosshair.Name = "ShiftlockCrosshair"
    crosshair.Size = UDim2.new(0, Config.crosshairSize, 0, Config.crosshairSize)
    crosshair.Position = UDim2.new(0.5, -Config.crosshairSize/2, 0.5, -Config.crosshairSize/2)
    crosshair.BackgroundTransparency = 1
    crosshair.Text = Config.crosshairSymbol
    crosshair.TextColor3 = Color3.fromRGB(255, 255, 255)
    crosshair.TextScaled = true
    crosshair.TextStrokeTransparency = 0.5
    crosshair.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    crosshair.Font = Enum.Font.Code
    crosshair.Visible = false
    crosshair.ZIndex = 5
    crosshair.Parent = parent
    
    State.uiElements.crosshair = crosshair
end

function UI.updateButton(isActive)
    if State.uiElements.button then
        local button = State.uiElements.button
        local stroke = State.uiElements.stroke
        
        if isActive then
            button.Text = "ON"
            button.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
            if stroke then
                stroke.Color = Color3.fromRGB(100, 255, 100)
            end
        else
            button.Text = "OFF"
            button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            if stroke then
                stroke.Color = Color3.fromRGB(255, 255, 255)
            end
        end
        
        local tween = Services.TweenService:Create(
            button,
            TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = Config.buttonSize * 0.9}
        )
        tween:Play()
        tween.Completed:Connect(function()
            Services.TweenService:Create(
                button,
                TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {Size = Config.buttonSize}
            ):Play()
        end)
    end
end

function UI.updateCrosshair(visible)
    if State.uiElements.crosshair then
        State.uiElements.crosshair.Visible = visible
    end
end

function UI.destroy()
    if State.uiElements.screenGui then
        State.uiElements.screenGui:Destroy()
    end
    State.uiElements = {}
end

-- ========================================
-- MÓDULO DE ROTACIÓN
-- ========================================
local Rotation = {}

function Rotation.start()
    if not Utils.isValidForShiftlock() then
        return false
    end
    
    if State.humanoid then
        State.humanoid.AutoRotate = false
    end
    
    State.connections.rotation = Services.RunService.RenderStepped:Connect(function()
        Rotation.update()
    end)
    
    State.connections.autoRotateKeeper = Services.RunService.Heartbeat:Connect(function()
        if State.humanoid and State.humanoid.AutoRotate then
            State.humanoid.AutoRotate = false
        end
    end)
    
    return true
end

function Rotation.update()
    if not State.camera or not State.rootPart or not State.character then
        return
    end
    
    local cameraDirection = State.camera.CFrame.LookVector
    local flatDirection = Vector3.new(cameraDirection.X, 0, cameraDirection.Z)
    
    if flatDirection.Magnitude > 0.01 then
        local targetPosition = State.rootPart.Position + flatDirection
        local newCFrame = CFrame.new(State.rootPart.Position, targetPosition)
        State.rootPart.CFrame = newCFrame
    end
end

function Rotation.stop()
    if State.connections.rotation then
        State.connections.rotation:Disconnect()
        State.connections.rotation = nil
    end
    
    if State.connections.autoRotateKeeper then
        State.connections.autoRotateKeeper:Disconnect()
        State.connections.autoRotateKeeper = nil
    end
    
    if State.humanoid then
        State.humanoid.AutoRotate = true
    end
end

-- ========================================
-- MÓDULO DE INPUT
-- ========================================
local Input = {}

function Input.setup()
    if State.connections.input then
        State.connections.input:Disconnect()
    end
    
    State.connections.input = Services.UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Config.keybind and State.enabled then
            ShiftlockCore.toggle()
        end
    end)
end

function Input.cleanup()
    if State.connections.input then
        State.connections.input:Disconnect()
        State.connections.input = nil
    end
end

-- ========================================
-- MÓDULO PRINCIPAL (CORE)
-- ========================================
ShiftlockCore = {}

function ShiftlockCore.activate()
    if State.active then return end
    if not Utils.isValidForShiftlock() then return end
    
    State.active = true
    
    Services.UserInputService.MouseIconEnabled = false
    Services.UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
    
    Rotation.start()
    
    UI.updateButton(true)
    UI.updateCrosshair(true)
end

function ShiftlockCore.deactivate()
    if not State.active then return end
    
    State.active = false
    
    Services.UserInputService.MouseIconEnabled = true
    Services.UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    
    Rotation.stop()
    
    UI.updateButton(false)
    UI.updateCrosshair(false)
end

function ShiftlockCore.toggle()
    if State.active then
        ShiftlockCore.deactivate()
    else
        ShiftlockCore.activate()
    end
end

function ShiftlockCore.enable()
    if State.enabled then return end
    
    State.enabled = true
    Utils.updateCharacterReferences()
    UI.create()
    Input.setup()
end

function ShiftlockCore.disable()
    if not State.enabled then return end
    
    State.enabled = false
    
    if State.active then
        ShiftlockCore.deactivate()
    end
    
    Utils.cleanupConnections()
    UI.destroy()
    Input.cleanup()
end

-- ========================================
-- EVENTOS DE PERSONAJE
-- ========================================
State.player.CharacterAdded:Connect(function(newCharacter)
    task.wait(0.5)
    Utils.updateCharacterReferences()
    
    if State.enabled and State.active then
        task.wait(0.5)
        ShiftlockCore.activate()
    end
end)

-- ========================================
-- FUNCIÓN PRINCIPAL PARA TU GUI
-- ========================================
function ToggleShiftlock(value)
    if value then
        ShiftlockCore.enable()
    else
        ShiftlockCore.disable()
    end
end

-- ========================================
-- INTEGRACIÓN INMEDIATA (SIN DELAYS)
-- ========================================
if MainTab and MainTab.CreateToggle then
    MainTab:CreateToggle({
        Name = "Shiftlock Nuevo (Q)",
        CurrentValue = false,
        Flag = "NewShiftlock",
        Callback = function(Value)
            ToggleShiftlock(Value)
        end
    })
end

-- ========================================
-- FUNCIONES GLOBALES
-- ========================================
getgenv().NewShiftlock = {
    Enable = ShiftlockCore.enable,
    Disable = ShiftlockCore.disable,
    Toggle = ShiftlockCore.toggle,
    IsActive = function() return State.active end,
    IsEnabled = function() return State.enabled end,
    SetKeybind = function(keycode) Config.keybind = keycode end
}

getgenv().ToggleShiftlock = ToggleShiftlock














-- Caminar en el aire
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local isWalkingInAir = false
local floorPart = nil
local heartbeatConnection = nil

-- Detectar si está tocando suelo REAL (no nuestra plataforma)
local function isTouchingRealGround()
    local character = player.Character
    if not character then return false end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not root or not humanoid then return false end
    
    -- Raycast para detectar suelo real
    local rayOrigin = root.Position
    local rayDirection = Vector3.new(0, -4, 0)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character, floorPart}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.IgnoreWater = true
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    -- Verificar si hay suelo real colisionable
    if raycastResult and raycastResult.Instance then
        local hitPart = raycastResult.Instance
        -- Ignorar nuestra plataforma
        if hitPart ~= floorPart and hitPart.CanCollide then
            return true
        end
    end
    
    return false
end

-- Crear el piso invisible
local function createFloor()
    if floorPart then
        floorPart:Destroy()
    end
    
    floorPart = Instance.new("Part")
    floorPart.Name = "InvisibleFloor_JmodsUniversal"
    floorPart.Size = Vector3.new(10, 0.5, 10)
    floorPart.Anchored = true
    floorPart.CanCollide = true
    floorPart.Transparency = 1
    floorPart.Material = Enum.Material.SmoothPlastic
    floorPart.CastShadow = false
    floorPart.Parent = workspace
    
    -- Posición inicial debajo del jugador
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local root = character.HumanoidRootPart
        floorPart.CFrame = CFrame.new(root.Position.X, root.Position.Y - 3, root.Position.Z)
    end
end

-- Limpiar el piso
local function destroyFloor()
    if floorPart then
        floorPart:Destroy()
        floorPart = nil
    end
end

-- Limpiar la conexión
local function disconnectHeartbeat()
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
end

MainTab:CreateToggle({
    Name = "Caminar en el aire",
    CurrentValue = false,
    Flag = "walkInAirToggle",
    Callback = function(Value)
        isWalkingInAir = Value

        if isWalkingInAir then
            -- Activar caminar en el aire
            createFloor()
            disconnectHeartbeat()
            
            heartbeatConnection = RunService.Heartbeat:Connect(function()
                if not isWalkingInAir then
                    disconnectHeartbeat()
                    destroyFloor()
                    return
                end
                
                local character = player.Character
                if not character then return end
                
                local root = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if not root or not floorPart or not humanoid then return end
                
                -- Verificar si está en suelo real
                local onRealGround = isTouchingRealGround()
                
                if onRealGround then
                    -- Si está en suelo real, mover la plataforma lejos
                    floorPart.CFrame = CFrame.new(root.Position.X, root.Position.Y - 1000, root.Position.Z)
                else
                    -- Si está en el aire, mantener la plataforma debajo
                    -- La plataforma sigue al jugador horizontalmente pero mantiene altura relativa
                    local targetY = root.Position.Y - 3
                    
                    -- Si la plataforma está muy lejos verticalmente, reposicionarla
                    local distance = math.abs(floorPart.Position.Y - targetY)
                    if distance > 5 then
                        floorPart.CFrame = CFrame.new(root.Position.X, targetY, root.Position.Z)
                    else
                        -- Solo actualizar posición horizontal para mantener estabilidad
                        floorPart.CFrame = CFrame.new(root.Position.X, floorPart.Position.Y, root.Position.Z)
                    end
                end
            end)
            
        else
            -- Desactivar caminar en el aire
            disconnectHeartbeat()
            destroyFloor()
        end
    end,
})

-- Limpiar al morir o cambiar de personaje
player.CharacterAdded:Connect(function(newChar)
    task.wait(0.3)
    
    if isWalkingInAir then
        destroyFloor()
        disconnectHeartbeat()
        task.wait(0.2)
        createFloor()
    end
end)

-- Limpiar al salir del juego
game:GetService("Players").PlayerRemoving:Connect(function(playerWhoLeft)
    if playerWhoLeft == player then
        disconnectHeartbeat()
        destroyFloor()
    end
end)



-- Mutear sonidos excepto voz
local mutedSounds = {}
local toggleActive = false

local function isVoiceSound(sound)
	if sound:IsDescendantOf(VoiceChatService) then return true end
	local name = sound.Name:lower()
	return name:find("voice") or name:find("vc")
end

local function muteAllExceptVoice()
	for _, sound in ipairs(game:GetDescendants()) do
		if sound:IsA("Sound") and not isVoiceSound(sound) then
			if sound.Playing and sound.Volume > 0 then
				mutedSounds[sound] = sound.Volume
				sound.Volume = 0
			end
		end
	end
end

local function unmuteAll()
	for sound, vol in pairs(mutedSounds) do
		if sound and sound.Parent then
			sound.Volume = vol
		end
	end
	mutedSounds = {}
end

game.DescendantAdded:Connect(function(sound)
	if toggleActive and sound:IsA("Sound") and not isVoiceSound(sound) then
		mutedSounds[sound] = sound.Volume
		sound.Volume = 0
	end
end)

MainTab:CreateToggle({
	Name = "Mutear sonidos (voz no)",
	CurrentValue = false,
	Flag = "MuteAudios",
	Callback = function(Value)
		toggleActive = Value
		if Value then
			muteAllExceptVoice()
		else
			unmuteAll()
		end
	end
})




---Fullbright

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local originalSettings = {}
local connection

MainTab:CreateToggle({
	Name = "Fullbright",
	Flag = "Fullbright",
	CurrentValue = false,
	Callback = function(enabled)
		if enabled then
			-- Guardar valores originales
			originalSettings.Brightness = Lighting.Brightness
			originalSettings.ClockTime = Lighting.ClockTime
			originalSettings.Ambient = Lighting.Ambient
			originalSettings.OutdoorAmbient = Lighting.OutdoorAmbient
			originalSettings.GlobalShadows = Lighting.GlobalShadows

			-- Conexión para forzar iluminación
			if not connection then
				connection = RunService.RenderStepped:Connect(function()
					Lighting.Brightness = 1.5
					Lighting.ClockTime = 12
					Lighting.Ambient = Color3.new(1, 1, 1)
					Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
					Lighting.GlobalShadows = false
				end)
			end
		else
			-- Restaurar valores
			if connection then
				connection:Disconnect()
				connection = nil
			end
			for prop, value in pairs(originalSettings) do
				Lighting[prop] = value
			end
		end
	end
})





-- Servicios y variables necesarias
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local unlockCameraConnection
local cameraUnlocked = false -- INICIALMENTE FALSO
local originalCameraSettings = {}

-- Función para forzar el control de cámara
local function enableCameraControl()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	-- Guardar estado original una sola vez
	if not originalCameraSettings.saved then
		originalCameraSettings.CameraType = Camera.CameraType
		originalCameraSettings.CameraSubject = Camera.CameraSubject
		originalCameraSettings.CameraMode = LocalPlayer.CameraMode
		originalCameraSettings.MaxZoom = LocalPlayer.CameraMaxZoomDistance
		originalCameraSettings.MinZoom = LocalPlayer.CameraMinZoomDistance
		originalCameraSettings.saved = true
	end

	-- Desconectar si ya había una conexión previa
	if unlockCameraConnection then
		unlockCameraConnection:Disconnect()
	end

	unlockCameraConnection = RunService.RenderStepped:Connect(function()
		if not cameraUnlocked then return end

		if Camera.CameraType ~= Enum.CameraType.Custom then
			Camera.CameraType = Enum.CameraType.Custom
		end

		if Camera.CameraSubject ~= humanoid then
			Camera.CameraSubject = humanoid
		end

		LocalPlayer.CameraMode = Enum.CameraMode.Classic
		LocalPlayer.CameraMaxZoomDistance = 128
		LocalPlayer.CameraMinZoomDistance = 0.5
	end)
end

-- TOGGLE: Unlock Camera
MainTab:CreateToggle({
	Name = "Desbloquear Camara",
	Flag = "unlockCam",
	CurrentValue = false,
	Callback = function(enabled)
		cameraUnlocked = enabled

		if enabled then
			enableCameraControl()
		else
			-- Desconectar render loop
			if unlockCameraConnection then
				unlockCameraConnection:Disconnect()
				unlockCameraConnection = nil
			end

			-- Restaurar valores originales si estaban guardados
			if originalCameraSettings.saved then
				Camera.CameraType = originalCameraSettings.CameraType
				Camera.CameraSubject = originalCameraSettings.CameraSubject
				LocalPlayer.CameraMode = originalCameraSettings.CameraMode
				LocalPlayer.CameraMaxZoomDistance = originalCameraSettings.MaxZoom
				LocalPlayer.CameraMinZoomDistance = originalCameraSettings.MinZoom
			end
		end
	end
})

-- Ejecutar enableCameraControl() solo si el toggle está activado al cargar (opcional)
if cameraUnlocked then
	enableCameraControl()
end

-- Reaplicar si reaparece el personaje, pero solo si está activado
LocalPlayer.CharacterAdded:Connect(function()
	if cameraUnlocked then
		enableCameraControl()
	end
end)











-- Asegúrate de que estas variables están definidas
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Variables de control
local boostEnabled = false
local boostStrength = 100
local baseWalkSpeed = 16
local baseJumpPower = 50
local originalStats = {}

-- Función para aplicar boost
local function applyBoost()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid then
		-- Guardar valores originales una vez
		if not originalStats.saved then
			originalStats.WalkSpeed = humanoid.WalkSpeed
			originalStats.JumpPower = humanoid.JumpPower
			originalStats.saved = true
		end

		humanoid.UseJumpPower = true
		local speedMultiplier = (boostStrength * 0.1) / 100
		local jumpMultiplier = (boostStrength * 0.4) / 100
		humanoid.WalkSpeed = baseWalkSpeed * (1 + speedMultiplier)
		humanoid.JumpPower = baseJumpPower * (1 + jumpMultiplier)
	end
end

-- Restaurar valores originales
local function restoreStats()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid and originalStats.saved then
		humanoid.WalkSpeed = originalStats.WalkSpeed
		humanoid.JumpPower = originalStats.JumpPower
	end
end

-- Toggle en MainTab
MainTab:CreateToggle({
	Name = "Salto y Velocidad Indetectable",
	Flag = "movementBoost",
	CurrentValue = false,
	Callback = function(value)
		boostEnabled = value
		if boostEnabled then
			applyBoost()
		else
			restoreStats()
		end
	end
})

-- Slider en MainTab
MainTab:CreateSlider({
	Name = "Aumento Velocidad Indetectable",
	Flag = "boostStrength",
	Range = {0, 100},
	Increment = 5,
	CurrentValue = boostStrength,
	Suffix = "+",
	Callback = function(value)
		boostStrength = value
		if boostEnabled then
			applyBoost()
		end
	end
})








-----







local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local antiFlingEnabled = false
local characterConnections = {}
local collisionLoop

local function SetNoCollision(character)
	for _, item in pairs(character:GetDescendants()) do
		if item:IsA("BasePart") and item.CanCollide then
			item.CanCollide = false
		end
	end
end

local function OnCharacterAdded(player, character)
	if not antiFlingEnabled or player == LocalPlayer then return end
	SetNoCollision(character)

	-- Nuevas partes
	local conn = character.DescendantAdded:Connect(function(desc)
		if desc:IsA("BasePart") then
			desc.CanCollide = false
		end
	end)

	characterConnections[player] = conn
end

local function EnableAntiFling()
	-- Inicial
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			if player.Character then
				OnCharacterAdded(player, player.Character)
			end
			characterConnections[player] = player.CharacterAdded:Connect(function(char)
				OnCharacterAdded(player, char)
			end)
		end
	end

	-- Nuevos jugadores
	characterConnections["_PlayerAdded"] = Players.PlayerAdded:Connect(function(player)
		if player == LocalPlayer then return end
		characterConnections[player] = player.CharacterAdded:Connect(function(char)
			OnCharacterAdded(player, char)
		end)
	end)

	-- Loop seguro cada 0.25s para mantener colisión desactivada
	local timer = 0
	collisionLoop = RunService.Stepped:Connect(function(_, dt)
		timer += dt
		if timer >= 0.25 then
			timer = 0
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character then
					SetNoCollision(player.Character)
				end
			end
		end
	end)
end

local function DisableAntiFling()
	for _, conn in pairs(characterConnections) do
		if typeof(conn) == "RBXScriptConnection" then
			conn:Disconnect()
		end
	end
	characterConnections = {}

	if collisionLoop then
		collisionLoop:Disconnect()
		collisionLoop = nil
	end

	-- Restaurar colisión
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			for _, part in pairs(player.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
				end
			end
		end
	end
end

MainTab:CreateToggle({
	Name = "Anti-Fling",
	CurrentValue = false,
	Callback = function(state)
		antiFlingEnabled = state
		if state then
			EnableAntiFling()
		else
			DisableAntiFling()
		end
	end,
})



-----Anti AFK



local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

local AntiAfkEnabled = false
local AntiAfkThread

MainTab:CreateToggle({
    Name = "Anti-AFK OP",
    CurrentValue = false,
    Flag = "AntiAfkToggle",
    Callback = function(Value)
        AntiAfkEnabled = Value

        if AntiAfkEnabled then
            AntiAfkThread = task.spawn(function()
                while AntiAfkEnabled do
                    -- Simular salto
                    if humanoid and humanoid.Health > 0 then
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end

                    -- Simular rotación de cámara
                    local camCF = camera.CFrame
                    local rotation = CFrame.Angles(0, math.rad(1), 0) -- gira un poco a la derecha
                    camera.CFrame = camCF * rotation

                    task.wait(60) -- cada 60 segundos
                end
            end)
        else
            if AntiAfkThread then
                task.cancel(AntiAfkThread)
                AntiAfkThread = nil
            end
        end
    end,
})




------Cargar guardar posicion

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local savedCFrame = nil
local systemEnabled = false 

MainTab:CreateToggle({
    Name = "Activar Guardar/Cargar",
    CurrentValue = false,
    Flag = "ToggleSistemaPos",
    Callback = function(value)
        systemEnabled = value
    end,
})

MainTab:CreateButton({
    Name = "Guardar Posición",
    Callback = function()
        if not systemEnabled then
            Rayfield:Notify({
                Title = "Sistema Desactivado",
                Content = "Activa el toggle para usar Guardar Posición.",
                Duration = 3,
            })
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            savedCFrame = rootPart.CFrame
        end
    end,
})

MainTab:CreateButton({
    Name = "Cargar Posición",
    Callback = function()
        if not systemEnabled then
            Rayfield:Notify({
                Title = "Sistema Desactivado",
                Content = "Activa el toggle para usar Cargar Posición.",
                Duration = 3,
            })
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if savedCFrame and rootPart then
            rootPart.CFrame = savedCFrame
        end
    end,
})

MainTab:CreateKeybind({
    Name = "Cargar Posición",
    CurrentKeybind = "Q", 
    HoldToInteract = false,
    Flag = "KeybindTP",
    Callback = function()
        if not systemEnabled then return end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if savedCFrame and rootPart then
            rootPart.CFrame = savedCFrame
        end
    end,
})



----


-- Variables para guardar configuraciones originales
local originalSettings = {
    Lighting = {},
    Terrain = {},
    Rendering = {},
    Materials = {},
    Parts = {},
    MeshParts = {},
    Particles = {},
    Explosions = {},
    PostEffects = {}
}

local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local MaterialService = game:GetService("MaterialService")
local ME = Players.LocalPlayer
local fpsBoosterActive = false
local descendantConnection = nil
local modifiedInstances = {}

-- Guardar configuraciones originales
function SaveOriginalSettings()
    -- Lighting
    originalSettings.Lighting.GlobalShadows = Lighting.GlobalShadows
    originalSettings.Lighting.FogEnd = Lighting.FogEnd
    originalSettings.Lighting.ShadowSoftness = Lighting.ShadowSoftness
    if sethiddenproperty then
        originalSettings.Lighting.Technology = Lighting.Technology
    end
    
    -- Terrain
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        originalSettings.Terrain.WaterWaveSize = terrain.WaterWaveSize
        originalSettings.Terrain.WaterWaveSpeed = terrain.WaterWaveSpeed
        originalSettings.Terrain.WaterReflectance = terrain.WaterReflectance
        originalSettings.Terrain.WaterTransparency = terrain.WaterTransparency
        
        -- CORRECCIÓN: Guardar Decoration para restaurar el pasto
        if sethiddenproperty then
            pcall(function()
                originalSettings.Terrain.Decoration = gethiddenproperty(terrain, "Decoration")
            end)
        end
    end
    
    -- Rendering
    originalSettings.Rendering.QualityLevel = settings().Rendering.QualityLevel
    originalSettings.Rendering.MeshPartDetailLevel = settings().Rendering.MeshPartDetailLevel
    
    -- Materials
    originalSettings.Materials.Use2022Materials = MaterialService.Use2022Materials
end

-- Restaurar configuraciones originales
function RestoreOriginalSettings()
    -- Lighting
    Lighting.GlobalShadows = originalSettings.Lighting.GlobalShadows
    Lighting.FogEnd = originalSettings.Lighting.FogEnd
    Lighting.ShadowSoftness = originalSettings.Lighting.ShadowSoftness
    if sethiddenproperty and originalSettings.Lighting.Technology then
        sethiddenproperty(Lighting, "Technology", originalSettings.Lighting.Technology)
    end
    
    -- Terrain
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        terrain.WaterWaveSize = originalSettings.Terrain.WaterWaveSize
        terrain.WaterWaveSpeed = originalSettings.Terrain.WaterWaveSpeed
        terrain.WaterReflectance = originalSettings.Terrain.WaterReflectance
        terrain.WaterTransparency = originalSettings.Terrain.WaterTransparency
        
        -- CORRECCIÓN: Restaurar Decoration para que vuelva el pasto
        if sethiddenproperty and originalSettings.Terrain.Decoration ~= nil then
            pcall(function()
                sethiddenproperty(terrain, "Decoration", originalSettings.Terrain.Decoration)
            end)
        end
    end
    
    -- Rendering
    settings().Rendering.QualityLevel = originalSettings.Rendering.QualityLevel
    settings().Rendering.MeshPartDetailLevel = originalSettings.Rendering.MeshPartDetailLevel
    
    -- Materials
    MaterialService.Use2022Materials = originalSettings.Materials.Use2022Materials
    
    -- Restaurar instancias modificadas
    for inst, data in pairs(modifiedInstances) do
        if inst and inst.Parent then
            pcall(function()
                if inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Smoke") or inst:IsA("Fire") or inst:IsA("Sparkles") then
                    inst.Enabled = data.Enabled
                elseif inst:IsA("PostEffect") then
                    inst.Enabled = data.Enabled
                elseif inst:IsA("BasePart") and not inst:IsA("MeshPart") then
                    inst.Material = data.Material
                    inst.Reflectance = data.Reflectance
                elseif inst:IsA("MeshPart") then
                    inst.RenderFidelity = data.RenderFidelity
                    inst.Reflectance = data.Reflectance
                    inst.Material = data.Material
                    inst.Transparency = data.Transparency
                elseif inst:IsA("SpecialMesh") then
                    inst.MeshId = data.MeshId
                    inst.TextureId = data.TextureId
                elseif inst:IsA("FaceInstance") then
                    inst.Transparency = data.Transparency
                    inst.Shiny = data.Shiny
                elseif inst:IsA("Model") then
                    inst.LevelOfDetail = data.LevelOfDetail
                end
            end)
        end
    end
    
    modifiedInstances = {}
end

-- Verificar si una instancia debe ser ignorada
function ShouldIgnore(Inst)
    if Inst:IsDescendantOf(Players) then return true end
    if ME.Character and Inst:IsDescendantOf(ME.Character) then return true end
    if Inst:IsA("BackpackItem") or Inst:FindFirstAncestorWhichIsA("BackpackItem") then return true end
    
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= ME and v.Character and Inst:IsDescendantOf(v.Character) then
            return true
        end
    end
    
    return false
end

-- Aplicar optimizaciones a una instancia
function OptimizeInstance(Inst)
    if ShouldIgnore(Inst) then return end
    
    pcall(function()
        if Inst:IsA("ParticleEmitter") or Inst:IsA("Trail") or Inst:IsA("Smoke") or Inst:IsA("Fire") or Inst:IsA("Sparkles") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {Enabled = Inst.Enabled}
            end
            Inst.Enabled = false
            
        elseif Inst:IsA("PostEffect") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {Enabled = Inst.Enabled}
            end
            Inst.Enabled = false
            
        elseif Inst:IsA("Explosion") then
            Inst.BlastPressure = 1
            Inst.BlastRadius = 1
            
        elseif Inst:IsA("SpecialMesh") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    MeshId = Inst.MeshId,
                    TextureId = Inst.TextureId
                }
            end
            Inst.TextureId = ""
            
        elseif Inst:IsA("FaceInstance") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    Transparency = Inst.Transparency,
                    Shiny = Inst.Shiny
                }
            end
            Inst.Transparency = 1
            Inst.Shiny = 1
            
        elseif Inst:IsA("BasePart") and not Inst:IsA("MeshPart") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    Material = Inst.Material,
                    Reflectance = Inst.Reflectance
                }
            end
            Inst.Material = Enum.Material.Plastic
            Inst.Reflectance = 0
            
        elseif Inst:IsA("MeshPart") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    RenderFidelity = Inst.RenderFidelity,
                    Reflectance = Inst.Reflectance,
                    Material = Inst.Material,
                    Transparency = Inst.Transparency
                }
            end
            Inst.RenderFidelity = Enum.RenderFidelity.Performance
            Inst.Reflectance = 0
            Inst.Material = Enum.Material.Plastic
            
        elseif Inst:IsA("Model") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    LevelOfDetail = Inst.LevelOfDetail
                }
            end
            Inst.LevelOfDetail = Enum.ModelLevelOfDetail.StreamingMesh
        end
    end)
end

-- Aplicar todas las optimizaciones
function ApplyOptimizations()
    -- Optimizaciones de Lighting
    Lighting.GlobalShadows = false
    Lighting.FogEnd = 9e9
    Lighting.ShadowSoftness = 0
    if sethiddenproperty then
        sethiddenproperty(Lighting, "Technology", 2)
    end
    
    -- Optimizaciones de Terrain
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        terrain.WaterWaveSize = 0
        terrain.WaterWaveSpeed = 0
        terrain.WaterReflectance = 0
        terrain.WaterTransparency = 0
        if sethiddenproperty then
            sethiddenproperty(terrain, "Decoration", false)
        end
    end
    
    -- Optimizaciones de Rendering
    settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level04
    
    -- Optimizaciones de Materials
    MaterialService.Use2022Materials = false
    
    -- FPS Cap
    if setfpscap then
        setfpscap(1e6)
    end
    
    -- Optimizar todas las instancias existentes
    for _, v in pairs(game:GetDescendants()) do
        OptimizeInstance(v)
    end
end

-- Guardar configuraciones originales al inicio
SaveOriginalSettings()



-- Toggle principal
MainTab:CreateToggle({
    Name = "Activar FPS Booster",
    CurrentValue = false,
    Callback = function(state)
        fpsBoosterActive = state
        
        if state then
            -- Activar optimizaciones
            ApplyOptimizations()
            
            -- Conectar evento para nuevas instancias
            if descendantConnection then
                descendantConnection:Disconnect()
            end
            
            descendantConnection = game.DescendantAdded:Connect(function(inst)
                task.wait(0.5)
                if fpsBoosterActive then
                    OptimizeInstance(inst)
                end
            end)
            
        else
            -- Desactivar optimizaciones
            if descendantConnection then
                descendantConnection:Disconnect()
                descendantConnection = nil
            end
            
            RestoreOriginalSettings()
        end
    end
})




-- ======================================
-- SERVICES / PLAYER
-- ======================================
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer


-- ======================================
-- BLOQUE 1: FAKELAG + FALLING
-- ======================================

-- FakeLag vars
local FakeLagEnabled = false
local FakeLagThread = nil
local FakeLagWaitTime = 0.05
local FakeLagDelayTime = 0.4

-- Falling vars
local FallingEnabled = false


-- ---------- FakeLag functions ----------
function StartFakeLag()
	if FakeLagThread then return end

	FakeLagThread = task.spawn(function()
		while FakeLagEnabled do
			local char = LocalPlayer.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")

			if hrp then
				hrp.Anchored = true
				task.wait(FakeLagDelayTime)
				hrp.Anchored = false
			end

			task.wait(FakeLagWaitTime)
		end
		FakeLagThread = nil
	end)
end

function StopFakeLag()
	FakeLagEnabled = false

	local char = LocalPlayer.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if hrp then
		hrp.Anchored = false
	end
end


-- ---------- Falling function (TOGGLE) ----------
function SetFalling(state)
	local char = LocalPlayer.Character
	local humanoid = char and char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	FallingEnabled = state
	humanoid.PlatformStand = state

	if state then
		humanoid:Move(Vector3.new(0, -50, 0))
	end
end


-- ---------- JmodsLib Toggles (FakeLag + Falling) ----------
MainTab:CreateToggle({
	Name = "FakeLag",
	CurrentValue = false,
	Flag = "FakeLagToggle",
	Callback = function(state)
		FakeLagEnabled = state
		if state then
			StartFakeLag()
		else
			StopFakeLag()
		end
	end
})

MainTab:CreateToggle({
	Name = "Caer",
	CurrentValue = false,
	Flag = "FallingToggle",
	Callback = function(state)
		SetFalling(state)
	end
})


-- ======================================
-- BLOQUE 2: EQUIP ALL TOOLS (SEPARADO)
-- ======================================

-- Equip vars
local ToolsEquipped = false


-- ---------- Equip / Unequip function ----------
function ToggleEquipAllTools()
	local char = LocalPlayer.Character
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if not char or not backpack then return end

	if not ToolsEquipped then
		for _, tool in ipairs(backpack:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent = char
			end
		end
		ToolsEquipped = true
	else
		for _, tool in ipairs(char:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent = backpack
			end
		end
		ToolsEquipped = false
	end
end


-- ---------- JmodsLib Toggle (Equip All) ----------
MainTab:CreateToggle({
	Name = "Equipar todas las herramientas",
	CurrentValue = false,
	Flag = "EquipAllToolsToggle",
	Callback = function(state)
		if state ~= ToolsEquipped then
			ToggleEquipAllTools()
		end
	end
})
