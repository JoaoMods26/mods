-- // Fantasma
-- ========================================
-- FANTASMA
-- ========================================

-- // Servicios
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- // Variables de jugador
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local camera = workspace.CurrentCamera

-- // Variables de ghost
local isGhostMode = false
local ghostPart = nil
local platform = nil
local lastPosition = nil

-- Tabla para guardar las transparencias originales
local originalTransparencies = {}

-- // Movimiento móvil flags
local moveFlags = {
	W = false,
	A = false,
	S = false,
	D = false,
	Space = false,
	LeftControl = false,
}

-- // Variables globales para GUI
local screenGui = nil
local buttons = {}

-- // Conexión del loop de movimiento (SE ACTIVA SOLO CUANDO SE USA)
local heartbeatConnection = nil

-- // Función para crear la GUI móvil (SOLO cuando se activa ghost)
local function createMobileGui()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		buttons = {}
	end

	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "GhostMobileControls"
	screenGui.Parent = player:WaitForChild("PlayerGui")
	screenGui.Enabled = false

	local directions = {{"W", "↑"}, {"S", "↓"}, {"A", "←"}, {"D", "→"}, {"Space", "⎵"}, {"LeftControl", "C"}}

	for i, dir in ipairs(directions) do
		local button = Instance.new("TextButton")
		button.Size = UDim2.new(0, 60, 0, 60)
		button.Position = UDim2.new(0, 10 + (i-1)*65, 1, -70)
		button.Text = dir[2]
		button.BackgroundTransparency = 0.3
		button.TextScaled = true
		button.Name = dir[1]
		button.Parent = screenGui
		buttons[dir[1]] = button

		button.MouseButton1Down:Connect(function()
			moveFlags[dir[1]] = true
		end)
		button.MouseButton1Up:Connect(function()
			moveFlags[dir[1]] = false
		end)
	end
end

-- // Función para limpiar la GUI móvil
local function cleanupMobileGui()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		buttons = {}
	end
end

-- // Funciones originales
local function createPlatform(position)
	if platform then platform:Destroy() end
	platform = Instance.new("Part")
	platform.Name = "PlayerPlatform"
	platform.Size = Vector3.new(10, 1, 10)
	platform.Position = position - Vector3.new(0, 3.5, 0)
	platform.Anchored = true
	platform.BrickColor = BrickColor.new("Really black")
	platform.Transparency = 1
	platform.CanCollide = true
	platform.CastShadow = false
	platform.Parent = workspace
end

local function createGhostPart(position)
	if workspace:FindFirstChild("GhostPart") then
		workspace.GhostPart:Destroy()
	end
	if ghostPart then ghostPart:Destroy() end

	ghostPart = Instance.new("Part")
	ghostPart.Name = "GhostPart"
	ghostPart.Size = Vector3.new(2, 2, 2)
	ghostPart.Position = position.Position + Vector3.new(0, 2, 0)
	ghostPart.Transparency = 0.5
	ghostPart.BrickColor = BrickColor.new("Really white")
	ghostPart.CanCollide = false
	ghostPart.Anchored = false
	ghostPart.Parent = workspace

	local mesh = Instance.new("SpecialMesh")
	mesh.MeshType = Enum.MeshType.FileMesh
	mesh.MeshId = "rbxassetid://11003401773"
	mesh.Scale = Vector3.new(0.15, 0.15, 0.15)
	mesh.Parent = ghostPart

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.Parent = ghostPart

	local bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyGyro.CFrame = CFrame.new(ghostPart.Position)
	bodyGyro.Parent = ghostPart

	camera.CameraSubject = ghostPart
	camera.CameraType = Enum.CameraType.Custom
end

local function updateGhostPartMovement()
	if not isGhostMode or not ghostPart then return end
	local moveDirection = Vector3.new(0, 0, 0)
	local speed = 60
	local cameraCFrame = camera.CFrame

	if UserInputService:IsKeyDown(Enum.KeyCode.W) or moveFlags.W then
		moveDirection += cameraCFrame.LookVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) or moveFlags.S then
		moveDirection -= cameraCFrame.LookVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) or moveFlags.A then
		moveDirection -= cameraCFrame.RightVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) or moveFlags.D then
		moveDirection += cameraCFrame.RightVector * speed
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.Space) or moveFlags.Space then
		moveDirection += Vector3.new(0, speed, 0)
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or moveFlags.LeftControl then
		moveDirection -= Vector3.new(0, speed, 0)
	end

	local bodyVelocity = ghostPart:FindFirstChildOfClass("BodyVelocity")
	if bodyVelocity then
		bodyVelocity.Velocity = moveDirection
	end
end

-- Función para activar el loop de movimiento
local function connectHeartbeat()
	if heartbeatConnection then return end
	heartbeatConnection = RunService.Heartbeat:Connect(function()
		updateGhostPartMovement()
	end)
end

-- Función para desactivar el loop de movimiento
local function disconnectHeartbeat()
	if heartbeatConnection then
		heartbeatConnection:Disconnect()
		heartbeatConnection = nil
	end
end

-- Función para guardar transparencias originales
local function saveOriginalTransparencies()
	originalTransparencies = {}
	
	for _, obj in pairs(character:GetDescendants()) do
		if obj:IsA("BasePart") or obj:IsA("MeshPart") then
			-- Solo guardar partes que son del cuerpo original del personaje
			-- Ignorar partes que el juego pueda haber añadido
			if obj.Parent == character or (obj.Parent and obj.Parent:IsA("Accessory")) then
				originalTransparencies[obj] = obj.Transparency
			end
		elseif obj:IsA("Decal") then
			if obj.Parent and (obj.Parent.Parent == character or obj.Parent.Name == "Head") then
				originalTransparencies[obj] = obj.Transparency
			end
		end
	end
end

-- Función para restaurar transparencias originales
local function restoreOriginalTransparencies()
	for obj, transparency in pairs(originalTransparencies) do
		if obj and obj.Parent then
			obj.Transparency = transparency
		end
	end
	
	-- Mantener HumanoidRootPart invisible siempre
	if humanoidRootPart then
		humanoidRootPart.Transparency = 1
	end
	
	-- Mantener CollisionPart invisible si existe
	local collidePart = character:FindFirstChild("CollisionPart", true)
	if collidePart and collidePart:IsA("BasePart") then
		collidePart.Transparency = 1
	end
	
	originalTransparencies = {}
end

local function teleportAndGhost()
	if isGhostMode then
		-- DESACTIVAR GHOST MODE
		humanoidRootPart.CFrame = ghostPart and CFrame.new(ghostPart.Position + Vector3.new(0, 3, 0)) or CFrame.new(0, 100, 0)
		character.Humanoid.WalkSpeed = 16
		character.Humanoid.JumpPower = 50

		-- Restaurar transparencias originales
		restoreOriginalTransparencies()

		camera.CameraSubject = character:FindFirstChildOfClass("Humanoid") or character
		camera.CameraType = Enum.CameraType.Custom

		if ghostPart then ghostPart:Destroy() ghostPart = nil end
		if platform then platform:Destroy() platform = nil end

		-- Limpiar GUI y desconectar loop
		cleanupMobileGui()
		disconnectHeartbeat()

		isGhostMode = false
	else
		-- ACTIVAR GHOST MODE
		lastPosition = humanoidRootPart.CFrame
		local teleportPosition = Vector3.new(math.random(-1000, 1000), 100, math.random(-1000, 1000))
		
		-- Guardar transparencias antes de modificar
		saveOriginalTransparencies()
		
		createPlatform(teleportPosition)
		humanoidRootPart.CFrame = CFrame.new(teleportPosition)
		createGhostPart(lastPosition)
		character.Humanoid.WalkSpeed = 0
		character.Humanoid.JumpPower = 0

		-- Hacer invisibles SOLO las partes del personaje original
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") or part:IsA("MeshPart") then
				-- Solo afectar partes del cuerpo y accesorios
				if part.Parent == character or (part.Parent and part.Parent:IsA("Accessory")) then
					part.Transparency = 1
				end
			elseif part:IsA("Decal") then
				-- Mantener decals visibles (cara)
				if part.Parent and (part.Parent.Parent == character or part.Parent.Name == "Head") then
					part.Transparency = 0
				end
			end
		end

		-- Crear GUI solo si es móvil
		if UserInputService.TouchEnabled then
			createMobileGui()
			if screenGui then
				screenGui.Enabled = true
			end
		end

		-- Conectar el loop de movimiento
		connectHeartbeat()

		isGhostMode = true
	end
end

-- // Manejo de respawn
player.CharacterAdded:Connect(function(char)
	character = char
	humanoidRootPart = char:WaitForChild("HumanoidRootPart")

	if isGhostMode then
		if ghostPart then ghostPart:Destroy() ghostPart = nil end
		if platform then platform:Destroy() platform = nil end
		camera.CameraSubject = character:WaitForChild("Humanoid")
		camera.CameraType = Enum.CameraType.Custom
		isGhostMode = false
		cleanupMobileGui()
		disconnectHeartbeat()
	end

	if platform then platform:Destroy() platform = nil end

	local collidePart = character:FindFirstChild("CollisionPart", true)
	if collidePart then
		collidePart.Transparency = 1
	end
end)

-- // Toggle Rayfield
MainTab:CreateToggle({
	Name = "Fantasma",
	CurrentValue = false,
	Flag = "InvincibilityToggle",
	Callback = function(Value)
		if Value and not isGhostMode then
			teleportAndGhost()
		elseif not Value and isGhostMode then
			teleportAndGhost()
		end
	end,
})


-- ========================================
-- ========================================
---shiftlock

-- Servicios
local TweenService = game:GetService("TweenService")

local camera2 = workspace.CurrentCamera
local character2 = player.Character or player.CharacterAdded:Wait()
local humanoid2 = character2:WaitForChild("Humanoid")
local root2 = character2:WaitForChild("HumanoidRootPart")

-- Shiftlock variables
local shiftlockEnabled = false
local shiftlockKeybind = Enum.KeyCode.Q
local isActive = false
local cameraConnection = nil

-- GUI Shiftlock (SE CREA PERO NO SE MUESTRA HASTA ACTIVAR)
local ShiftlockGui = nil
local Button = nil
local StateLabelFrame = nil
local StateLabel = nil
local Crosshair = nil

-- Conexión de input (SE ACTIVA SOLO CUANDO SE USA)
local inputBeganConnection = nil

-- Función para crear la GUI (solo cuando se activa el toggle)
local function createShiftlockGui()
	if ShiftlockGui then
		ShiftlockGui:Destroy()
	end

	ShiftlockGui = Instance.new("ScreenGui")
	ShiftlockGui.Name = "ShiftlockGUI"
	ShiftlockGui.ResetOnSpawn = false
	ShiftlockGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ShiftlockGui.Parent = player:WaitForChild("PlayerGui")

	Button = Instance.new("ImageButton")
	Button.Name = "ShiftlockButton"
	Button.Parent = ShiftlockGui
	Button.BackgroundTransparency = 1
	Button.Size = UDim2.new(0.0636, 0, 0.0661, 0)
	Button.Position = UDim2.new(0.9219, 0, 0.5523, 0)
	Button.SizeConstraint = Enum.SizeConstraint.RelativeXX
	Button.Visible = false

	StateLabelFrame = Instance.new("Frame")
	StateLabelFrame.Parent = Button
	StateLabelFrame.Size = UDim2.new(1, 0, 1, 0)
	StateLabelFrame.BackgroundTransparency = 0.5
	StateLabelFrame.BackgroundColor3 = Color3.new(0, 0, 0)

	StateLabel = Instance.new("TextLabel")
	StateLabel.Parent = StateLabelFrame
	StateLabel.Size = UDim2.new(1, 0, 1, 0)
	StateLabel.BackgroundTransparency = 1
	StateLabel.Text = "OFF"
	StateLabel.TextColor3 = Color3.new(1, 1, 1)
	StateLabel.TextScaled = true
	StateLabel.Font = Enum.Font.SourceSansBold

	Crosshair = Instance.new("TextLabel")
	Crosshair.Parent = ShiftlockGui
	Crosshair.Size = UDim2.new(0, 30, 0, 30)
	Crosshair.Position = UDim2.new(0.5, -15, 0.5, -15)
	Crosshair.BackgroundTransparency = 1
	Crosshair.Text = "O"
	Crosshair.TextScaled = true
	Crosshair.TextColor3 = Color3.new(1, 1, 1)
	Crosshair.Visible = false

	-- Conectar el botón
	Button.MouseButton1Click:Connect(function()
		if shiftlockEnabled then
			ShiftLockToggle()
		end
	end)
end

-- Función para limpiar la GUI
local function cleanupShiftlockGui()
	if ShiftlockGui then
		ShiftlockGui:Destroy()
		ShiftlockGui = nil
		Button = nil
		StateLabelFrame = nil
		StateLabel = nil
		Crosshair = nil
	end
end

-- Funciones Shiftlock
local function UpdateImage(state)
	if StateLabel then
		StateLabel.Text = state
	end
end

local function UpdateAutoRotate(state)
	if humanoid2 then
		humanoid2.AutoRotate = state
	end
end

local function AnimateButtonPress()
	if not Button then return end
	local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local shrinkSize = Button.Size - UDim2.new(0.01, 0, 0.01, 0)
	local tweenShrink = TweenService:Create(Button, tweenInfo, { Size = shrinkSize })
	local tweenGrow = TweenService:Create(Button, tweenInfo, { Size = UDim2.new(0.0636, 0, 0.0661, 0) })
	tweenShrink:Play()
	tweenShrink.Completed:Connect(function()
		tweenGrow:Play()
	end)
end

local function ShiftLockToggle()
	if not ((camera2.CameraSubject == humanoid2 or camera2.CameraSubject == root2) and camera2.CameraType == Enum.CameraType.Custom) then
		return
	end

	AnimateButtonPress()

	if not isActive then
		isActive = true
		UpdateAutoRotate(false)
		UpdateImage("ON")
		if Crosshair then Crosshair.Visible = true end
		UserInputService.MouseIconEnabled = false
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter

		cameraConnection = RunService.RenderStepped:Connect(function()
			if character2 and root2 and camera2 then
				local direction = camera2.CFrame.LookVector
				local flatDirection = Vector3.new(direction.X, 0, direction.Z)
				if flatDirection.Magnitude > 0 then
					root2.CFrame = CFrame.new(root2.Position, root2.Position + flatDirection)
				end
			end
		end)
	else
		isActive = false
		UpdateAutoRotate(true)
		UpdateImage("OFF")
		if Crosshair then Crosshair.Visible = false end
		UserInputService.MouseIconEnabled = true
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default

		if cameraConnection then
			cameraConnection:Disconnect()
			cameraConnection = nil
		end
	end
end

-- Función para conectar el input (solo cuando se activa)
local function connectInput()
	if inputBeganConnection then return end
	
	inputBeganConnection = UserInputService.InputBegan:Connect(function(input, gp)
		if gp then return end
		if not UserInputService.TouchEnabled and shiftlockEnabled and input.KeyCode == shiftlockKeybind then
			ShiftLockToggle()
		end
	end)
end

-- Función para desconectar el input
local function disconnectInput()
	if inputBeganConnection then
		inputBeganConnection:Disconnect()
		inputBeganConnection = nil
	end
end

player.CharacterAdded:Connect(function(char)
	character2 = char
	humanoid2 = character2:WaitForChild("Humanoid")
	root2 = character2:WaitForChild("HumanoidRootPart")
	if isActive then
		UpdateAutoRotate(false)
	end
end)

-- Toggle Shiftlock
MainTab:CreateToggle({
	Name = "Shiftlock Q para activar",
	CurrentValue = false,
	Flag = "ShiftlockToggle",
	Callback = function(Value)
		shiftlockEnabled = Value
		
		if Value then
			-- ACTIVAR: Crear GUI y conectar input
			createShiftlockGui()
			connectInput()
			if Button then
				Button.Visible = UserInputService.TouchEnabled
			end
		else
			-- DESACTIVAR: Limpiar todo
			if isActive then
				isActive = false
				UpdateAutoRotate(true)
				UpdateImage("OFF")
				if Crosshair then Crosshair.Visible = false end
				UserInputService.MouseIconEnabled = true
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
				if cameraConnection then
					cameraConnection:Disconnect()
					cameraConnection = nil
				end
			end
			cleanupShiftlockGui()
			disconnectInput()
		end
	end
})









-- Caminar en el aire
local isWalkingInAir = false
local floorPart = nil
local heartbeatConnection = nil

local function isTouchingGround()
	local ray = Ray.new(root.Position, Vector3.new(0, -5, 0))
	local hitPart = workspace:FindPartOnRay(ray, character)
	return hitPart and hitPart.CanCollide
end

local function createFloor()
	if not floorPart then
		floorPart = Instance.new("Part")
		floorPart.Size = Vector3.new(50, 1, 50)
		floorPart.Anchored = true
		floorPart.CanCollide = true
		floorPart.Transparency = 1
		floorPart.Parent = workspace
	end
end

MainTab:CreateToggle({
	Name = "Caminar en el aire",
	CurrentValue = isWalkingInAir,
	Flag = "walkInAirToggle",
	Callback = function(Value)
		isWalkingInAir = Value

		if isWalkingInAir then
			createFloor()
			if not heartbeatConnection then
				heartbeatConnection = RunService.Heartbeat:Connect(function()
					if isWalkingInAir and floorPart and not isTouchingGround() then
						floorPart.Position = root.Position - Vector3.new(0, 3, 0)
					end
				end)
			end
		else
			if floorPart then
				floorPart:Destroy()
				floorPart = nil
			end
			if heartbeatConnection then
				heartbeatConnection:Disconnect()
				heartbeatConnection = nil
			end
		end
	end,
})

-- Mutear sonidos excepto voz
local mutedSounds = {}
local toggleActive = false

local function isVoiceSound(sound)
	if sound:IsDescendantOf(VoiceChatService) then return true end
	local name = sound.Name:lower()
	return name:find("voice") or name:find("vc")
end

local function muteAllExceptVoice()
	for _, sound in ipairs(game:GetDescendants()) do
		if sound:IsA("Sound") and not isVoiceSound(sound) then
			if sound.Playing and sound.Volume > 0 then
				mutedSounds[sound] = sound.Volume
				sound.Volume = 0
			end
		end
	end
end

local function unmuteAll()
	for sound, vol in pairs(mutedSounds) do
		if sound and sound.Parent then
			sound.Volume = vol
		end
	end
	mutedSounds = {}
end

game.DescendantAdded:Connect(function(sound)
	if toggleActive and sound:IsA("Sound") and not isVoiceSound(sound) then
		mutedSounds[sound] = sound.Volume
		sound.Volume = 0
	end
end)

MainTab:CreateToggle({
	Name = "Mutear sonidos (voz no)",
	CurrentValue = false,
	Flag = "MuteAudios",
	Callback = function(Value)
		toggleActive = Value
		if Value then
			muteAllExceptVoice()
		else
			unmuteAll()
		end
	end
})




---Fullbright

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local originalSettings = {}
local connection

MainTab:CreateToggle({
	Name = "Fullbright",
	Flag = "Fullbright",
	CurrentValue = false,
	Callback = function(enabled)
		if enabled then
			-- Guardar valores originales
			originalSettings.Brightness = Lighting.Brightness
			originalSettings.ClockTime = Lighting.ClockTime
			originalSettings.Ambient = Lighting.Ambient
			originalSettings.OutdoorAmbient = Lighting.OutdoorAmbient
			originalSettings.GlobalShadows = Lighting.GlobalShadows

			-- Conexión para forzar iluminación
			if not connection then
				connection = RunService.RenderStepped:Connect(function()
					Lighting.Brightness = 1.5
					Lighting.ClockTime = 12
					Lighting.Ambient = Color3.new(1, 1, 1)
					Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
					Lighting.GlobalShadows = false
				end)
			end
		else
			-- Restaurar valores
			if connection then
				connection:Disconnect()
				connection = nil
			end
			for prop, value in pairs(originalSettings) do
				Lighting[prop] = value
			end
		end
	end
})





-- Servicios y variables necesarias
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local unlockCameraConnection
local cameraUnlocked = false -- INICIALMENTE FALSO
local originalCameraSettings = {}

-- Función para forzar el control de cámara
local function enableCameraControl()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	-- Guardar estado original una sola vez
	if not originalCameraSettings.saved then
		originalCameraSettings.CameraType = Camera.CameraType
		originalCameraSettings.CameraSubject = Camera.CameraSubject
		originalCameraSettings.CameraMode = LocalPlayer.CameraMode
		originalCameraSettings.MaxZoom = LocalPlayer.CameraMaxZoomDistance
		originalCameraSettings.MinZoom = LocalPlayer.CameraMinZoomDistance
		originalCameraSettings.saved = true
	end

	-- Desconectar si ya había una conexión previa
	if unlockCameraConnection then
		unlockCameraConnection:Disconnect()
	end

	unlockCameraConnection = RunService.RenderStepped:Connect(function()
		if not cameraUnlocked then return end

		if Camera.CameraType ~= Enum.CameraType.Custom then
			Camera.CameraType = Enum.CameraType.Custom
		end

		if Camera.CameraSubject ~= humanoid then
			Camera.CameraSubject = humanoid
		end

		LocalPlayer.CameraMode = Enum.CameraMode.Classic
		LocalPlayer.CameraMaxZoomDistance = 128
		LocalPlayer.CameraMinZoomDistance = 0.5
	end)
end

-- TOGGLE: Unlock Camera
MainTab:CreateToggle({
	Name = "Desbloquear Camara",
	Flag = "unlockCam",
	CurrentValue = false,
	Callback = function(enabled)
		cameraUnlocked = enabled

		if enabled then
			enableCameraControl()
		else
			-- Desconectar render loop
			if unlockCameraConnection then
				unlockCameraConnection:Disconnect()
				unlockCameraConnection = nil
			end

			-- Restaurar valores originales si estaban guardados
			if originalCameraSettings.saved then
				Camera.CameraType = originalCameraSettings.CameraType
				Camera.CameraSubject = originalCameraSettings.CameraSubject
				LocalPlayer.CameraMode = originalCameraSettings.CameraMode
				LocalPlayer.CameraMaxZoomDistance = originalCameraSettings.MaxZoom
				LocalPlayer.CameraMinZoomDistance = originalCameraSettings.MinZoom
			end
		end
	end
})

-- Ejecutar enableCameraControl() solo si el toggle está activado al cargar (opcional)
if cameraUnlocked then
	enableCameraControl()
end

-- Reaplicar si reaparece el personaje, pero solo si está activado
LocalPlayer.CharacterAdded:Connect(function()
	if cameraUnlocked then
		enableCameraControl()
	end
end)











-- Asegúrate de que estas variables están definidas
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Variables de control
local boostEnabled = false
local boostStrength = 100
local baseWalkSpeed = 16
local baseJumpPower = 50
local originalStats = {}

-- Función para aplicar boost
local function applyBoost()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid then
		-- Guardar valores originales una vez
		if not originalStats.saved then
			originalStats.WalkSpeed = humanoid.WalkSpeed
			originalStats.JumpPower = humanoid.JumpPower
			originalStats.saved = true
		end

		humanoid.UseJumpPower = true
		local speedMultiplier = (boostStrength * 0.1) / 100
		local jumpMultiplier = (boostStrength * 0.4) / 100
		humanoid.WalkSpeed = baseWalkSpeed * (1 + speedMultiplier)
		humanoid.JumpPower = baseJumpPower * (1 + jumpMultiplier)
	end
end

-- Restaurar valores originales
local function restoreStats()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid and originalStats.saved then
		humanoid.WalkSpeed = originalStats.WalkSpeed
		humanoid.JumpPower = originalStats.JumpPower
	end
end

-- Toggle en MainTab
MainTab:CreateToggle({
	Name = "Salto y Velocidad Indetectable",
	Flag = "movementBoost",
	CurrentValue = false,
	Callback = function(value)
		boostEnabled = value
		if boostEnabled then
			applyBoost()
		else
			restoreStats()
		end
	end
})

-- Slider en MainTab
MainTab:CreateSlider({
	Name = "Aumento Velocidad Indetectable",
	Flag = "boostStrength",
	Range = {0, 100},
	Increment = 5,
	CurrentValue = boostStrength,
	Suffix = "+",
	Callback = function(value)
		boostStrength = value
		if boostEnabled then
			applyBoost()
		end
	end
})








-----







local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local antiFlingEnabled = false
local characterConnections = {}
local collisionLoop

local function SetNoCollision(character)
	for _, item in pairs(character:GetDescendants()) do
		if item:IsA("BasePart") and item.CanCollide then
			item.CanCollide = false
		end
	end
end

local function OnCharacterAdded(player, character)
	if not antiFlingEnabled or player == LocalPlayer then return end
	SetNoCollision(character)

	-- Nuevas partes
	local conn = character.DescendantAdded:Connect(function(desc)
		if desc:IsA("BasePart") then
			desc.CanCollide = false
		end
	end)

	characterConnections[player] = conn
end

local function EnableAntiFling()
	-- Inicial
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			if player.Character then
				OnCharacterAdded(player, player.Character)
			end
			characterConnections[player] = player.CharacterAdded:Connect(function(char)
				OnCharacterAdded(player, char)
			end)
		end
	end

	-- Nuevos jugadores
	characterConnections["_PlayerAdded"] = Players.PlayerAdded:Connect(function(player)
		if player == LocalPlayer then return end
		characterConnections[player] = player.CharacterAdded:Connect(function(char)
			OnCharacterAdded(player, char)
		end)
	end)

	-- Loop seguro cada 0.25s para mantener colisión desactivada
	local timer = 0
	collisionLoop = RunService.Stepped:Connect(function(_, dt)
		timer += dt
		if timer >= 0.25 then
			timer = 0
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character then
					SetNoCollision(player.Character)
				end
			end
		end
	end)
end

local function DisableAntiFling()
	for _, conn in pairs(characterConnections) do
		if typeof(conn) == "RBXScriptConnection" then
			conn:Disconnect()
		end
	end
	characterConnections = {}

	if collisionLoop then
		collisionLoop:Disconnect()
		collisionLoop = nil
	end

	-- Restaurar colisión
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			for _, part in pairs(player.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
				end
			end
		end
	end
end

MainTab:CreateToggle({
	Name = "Anti-Fling",
	CurrentValue = false,
	Callback = function(state)
		antiFlingEnabled = state
		if state then
			EnableAntiFling()
		else
			DisableAntiFling()
		end
	end,
})



-----Anti AFK



local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

local AntiAfkEnabled = false
local AntiAfkThread

MainTab:CreateToggle({
    Name = "Anti-AFK OP",
    CurrentValue = false,
    Flag = "AntiAfkToggle",
    Callback = function(Value)
        AntiAfkEnabled = Value

        if AntiAfkEnabled then
            AntiAfkThread = task.spawn(function()
                while AntiAfkEnabled do
                    -- Simular salto
                    if humanoid and humanoid.Health > 0 then
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end

                    -- Simular rotación de cámara
                    local camCF = camera.CFrame
                    local rotation = CFrame.Angles(0, math.rad(1), 0) -- gira un poco a la derecha
                    camera.CFrame = camCF * rotation

                    task.wait(60) -- cada 60 segundos
                end
            end)
        else
            if AntiAfkThread then
                task.cancel(AntiAfkThread)
                AntiAfkThread = nil
            end
        end
    end,
})




------Cargar guardar posicion

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local savedCFrame = nil
local systemEnabled = false 

MainTab:CreateToggle({
    Name = "Activar Guardar/Cargar",
    CurrentValue = false,
    Flag = "ToggleSistemaPos",
    Callback = function(value)
        systemEnabled = value
    end,
})

MainTab:CreateButton({
    Name = "Guardar Posición",
    Callback = function()
        if not systemEnabled then
            Rayfield:Notify({
                Title = "Sistema Desactivado",
                Content = "Activa el toggle para usar Guardar Posición.",
                Duration = 3,
            })
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            savedCFrame = rootPart.CFrame
        end
    end,
})

MainTab:CreateButton({
    Name = "Cargar Posición",
    Callback = function()
        if not systemEnabled then
            Rayfield:Notify({
                Title = "Sistema Desactivado",
                Content = "Activa el toggle para usar Cargar Posición.",
                Duration = 3,
            })
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if savedCFrame and rootPart then
            rootPart.CFrame = savedCFrame
        end
    end,
})

MainTab:CreateKeybind({
    Name = "Cargar Posición",
    CurrentKeybind = "Q", 
    HoldToInteract = false,
    Flag = "KeybindTP",
    Callback = function()
        if not systemEnabled then return end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if savedCFrame and rootPart then
            rootPart.CFrame = savedCFrame
        end
    end,
})




