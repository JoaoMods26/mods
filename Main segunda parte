-- Fantasma
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local camera = workspace.CurrentCamera

local isGhostMode = false
local ghostPart = nil
local platform = nil
local lastPosition = nil

-- Tabla para guardar las transparencias originales
local originalTransparencies = {}

-- // Movimiento móvil flags
local moveFlags = {
	Space = false,
	LeftControl = false,
}

-- // Variables globales para GUI
local screenGui = nil
local buttons = {}

-- // Conexión del loop de movimiento (SE ACTIVA SOLO CUANDO SE USA)
local heartbeatConnection = nil

-- Función para obtener el movimiento del stick móvil nativo
local function getMobileMovement()
    local moveDirection = Vector3.zero
 
    pcall(function()
        local playerModule = player.PlayerScripts:WaitForChild("PlayerModule")
        local controls = require(playerModule:WaitForChild("ControlModule"))
        if controls then
            moveDirection = controls:GetMoveVector()
        end
    end)
 
    return moveDirection
end

-- // Función para crear la GUI móvil (SOLO cuando se activa ghost)
function createMobileGui()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		buttons = {}
	end

	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "GhostMobileControls"
	screenGui.Parent = CoreGui
	screenGui.Enabled = false

	-- Solo botones de subir/bajar (el stick nativo maneja WASD)
	local directions = {{"Space", "▲"}, {"LeftControl", "▼"}}

	for i, dir in ipairs(directions) do
		local button = Instance.new("TextButton")
		button.Size = UDim2.new(0, 80, 0, 80)
		button.Position = UDim2.new(1, -100, 1, -100 - (i-1)*90)
		button.Text = dir[2]
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		button.BackgroundTransparency = 0.3
		button.TextScaled = true
		button.Font = Enum.Font.GothamBold
		button.TextColor3 = Color3.new(1, 1, 1)
		button.AutoButtonColor = false
		button.Name = dir[1]
		button.Parent = screenGui
		buttons[dir[1]] = button

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0.2, 0)
		corner.Parent = button

		button.MouseButton1Down:Connect(function()
			moveFlags[dir[1]] = true
			button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
		end)
		button.MouseButton1Up:Connect(function()
			moveFlags[dir[1]] = false
			button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		end)
	end
end

-- // Función para limpiar la GUI móvil
 function cleanupMobileGui()
	if screenGui then
		screenGui:Destroy()
		screenGui = nil
		buttons = {}
	end
	-- Limpiar estados
	for key in pairs(moveFlags) do
		moveFlags[key] = false
	end
end

-- // Funciones originales
function createPlatform(position)
	if platform then platform:Destroy() end
	platform = Instance.new("Part")
	platform.Name = "PlayerPlatform"
	platform.Size = Vector3.new(10, 1, 10)
	platform.Position = position - Vector3.new(0, 3.5, 0)
	platform.Anchored = true
	platform.BrickColor = BrickColor.new("Really black")
	platform.Transparency = 1
	platform.CanCollide = true
	platform.CastShadow = false
	platform.Parent = workspace
end

 function createGhostPart(position)
	if workspace:FindFirstChild("GhostPart") then
		workspace.GhostPart:Destroy()
	end
	if ghostPart then ghostPart:Destroy() end

	ghostPart = Instance.new("Part")
	ghostPart.Name = "GhostPart"
	ghostPart.Size = Vector3.new(2, 2, 2)
	ghostPart.Position = position.Position + Vector3.new(0, 2, 0)
	ghostPart.Transparency = 0.5
	ghostPart.BrickColor = BrickColor.new("Really white")
	ghostPart.CanCollide = false
	ghostPart.Anchored = false
	ghostPart.Parent = workspace

	local mesh = Instance.new("SpecialMesh")
	mesh.MeshType = Enum.MeshType.FileMesh
	mesh.MeshId = "rbxassetid://11003401773"
	mesh.Scale = Vector3.new(0.15, 0.15, 0.15)
	mesh.Parent = ghostPart

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.Parent = ghostPart

	local bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyGyro.CFrame = CFrame.new(ghostPart.Position)
	bodyGyro.Parent = ghostPart

	camera.CameraSubject = ghostPart
	camera.CameraType = Enum.CameraType.Custom
end

 function updateGhostPartMovement()
	if not isGhostMode or not ghostPart then return end
	local moveDirection = Vector3.new(0, 0, 0)
	local speed = 60
	local cameraCFrame = camera.CFrame

	-- Movimiento horizontal
	if UserInputService.TouchEnabled then
		-- Usar stick móvil nativo
		local mobileMove = getMobileMovement()
		if mobileMove.Magnitude > 0 then
			local lookVector = cameraCFrame.LookVector
			local rightVector = cameraCFrame.RightVector
			
			local worldDirection = (rightVector * mobileMove.X) + (lookVector * -mobileMove.Z)
			moveDirection += worldDirection * speed
		end
	else
		-- Controles de teclado PC
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then
			moveDirection += cameraCFrame.LookVector * speed
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.S) then
			moveDirection -= cameraCFrame.LookVector * speed
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.A) then
			moveDirection -= cameraCFrame.RightVector * speed
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.D) then
			moveDirection += cameraCFrame.RightVector * speed
		end
	end

	-- Subir/bajar (igual para móvil y PC)
	if UserInputService:IsKeyDown(Enum.KeyCode.Space) or moveFlags.Space then
		moveDirection += Vector3.new(0, speed, 0)
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or moveFlags.LeftControl then
		moveDirection -= Vector3.new(0, speed, 0)
	end

	local bodyVelocity = ghostPart:FindFirstChildOfClass("BodyVelocity")
	if bodyVelocity then
		bodyVelocity.Velocity = moveDirection
	end
end

-- Función para activar el loop de movimiento
function connectHeartbeat()
	if heartbeatConnection then return end
	heartbeatConnection = RunService.Heartbeat:Connect(function()
		updateGhostPartMovement()
	end)
end

-- Función para desactivar el loop de movimiento
 function disconnectHeartbeat()
	if heartbeatConnection then
		heartbeatConnection:Disconnect()
		heartbeatConnection = nil
	end
end

-- Función para guardar transparencias originales
 function saveOriginalTransparencies()
	originalTransparencies = {}
	
	for _, obj in pairs(character:GetDescendants()) do
		if obj:IsA("BasePart") or obj:IsA("MeshPart") then
			-- Solo guardar partes que son del cuerpo original del personaje
			-- Ignorar partes que el juego pueda haber añadido
			if obj.Parent == character or (obj.Parent and obj.Parent:IsA("Accessory")) then
				originalTransparencies[obj] = obj.Transparency
			end
		elseif obj:IsA("Decal") then
			if obj.Parent and (obj.Parent.Parent == character or obj.Parent.Name == "Head") then
				originalTransparencies[obj] = obj.Transparency
			end
		end
	end
end

-- Función para restaurar transparencias originales
function restoreOriginalTransparencies()
	for obj, transparency in pairs(originalTransparencies) do
		if obj and obj.Parent then
			obj.Transparency = transparency
		end
	end
	
	if humanoidRootPart then
		humanoidRootPart.Transparency = 1
	end
	
	-- Mantener CollisionPart invisible si existe
	local collidePart = character:FindFirstChild("CollisionPart", true)
	if collidePart and collidePart:IsA("BasePart") then
		collidePart.Transparency = 1
	end
	
	originalTransparencies = {}
end

 function teleportAndGhost()
	if isGhostMode then
		-- DESACTIVAR GHOST MODE
		humanoidRootPart.CFrame = ghostPart and CFrame.new(ghostPart.Position + Vector3.new(0, 3, 0)) or CFrame.new(0, 100, 0)
		character.Humanoid.WalkSpeed = 16
		character.Humanoid.JumpPower = 50

		-- Restaurar transparencias originales
		restoreOriginalTransparencies()

		camera.CameraSubject = character:FindFirstChildOfClass("Humanoid") or character
		camera.CameraType = Enum.CameraType.Custom

		if ghostPart then ghostPart:Destroy() ghostPart = nil end
		if platform then platform:Destroy() platform = nil end

		-- Limpiar GUI y desconectar loop
		cleanupMobileGui()
		disconnectHeartbeat()

		isGhostMode = false
	else
		lastPosition = humanoidRootPart.CFrame
		local teleportPosition = Vector3.new(math.random(-1000, 1000), 100, math.random(-1000, 1000))
		
		saveOriginalTransparencies()
		
		createPlatform(teleportPosition)
		humanoidRootPart.CFrame = CFrame.new(teleportPosition)
		createGhostPart(lastPosition)
		character.Humanoid.WalkSpeed = 0
		character.Humanoid.JumpPower = 0

		-- Hacer invisibles SOLO las partes del personaje original
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") or part:IsA("MeshPart") then
				-- Solo afectar partes del cuerpo y accesorios
				if part.Parent == character or (part.Parent and part.Parent:IsA("Accessory")) then
					part.Transparency = 1
				end
			elseif part:IsA("Decal") then
				-- Mantener decals visibles (cara)
				if part.Parent and (part.Parent.Parent == character or part.Parent.Name == "Head") then
					part.Transparency = 0
				end
			end
		end

		if UserInputService.TouchEnabled then
			createMobileGui()
			if screenGui then
				screenGui.Enabled = true
			end
		end

		connectHeartbeat()

		isGhostMode = true
	end
end

player.CharacterAdded:Connect(function(char)
	character = char
	humanoidRootPart = char:WaitForChild("HumanoidRootPart")

	if isGhostMode then
		if ghostPart then ghostPart:Destroy() ghostPart = nil end
		if platform then platform:Destroy() platform = nil end
		camera.CameraSubject = character:WaitForChild("Humanoid")
		camera.CameraType = Enum.CameraType.Custom
		isGhostMode = false
		cleanupMobileGui()
		disconnectHeartbeat()
	end

	if platform then platform:Destroy() platform = nil end

	local collidePart = character:FindFirstChild("CollisionPart", true)
	if collidePart then
		collidePart.Transparency = 1
	end
end)

MainTab:CreateToggle({
	Name = "Fantasma",
	CurrentValue = false,
	Flag = "InvincibilityToggle",
	Callback = function(Value)
		if Value and not isGhostMode then
			teleportAndGhost()
		elseif not Value and isGhostMode then
			teleportAndGhost()
		end
	end,
})











-- SHIFTLOCK
-- SHIFTLOCK
local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    CoreGui = game:GetService("CoreGui")
}

local State = {
    enabled = false,
    active = false,
    player = Services.Players.LocalPlayer,
    camera = workspace.CurrentCamera,
    character = nil,
    humanoid = nil,
    rootPart = nil,
    connections = {},
    uiElements = {}
}


local Config = {
    keybind = Enum.KeyCode.Q,
    crosshairSymbol = "⊕",
    crosshairSize = 30,
    buttonPosition = UDim2.new(0.92, 0, 0.55, 0),
    buttonSize = UDim2.new(0.06, 0, 0.065, 0),
    showMobileButton = true
}


local Utils = {}

function Utils.cleanupConnections()
    for name, connection in pairs(State.connections) do
        if connection then
            connection:Disconnect()
        end
        State.connections[name] = nil
    end
end

function Utils.updateCharacterReferences()
    State.character = State.player.Character
    if State.character then
        State.humanoid = State.character:WaitForChild("Humanoid", 5)
        State.rootPart = State.character:WaitForChild("HumanoidRootPart", 5)
        return true
    end
    return false
end

function Utils.isValidForShiftlock()
    if not State.camera or not State.humanoid or not State.rootPart then
        return false
    end
    
    local validSubject = (State.camera.CameraSubject == State.humanoid or 
                         State.camera.CameraSubject == State.rootPart)
    local validType = State.camera.CameraType == Enum.CameraType.Custom
    
    return validSubject and validType
end

local UI = {}

function UI.create()
    UI.destroy()
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "NewShiftlockUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = Services.CoreGui
    
    State.uiElements.screenGui = screenGui
    
    if Services.UserInputService.TouchEnabled and Config.showMobileButton then
        UI.createMobileButton(screenGui)
    end
    
    UI.createCrosshair(screenGui)
    
    return true
end

function UI.createMobileButton(parent)
    local button = Instance.new("TextButton")
    button.Name = "MobileShiftlockBtn"
    button.Size = Config.buttonSize
    button.Position = Config.buttonPosition
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BackgroundTransparency = 0.3
    button.BorderSizePixel = 0
    button.Text = "OFF"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextScaled = true
    button.Font = Enum.Font.GothamBold
    button.ZIndex = 10
    button.Active = true
    button.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.25, 0)
    corner.Parent = button
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Thickness = 2
    stroke.Transparency = 0.5
    stroke.Parent = button
    
    State.uiElements.button = button
    State.uiElements.stroke = stroke
    
    -- Debounce para evitar doble activación
    local debouncing = false
    
    -- Usar solo Activated que funciona tanto en PC como móvil
    button.Activated:Connect(function()
        if debouncing then return end
        debouncing = true
        
        if State.active then
            ShiftlockCore.deactivate()
        else
            ShiftlockCore.activate()
        end
        
        task.wait(0.2)
        debouncing = false
    end)
end

function UI.createCrosshair(parent)
    local crosshair = Instance.new("TextLabel")
    crosshair.Name = "ShiftlockCrosshair"
    crosshair.Size = UDim2.new(0, Config.crosshairSize, 0, Config.crosshairSize)
    crosshair.Position = UDim2.new(0.5, -Config.crosshairSize/2, 0.5, -Config.crosshairSize/2)
    crosshair.BackgroundTransparency = 1
    crosshair.Text = Config.crosshairSymbol
    crosshair.TextColor3 = Color3.fromRGB(255, 255, 255)
    crosshair.TextScaled = true
    crosshair.TextStrokeTransparency = 0.3
    crosshair.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    crosshair.Font = Enum.Font.Code
    crosshair.Visible = false
    crosshair.ZIndex = 100
    crosshair.Active = false
    crosshair.Parent = parent
    
    State.uiElements.crosshair = crosshair
end

function UI.updateButton(isActive)
    if State.uiElements.button then
        local button = State.uiElements.button
        local stroke = State.uiElements.stroke
        
        if isActive then
            button.Text = "ON"
            button.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
            if stroke then
                stroke.Color = Color3.fromRGB(100, 255, 100)
            end
        else
            button.Text = "OFF"
            button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            if stroke then
                stroke.Color = Color3.fromRGB(255, 255, 255)
            end
        end
        
        -- Calcular el tamaño reducido correctamente
        local smallSize = UDim2.new(
            Config.buttonSize.X.Scale * 0.9,
            Config.buttonSize.X.Offset * 0.9,
            Config.buttonSize.Y.Scale * 0.9,
            Config.buttonSize.Y.Offset * 0.9
        )
        
        local tween = Services.TweenService:Create(
            button,
            TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = smallSize}
        )
        tween:Play()
        tween.Completed:Connect(function()
            Services.TweenService:Create(
                button,
                TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {Size = Config.buttonSize}
            ):Play()
        end)
    end
end

function UI.updateCrosshair(visible)
    if State.uiElements.crosshair then
        State.uiElements.crosshair.Visible = visible
    end
end

function UI.destroy()
    if State.uiElements.screenGui then
        State.uiElements.screenGui:Destroy()
    end
    State.uiElements = {}
end

local Rotation = {}

function Rotation.start()
    if not Utils.isValidForShiftlock() then
        return false
    end
    
    if State.humanoid then
        State.humanoid.AutoRotate = false
    end
    
    State.connections.rotation = Services.RunService.RenderStepped:Connect(function()
        Rotation.update()
    end)
    
    State.connections.autoRotateKeeper = Services.RunService.Heartbeat:Connect(function()
        if State.humanoid and State.humanoid.AutoRotate then
            State.humanoid.AutoRotate = false
        end
    end)
    
    return true
end

function Rotation.update()
    if not State.camera or not State.rootPart or not State.character then
        return
    end
    
    local cameraDirection = State.camera.CFrame.LookVector
    local flatDirection = Vector3.new(cameraDirection.X, 0, cameraDirection.Z)
    
    if flatDirection.Magnitude > 0.01 then
        local targetPosition = State.rootPart.Position + flatDirection
        local newCFrame = CFrame.new(State.rootPart.Position, targetPosition)
        State.rootPart.CFrame = newCFrame
    end
end

function Rotation.stop()
    if State.connections.rotation then
        State.connections.rotation:Disconnect()
        State.connections.rotation = nil
    end
    
    if State.connections.autoRotateKeeper then
        State.connections.autoRotateKeeper:Disconnect()
        State.connections.autoRotateKeeper = nil
    end
    
    if State.humanoid then
        State.humanoid.AutoRotate = true
    end
end

local Input = {}

function Input.setup()
    if State.connections.input then
        State.connections.input:Disconnect()
    end
    
    State.connections.input = Services.UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Config.keybind and State.enabled then
            ShiftlockCore.toggle()
        end
    end)
end

function Input.cleanup()
    if State.connections.input then
        State.connections.input:Disconnect()
        State.connections.input = nil
    end
end

ShiftlockCore = {}

function ShiftlockCore.activate()
    if State.active then 
        return 
    end
    
    -- En móvil, la validación es diferente porque no usamos el mouse
    local isValid = Utils.isValidForShiftlock()
    if not isValid and not Services.UserInputService.TouchEnabled then
        return
    end
    
    State.active = true
    
    -- En PC ocultar cursor, en móvil no
    if not Services.UserInputService.TouchEnabled then
        Services.UserInputService.MouseIconEnabled = false
        Services.UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
    end
    
    Rotation.start()
    
    UI.updateButton(true)
    UI.updateCrosshair(true)
end

function ShiftlockCore.deactivate()
    if not State.active then 
        return 
    end
    
    State.active = false
    
    -- Restaurar cursor solo si no es móvil
    if not Services.UserInputService.TouchEnabled then
        Services.UserInputService.MouseIconEnabled = true
        Services.UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    end
    
    Rotation.stop()
    
    UI.updateButton(false)
    UI.updateCrosshair(false)
end

function ShiftlockCore.toggle()
    if State.active then
        ShiftlockCore.deactivate()
    else
        ShiftlockCore.activate()
    end
end

function ShiftlockCore.enable()
    if State.enabled then return end
    
    State.enabled = true
    Utils.updateCharacterReferences()
    UI.create()
    Input.setup()
end

function ShiftlockCore.disable()
    if not State.enabled then return end
    
    State.enabled = false
    
    -- Primero desactivar si está activo
    if State.active then
        ShiftlockCore.deactivate()
    end
    
    -- Limpiar todas las conexiones
    Utils.cleanupConnections()
    
    -- Destruir UI
    UI.destroy()
    
    -- Limpiar input
    Input.cleanup()
    
    -- Forzar reset del estado activo por si acaso
    State.active = false
end

State.player.CharacterAdded:Connect(function(newCharacter)
    task.wait(0.5)
    Utils.updateCharacterReferences()
    
    if State.enabled and State.active then
        task.wait(0.5)
        ShiftlockCore.activate()
    end
end)

function ToggleShiftlock(value)
    if value then
        ShiftlockCore.enable()
    else
        ShiftlockCore.disable()
    end
end

if MainTab and MainTab.CreateToggle then
    MainTab:CreateToggle({
        Name = "Shiftlock Nuevo (Q)",
        CurrentValue = false,
        Flag = "NewShiftlock",
        Callback = function(Value)
            ToggleShiftlock(Value)
        end
    })
end


getgenv().NewShiftlock = {
    Enable = ShiftlockCore.enable,
    Disable = ShiftlockCore.disable,
    Toggle = ShiftlockCore.toggle,
    IsActive = function() return State.active end,
    IsEnabled = function() return State.enabled end,
    SetKeybind = function(keycode) Config.keybind = keycode end
}

getgenv().ToggleShiftlock = ToggleShiftlock






---Volar autos
--Volar autos y normal
local UIS = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
local RootPart = Character:FindFirstChild("HumanoidRootPart")

local FlyEnabled = false
local FlySpeed = 50
local Connection
local SeatConnection
local MobileGui = nil
local OriginalPlatformStand = false
local CurrentSeat = nil
local VehicleInitialRotation = nil
local SeatOffset = nil

local MobileMove = {
    Up = false,
    Down = false,
}

local moveVector = Vector3.zero

function UpdateCharacter(newCharacter)
    Character = newCharacter
    Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
    RootPart = Character:FindFirstChild("HumanoidRootPart")
end

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    newCharacter:WaitForChild("HumanoidRootPart")
    newCharacter:WaitForChild("Humanoid")
    UpdateCharacter(newCharacter)
    if FlyEnabled then
        ToggleFly(false)
        ToggleFly(true)
    end
end)

function getMobileMovement()
    local moveDirection = Vector3.zero

    pcall(function()
        local playerModule = LocalPlayer.PlayerScripts:WaitForChild("PlayerModule")
        local controls = require(playerModule:WaitForChild("ControlModule"))
        if controls then
            moveDirection = controls:GetMoveVector()
        end
    end)

    return moveDirection
end

function CreateMobileControls()
    if not UIS.TouchEnabled or MobileGui then return end

    MobileGui = Instance.new("ScreenGui")
    MobileGui.Name = "MobileFlyControls"
    MobileGui.ResetOnSpawn = false
    MobileGui.Parent = CoreGui

    local ButtonSize = UDim2.new(0, 80, 0, 80)

     function CreateButton(name, position, text, onPress, onRelease)
        local Button = Instance.new("TextButton")
        Button.Name = name
        Button.Size = ButtonSize
        Button.Position = position
        Button.Text = text
        Button.TextScaled = true
        Button.Font = Enum.Font.GothamBold
        Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        Button.TextColor3 = Color3.new(1, 1, 1)
        Button.AutoButtonColor = false
        Button.Parent = MobileGui

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0.2, 0)
        corner.Parent = Button

        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.BackgroundTransparency = 1
        shadow.Position = UDim2.new(0, 0, 0, 2)
        shadow.Size = UDim2.new(1, 0, 1, 0)
        shadow.Image = "rbxasset://textures/ui/Controls/DesignSystem/Shadow_Circle.png"
        shadow.ImageColor3 = Color3.new(0, 0, 0)
        shadow.ImageTransparency = 0.7
        shadow.ZIndex = 0
        shadow.Parent = Button

        Button.MouseButton1Down:Connect(function()
            onPress()
            Button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        end)

        Button.MouseButton1Up:Connect(function()
            onRelease()
            Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        end)

        return Button
    end

    CreateButton("Up", UDim2.new(1, -100, 1, -200), "▲", 
        function() MobileMove.Up = true end, 
        function() MobileMove.Up = false end
    )
    CreateButton("Down", UDim2.new(1, -100, 1, -100), "▼", 
        function() MobileMove.Down = true end, 
        function() MobileMove.Down = false end
    )
end

function DestroyMobileControls()
    if MobileGui then
        MobileGui:Destroy()
        MobileGui = nil
    end
    for key in pairs(MobileMove) do
        MobileMove[key] = false
    end
end

function ToggleFly(state)
    if not RootPart or not Humanoid then
        return
    end

    FlyEnabled = state

    if FlyEnabled then
        if Humanoid.Sit and Humanoid.SeatPart then
            CurrentSeat = Humanoid.SeatPart
            
            local vehicle = CurrentSeat:FindFirstAncestorOfClass("Model")
            local vehiclePart = vehicle and vehicle.PrimaryPart or CurrentSeat
            VehicleInitialRotation = vehiclePart.CFrame - vehiclePart.Position
            
            SeatOffset = CurrentSeat.CFrame:ToObjectSpace(RootPart.CFrame)
        end

        if UIS.TouchEnabled then
            CreateMobileControls()
        end

        OriginalPlatformStand = Humanoid.PlatformStand
        
        if not CurrentSeat then
            Humanoid.PlatformStand = true
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
            Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
        end

        SeatConnection = RunService.Heartbeat:Connect(function()
            if CurrentSeat and CurrentSeat.Parent then
                if not Humanoid.Sit then
                    Humanoid.Sit = true
                end
                
                if Humanoid.SeatPart ~= CurrentSeat then
                    if CurrentSeat:IsA("VehicleSeat") or CurrentSeat:IsA("Seat") then
                        CurrentSeat:Sit(Humanoid)
                    end
                end
                
                if SeatOffset then
                    RootPart.CFrame = CurrentSeat.CFrame * SeatOffset
                end
            end
        end)

        Connection = RunService.RenderStepped:Connect(function()
            local MoveDirection = Vector3.new()
            local cameraCFrame = Workspace.CurrentCamera.CFrame
            local up = Vector3.new(0, 1, 0)

            if CurrentSeat and CurrentSeat.Parent then
                local seat = CurrentSeat
                local vehicle = seat:FindFirstAncestorOfClass("Model")
                local vehiclePart = vehicle and vehicle.PrimaryPart or seat

                local cameraForward = cameraCFrame.LookVector
                local cameraRight = cameraCFrame.RightVector

                if not UIS.TouchEnabled then
                    if UIS:IsKeyDown(Enum.KeyCode.W) then MoveDirection = MoveDirection + cameraForward end
                    if UIS:IsKeyDown(Enum.KeyCode.S) then MoveDirection = MoveDirection - cameraForward end
                    if UIS:IsKeyDown(Enum.KeyCode.A) then MoveDirection = MoveDirection - cameraRight end
                    if UIS:IsKeyDown(Enum.KeyCode.D) then MoveDirection = MoveDirection + cameraRight end
                else
                    -- Entrada de movimiento (Móvil)
                    local mobileMove = getMobileMovement()
                    if mobileMove.Magnitude > 0 then
                        local worldDirection = (cameraRight * mobileMove.X) + (cameraForward * -mobileMove.Z)
                        MoveDirection = MoveDirection + worldDirection
                    end
                end

                if UIS:IsKeyDown(Enum.KeyCode.Space) or MobileMove.Up then 
                    MoveDirection = MoveDirection + up 
                end
                if UIS:IsKeyDown(Enum.KeyCode.LeftShift) or MobileMove.Down then 
                    MoveDirection = MoveDirection - up 
                end

                local currentPosition = vehiclePart.Position

                if MoveDirection.Magnitude == 0 then
                    vehiclePart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                else
                    vehiclePart.AssemblyLinearVelocity = MoveDirection.Unit * FlySpeed
                end
                
                vehiclePart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                vehiclePart.CFrame = CFrame.new(currentPosition) * VehicleInitialRotation

            else
                if Humanoid.PlatformStand == false then
                    Humanoid.PlatformStand = true
                end

                if not UIS.TouchEnabled then
                    local forward = cameraCFrame.LookVector
                    local right = cameraCFrame.RightVector

                    if UIS:IsKeyDown(Enum.KeyCode.W) then MoveDirection = MoveDirection + forward end
                    if UIS:IsKeyDown(Enum.KeyCode.S) then MoveDirection = MoveDirection - forward end
                    if UIS:IsKeyDown(Enum.KeyCode.A) then MoveDirection = MoveDirection - right end
                    if UIS:IsKeyDown(Enum.KeyCode.D) then MoveDirection = MoveDirection + right end
                else
                    local mobileMove = getMobileMovement()
                    if mobileMove.Magnitude > 0 then
                        local lookVector = cameraCFrame.LookVector
                        local rightVector = cameraCFrame.RightVector
                        local worldDirection = (rightVector * mobileMove.X) + (lookVector * -mobileMove.Z)
                        MoveDirection = MoveDirection + worldDirection
                    end
                end

                if UIS:IsKeyDown(Enum.KeyCode.Space) or MobileMove.Up then 
                    MoveDirection = MoveDirection + up 
                end
                if UIS:IsKeyDown(Enum.KeyCode.LeftShift) or MobileMove.Down then 
                    MoveDirection = MoveDirection - up 
                end

                local currentPosition = RootPart.Position

                if MoveDirection.Magnitude == 0 then
                    RootPart.Velocity = Vector3.new(0, 0, 0)
                else
                    RootPart.Velocity = MoveDirection.Unit * FlySpeed
                end
                
                local cameraLook = cameraCFrame.LookVector
                local horizontalLook = Vector3.new(cameraLook.X, 0, cameraLook.Z)
                
                if horizontalLook.Magnitude > 0.01 then
                    horizontalLook = horizontalLook.Unit
                    -- Crear rotación instantánea mirando hacia la cámara
                    local targetCFrame = CFrame.new(currentPosition, currentPosition + horizontalLook)
                    RootPart.CFrame = targetCFrame
                else
                    -- Mantener rotación actual si mira directo arriba/abajo
                    RootPart.CFrame = CFrame.new(currentPosition) * (RootPart.CFrame - RootPart.Position)
                end
                
                RootPart.RotVelocity = Vector3.new(0, 0, 0)
            end
        end)
    else
        local wasSeated = CurrentSeat ~= nil
        local savedSeat = CurrentSeat
        
        if Connection then
            Connection:Disconnect()
            Connection = nil
        end

        if SeatConnection then
            SeatConnection:Disconnect()
            SeatConnection = nil
        end

        if not wasSeated then
            Humanoid.PlatformStand = OriginalPlatformStand
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
            Humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
        else
            if savedSeat and savedSeat.Parent then
                task.wait(0.05)
                if savedSeat:IsA("VehicleSeat") or savedSeat:IsA("Seat") then
                    savedSeat:Sit(Humanoid)
                end
                Humanoid.Sit = true
            end
        end

        CurrentSeat = nil
        VehicleInitialRotation = nil
        SeatOffset = nil

        DestroyMobileControls()
    end
end

FlyToggle = MainTab:CreateToggle({
    Name = "Volar en Vehiculos",
    CurrentValue = false,
    Callback = function(state)
        ToggleFly(state)
    end
})

FlySpeedSlider = MainTab:CreateSlider({
    Name = "Velociddad Volar en Vehiculos",
    Range = {0, 1000},
    Increment = 5,
    Suffix = " Velocidad",
    CurrentValue = FlySpeed,
    Callback = function(value)
        FlySpeed = value
    end
})








-- Caminar en el aire
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local isWalkingInAir = false
local floorPart = nil
local heartbeatConnection = nil

-- Detectar si está tocando suelo REAL (no nuestra plataforma)
 function isTouchingRealGround()
    local character = player.Character
    if not character then return false end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not root or not humanoid then return false end
    
    -- Raycast para detectar suelo real
    local rayOrigin = root.Position
    local rayDirection = Vector3.new(0, -4, 0)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character, floorPart}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.IgnoreWater = true
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    -- Verificar si hay suelo real colisionable
    if raycastResult and raycastResult.Instance then
        local hitPart = raycastResult.Instance
        -- Ignorar nuestra plataforma
        if hitPart ~= floorPart and hitPart.CanCollide then
            return true
        end
    end
    
    return false
end

-- Crear el piso invisible
 function createFloor()
    if floorPart then
        floorPart:Destroy()
    end
    
    floorPart = Instance.new("Part")
    floorPart.Name = "InvisibleFloor_JmodsUniversal"
    floorPart.Size = Vector3.new(10, 0.5, 10)
    floorPart.Anchored = true
    floorPart.CanCollide = true
    floorPart.Transparency = 1
    floorPart.Material = Enum.Material.SmoothPlastic
    floorPart.CastShadow = false
    floorPart.Parent = workspace
    
    -- Posición inicial debajo del jugador
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local root = character.HumanoidRootPart
        floorPart.CFrame = CFrame.new(root.Position.X, root.Position.Y - 3, root.Position.Z)
    end
end

-- Limpiar el piso
function destroyFloor()
    if floorPart then
        floorPart:Destroy()
        floorPart = nil
    end
end

-- Limpiar la conexión
function disconnectHeartbeat()
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
end

MainTab:CreateToggle({
    Name = "Caminar en el aire",
    CurrentValue = false,
    Flag = "walkInAirToggle",
    Callback = function(Value)
        isWalkingInAir = Value

        if isWalkingInAir then
            -- Activar caminar en el aire
            createFloor()
            disconnectHeartbeat()
            
            heartbeatConnection = RunService.Heartbeat:Connect(function()
                if not isWalkingInAir then
                    disconnectHeartbeat()
                    destroyFloor()
                    return
                end
                
                local character = player.Character
                if not character then return end
                
                local root = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if not root or not floorPart or not humanoid then return end
                
                -- Verificar si está en suelo real
                local onRealGround = isTouchingRealGround()
                
                if onRealGround then
                    -- Si está en suelo real, mover la plataforma lejos
                    floorPart.CFrame = CFrame.new(root.Position.X, root.Position.Y - 1000, root.Position.Z)
                else
                    -- Si está en el aire, mantener la plataforma debajo
                    -- La plataforma sigue al jugador horizontalmente pero mantiene altura relativa
                    local targetY = root.Position.Y - 3
                    
                    -- Si la plataforma está muy lejos verticalmente, reposicionarla
                    local distance = math.abs(floorPart.Position.Y - targetY)
                    if distance > 5 then
                        floorPart.CFrame = CFrame.new(root.Position.X, targetY, root.Position.Z)
                    else
                        -- Solo actualizar posición horizontal para mantener estabilidad
                        floorPart.CFrame = CFrame.new(root.Position.X, floorPart.Position.Y, root.Position.Z)
                    end
                end
            end)
            
        else
            -- Desactivar caminar en el aire
            disconnectHeartbeat()
            destroyFloor()
        end
    end,
})

-- Limpiar al morir o cambiar de personaje
player.CharacterAdded:Connect(function(newChar)
    task.wait(0.3)
    
    if isWalkingInAir then
        destroyFloor()
        disconnectHeartbeat()
        task.wait(0.2)
        createFloor()
    end
end)

-- Limpiar al salir del juego
game:GetService("Players").PlayerRemoving:Connect(function(playerWhoLeft)
    if playerWhoLeft == player then
        disconnectHeartbeat()
        destroyFloor()
    end
end)



-- Mutear sonidos excepto voz
local mutedSounds = {}
local toggleActive = false

 function isVoiceSound(sound)
	if sound:IsDescendantOf(VoiceChatService) then return true end
	local name = sound.Name:lower()
	return name:find("voice") or name:find("vc")
end

 function muteAllExceptVoice()
	for _, sound in ipairs(game:GetDescendants()) do
		if sound:IsA("Sound") and not isVoiceSound(sound) then
			if sound.Playing and sound.Volume > 0 then
				mutedSounds[sound] = sound.Volume
				sound.Volume = 0
			end
		end
	end
end

 function unmuteAll()
	for sound, vol in pairs(mutedSounds) do
		if sound and sound.Parent then
			sound.Volume = vol
		end
	end
	mutedSounds = {}
end

game.DescendantAdded:Connect(function(sound)
	if toggleActive and sound:IsA("Sound") and not isVoiceSound(sound) then
		mutedSounds[sound] = sound.Volume
		sound.Volume = 0
	end
end)

MainTab:CreateToggle({
	Name = "Mutear sonidos (voz no)",
	CurrentValue = false,
	Flag = "MuteAudios",
	Callback = function(Value)
		toggleActive = Value
		if Value then
			muteAllExceptVoice()
		else
			unmuteAll()
		end
	end
})




---Fullbright

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local originalSettings = {}
local connection

MainTab:CreateToggle({
	Name = "Fullbright",
	Flag = "Fullbright",
	CurrentValue = false,
	Callback = function(enabled)
		if enabled then
			-- Guardar valores originales
			originalSettings.Brightness = Lighting.Brightness
			originalSettings.ClockTime = Lighting.ClockTime
			originalSettings.Ambient = Lighting.Ambient
			originalSettings.OutdoorAmbient = Lighting.OutdoorAmbient
			originalSettings.GlobalShadows = Lighting.GlobalShadows

			-- Conexión para forzar iluminación
			if not connection then
				connection = RunService.RenderStepped:Connect(function()
					Lighting.Brightness = 1.5
					Lighting.ClockTime = 12
					Lighting.Ambient = Color3.new(1, 1, 1)
					Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
					Lighting.GlobalShadows = false
				end)
			end
		else
			-- Restaurar valores
			if connection then
				connection:Disconnect()
				connection = nil
			end
			for prop, value in pairs(originalSettings) do
				Lighting[prop] = value
			end
		end
	end
})





-- Servicios y variables necesarias
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local unlockCameraConnection
local cameraUnlocked = false -- INICIALMENTE FALSO
local originalCameraSettings = {}

-- Función para forzar el control de cámara
 function enableCameraControl()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	-- Guardar estado original una sola vez
	if not originalCameraSettings.saved then
		originalCameraSettings.CameraType = Camera.CameraType
		originalCameraSettings.CameraSubject = Camera.CameraSubject
		originalCameraSettings.CameraMode = LocalPlayer.CameraMode
		originalCameraSettings.MaxZoom = LocalPlayer.CameraMaxZoomDistance
		originalCameraSettings.MinZoom = LocalPlayer.CameraMinZoomDistance
		originalCameraSettings.saved = true
	end

	-- Desconectar si ya había una conexión previa
	if unlockCameraConnection then
		unlockCameraConnection:Disconnect()
	end

	unlockCameraConnection = RunService.RenderStepped:Connect(function()
		if not cameraUnlocked then return end

		if Camera.CameraType ~= Enum.CameraType.Custom then
			Camera.CameraType = Enum.CameraType.Custom
		end

		if Camera.CameraSubject ~= humanoid then
			Camera.CameraSubject = humanoid
		end

		LocalPlayer.CameraMode = Enum.CameraMode.Classic
		LocalPlayer.CameraMaxZoomDistance = 128
		LocalPlayer.CameraMinZoomDistance = 0.5
	end)
end

-- TOGGLE: Unlock Camera
MainTab:CreateToggle({
	Name = "Desbloquear Camara",
	Flag = "unlockCam",
	CurrentValue = false,
	Callback = function(enabled)
		cameraUnlocked = enabled

		if enabled then
			enableCameraControl()
		else
			-- Desconectar render loop
			if unlockCameraConnection then
				unlockCameraConnection:Disconnect()
				unlockCameraConnection = nil
			end

			-- Restaurar valores originales si estaban guardados
			if originalCameraSettings.saved then
				Camera.CameraType = originalCameraSettings.CameraType
				Camera.CameraSubject = originalCameraSettings.CameraSubject
				LocalPlayer.CameraMode = originalCameraSettings.CameraMode
				LocalPlayer.CameraMaxZoomDistance = originalCameraSettings.MaxZoom
				LocalPlayer.CameraMinZoomDistance = originalCameraSettings.MinZoom
			end
		end
	end
})

-- Ejecutar enableCameraControl() solo si el toggle está activado al cargar (opcional)
if cameraUnlocked then
	enableCameraControl()
end

-- Reaplicar si reaparece el personaje, pero solo si está activado
LocalPlayer.CharacterAdded:Connect(function()
	if cameraUnlocked then
		enableCameraControl()
	end
end)











-- Asegúrate de que estas variables están definidas
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Variables de control
local boostEnabled = false
local boostStrength = 100
local baseWalkSpeed = 16
local baseJumpPower = 50
local originalStats = {}

-- Función para aplicar boost
 function applyBoost()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid then
		-- Guardar valores originales una vez
		if not originalStats.saved then
			originalStats.WalkSpeed = humanoid.WalkSpeed
			originalStats.JumpPower = humanoid.JumpPower
			originalStats.saved = true
		end

		humanoid.UseJumpPower = true
		local speedMultiplier = (boostStrength * 0.1) / 100
		local jumpMultiplier = (boostStrength * 0.4) / 100
		humanoid.WalkSpeed = baseWalkSpeed * (1 + speedMultiplier)
		humanoid.JumpPower = baseJumpPower * (1 + jumpMultiplier)
	end
end

-- Restaurar valores originales
 function restoreStats()
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if humanoid and originalStats.saved then
		humanoid.WalkSpeed = originalStats.WalkSpeed
		humanoid.JumpPower = originalStats.JumpPower
	end
end

-- Toggle en MainTab
MainTab:CreateToggle({
	Name = "Salto y Velocidad Indetectable",
	Flag = "movementBoost",
	CurrentValue = false,
	Callback = function(value)
		boostEnabled = value
		if boostEnabled then
			applyBoost()
		else
			restoreStats()
		end
	end
})

-- Slider en MainTab
MainTab:CreateSlider({
	Name = "Aumento Velocidad Indetectable",
	Flag = "boostStrength",
	Range = {0, 100},
	Increment = 5,
	CurrentValue = boostStrength,
	Suffix = "+",
	Callback = function(value)
		boostStrength = value
		if boostEnabled then
			applyBoost()
		end
	end
})








-----







local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local antiFlingEnabled = false
local characterConnections = {}
local collisionLoop

 function SetNoCollision(character)
	for _, item in pairs(character:GetDescendants()) do
		if item:IsA("BasePart") and item.CanCollide then
			item.CanCollide = false
		end
	end
end

 function OnCharacterAdded(player, character)
	if not antiFlingEnabled or player == LocalPlayer then return end
	SetNoCollision(character)

	-- Nuevas partes
	local conn = character.DescendantAdded:Connect(function(desc)
		if desc:IsA("BasePart") then
			desc.CanCollide = false
		end
	end)

	characterConnections[player] = conn
end

 function EnableAntiFling()
	-- Inicial
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			if player.Character then
				OnCharacterAdded(player, player.Character)
			end
			characterConnections[player] = player.CharacterAdded:Connect(function(char)
				OnCharacterAdded(player, char)
			end)
		end
	end

	-- Nuevos jugadores
	characterConnections["_PlayerAdded"] = Players.PlayerAdded:Connect(function(player)
		if player == LocalPlayer then return end
		characterConnections[player] = player.CharacterAdded:Connect(function(char)
			OnCharacterAdded(player, char)
		end)
	end)

	-- Loop seguro cada 0.25s para mantener colisión desactivada
	local timer = 0
	collisionLoop = RunService.Stepped:Connect(function(_, dt)
		timer += dt
		if timer >= 0.25 then
			timer = 0
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character then
					SetNoCollision(player.Character)
				end
			end
		end
	end)
end

function DisableAntiFling()
	for _, conn in pairs(characterConnections) do
		if typeof(conn) == "RBXScriptConnection" then
			conn:Disconnect()
		end
	end
	characterConnections = {}

	if collisionLoop then
		collisionLoop:Disconnect()
		collisionLoop = nil
	end

	-- Restaurar colisión
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			for _, part in pairs(player.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
				end
			end
		end
	end
end

MainTab:CreateToggle({
	Name = "Anti-Fling",
	CurrentValue = false,
	Callback = function(state)
		antiFlingEnabled = state
		if state then
			EnableAntiFling()
		else
			DisableAntiFling()
		end
	end,
})



-----Anti AFK



local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

-- Reconectar si respawns
player.CharacterAdded:Connect(function(newChar)
	character = newChar
	humanoid = character:WaitForChild("Humanoid")
end)

local AntiAfkEnabled = false
local AntiAfkThread = nil

-- Función que simula un input completo (presión + liberación)
local function SimulateInput()
	-- Crear objeto de input falso que simula presión de tecla
	local inputObject = Instance.new("BindableEvent")

	-- Usar ContextActionService para registrar y desregistrar una acción
	-- Esto genera un ciclo input completo que Roblox reconoce
	local actionId = "AAF_" .. tostring(math.random(100000))

	ContextActionService:BindToAction(
		actionId,
		{ Enum.KeyCode.L }, -- Usar una tecla que generalmente no se usa en juegos
		false,
		function(actionName, actionState, inputObject)
			-- No hacer nada, solo existe para generar el evento
			return Enum.ContextActionResult.Sink -- "Absorber" el input para que no haga otra cosa
		end
	)

	-- Esperar un frame para que se registre
	task.wait(0)

	-- Desregistrar inmediatamente
	ContextActionService:UnbindAction(actionId)
	inputObject:Destroy()
end

-- Función que resetea el idle time de múltiples formas
local function ResetIdleTime()
	-- Método 1: Asignar directamente (funciona en muchos casos)
	player.IdleTime = 0

	-- Método 2: Usar Chat para generar actividad interna
	-- Escribir un mensaje vacío al chat no envía nada pero genera actividad
	local chat = player:FindFirstChild("ChatService") 
		or game:GetService("ChatService")
	-- No enviar nada real, solo activar el servicio
end

-- Función que hace un movimiento físico sutil
local function PhysicsMovement()
	if humanoid and humanoid.Health > 0 then
		-- Salto sutil cada vez
		humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
	end

	-- Rotar cámara un poco
	if camera then
		camera.CFrame = camera.CFrame * CFrame.Angles(0, math.rad(0.5), 0)
	end
end

-- Loop principal
local function RunAntiAfk()
	while AntiAfkEnabled do
		-- Ejecutar las 3 capas de anti-afk
		ResetIdleTime()      -- Resetea contador interno
		SimulateInput()      -- Genera evento de input real
		PhysicsMovement()    -- Movimiento físico visible

		-- Cada 20 segundos (bien antes del límite de detección)
		task.wait(20)
	end
end

-- Toggle
MainTab:CreateToggle({
	Name = "Anti-AFK OP",
	CurrentValue = false,
	Flag = "AntiAfkToggle",
	Callback = function(Value)
		AntiAfkEnabled = Value

		if AntiAfkEnabled then
			AntiAfkThread = task.spawn(RunAntiAfk)
		else
			if AntiAfkThread then
				task.cancel(AntiAfkThread)
				AntiAfkThread = nil
			end
		end
	end,
})





------Cargar guardar posicion

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local savedCFrame = nil
local systemEnabled = false 

MainTab:CreateToggle({
    Name = "Activar Guardar/Cargar",
    CurrentValue = false,
    Flag = "ToggleSistemaPos",
    Callback = function(value)
        systemEnabled = value
    end,
})

MainTab:CreateButton({
    Name = "Guardar Posición",
    Callback = function()
        if not systemEnabled then
            Rayfield:Notify({
                Title = "Sistema Desactivado",
                Content = "Activa el toggle para usar Guardar Posición.",
                Duration = 3,
            })
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            savedCFrame = rootPart.CFrame
        end
    end,
})

MainTab:CreateButton({
    Name = "Cargar Posición",
    Callback = function()
        if not systemEnabled then
            Rayfield:Notify({
                Title = "Sistema Desactivado",
                Content = "Activa el toggle para usar Cargar Posición.",
                Duration = 3,
            })
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if savedCFrame and rootPart then
            rootPart.CFrame = savedCFrame
        end
    end,
})

MainTab:CreateKeybind({
    Name = "Cargar Posición",
    CurrentKeybind = "Q", 
    HoldToInteract = false,
    Flag = "KeybindTP",
    Callback = function()
        if not systemEnabled then return end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if savedCFrame and rootPart then
            rootPart.CFrame = savedCFrame
        end
    end,
})



----


-- Variables para guardar configuraciones originales
local originalSettings = {
    Lighting = {},
    Terrain = {},
    Rendering = {},
    Materials = {},
    Parts = {},
    MeshParts = {},
    Particles = {},
    Explosions = {},
    PostEffects = {}
}

local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local MaterialService = game:GetService("MaterialService")
local ME = Players.LocalPlayer
local fpsBoosterActive = false
local descendantConnection = nil
local modifiedInstances = {}

-- Guardar configuraciones originales
function SaveOriginalSettings()
    -- Lighting
    originalSettings.Lighting.GlobalShadows = Lighting.GlobalShadows
    originalSettings.Lighting.FogEnd = Lighting.FogEnd
    originalSettings.Lighting.ShadowSoftness = Lighting.ShadowSoftness
    if sethiddenproperty then
        originalSettings.Lighting.Technology = Lighting.Technology
    end
    
    -- Terrain
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        originalSettings.Terrain.WaterWaveSize = terrain.WaterWaveSize
        originalSettings.Terrain.WaterWaveSpeed = terrain.WaterWaveSpeed
        originalSettings.Terrain.WaterReflectance = terrain.WaterReflectance
        originalSettings.Terrain.WaterTransparency = terrain.WaterTransparency
        
        -- CORRECCIÓN: Guardar Decoration para restaurar el pasto
        if sethiddenproperty then
            pcall(function()
                originalSettings.Terrain.Decoration = gethiddenproperty(terrain, "Decoration")
            end)
        end
    end
    
    -- Rendering
    originalSettings.Rendering.QualityLevel = settings().Rendering.QualityLevel
    originalSettings.Rendering.MeshPartDetailLevel = settings().Rendering.MeshPartDetailLevel
    
    -- Materials
    originalSettings.Materials.Use2022Materials = MaterialService.Use2022Materials
end

-- Restaurar configuraciones originales
function RestoreOriginalSettings()
    -- Lighting
    Lighting.GlobalShadows = originalSettings.Lighting.GlobalShadows
    Lighting.FogEnd = originalSettings.Lighting.FogEnd
    Lighting.ShadowSoftness = originalSettings.Lighting.ShadowSoftness
    if sethiddenproperty and originalSettings.Lighting.Technology then
        sethiddenproperty(Lighting, "Technology", originalSettings.Lighting.Technology)
    end
    
    -- Terrain
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        terrain.WaterWaveSize = originalSettings.Terrain.WaterWaveSize
        terrain.WaterWaveSpeed = originalSettings.Terrain.WaterWaveSpeed
        terrain.WaterReflectance = originalSettings.Terrain.WaterReflectance
        terrain.WaterTransparency = originalSettings.Terrain.WaterTransparency
        
        -- CORRECCIÓN: Restaurar Decoration para que vuelva el pasto
        if sethiddenproperty and originalSettings.Terrain.Decoration ~= nil then
            pcall(function()
                sethiddenproperty(terrain, "Decoration", originalSettings.Terrain.Decoration)
            end)
        end
    end
    
    -- Rendering
    settings().Rendering.QualityLevel = originalSettings.Rendering.QualityLevel
    settings().Rendering.MeshPartDetailLevel = originalSettings.Rendering.MeshPartDetailLevel
    
    -- Materials
    MaterialService.Use2022Materials = originalSettings.Materials.Use2022Materials
    
    -- Restaurar instancias modificadas
    for inst, data in pairs(modifiedInstances) do
        if inst and inst.Parent then
            pcall(function()
                if inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Smoke") or inst:IsA("Fire") or inst:IsA("Sparkles") then
                    inst.Enabled = data.Enabled
                elseif inst:IsA("PostEffect") then
                    inst.Enabled = data.Enabled
                elseif inst:IsA("BasePart") and not inst:IsA("MeshPart") then
                    inst.Material = data.Material
                    inst.Reflectance = data.Reflectance
                elseif inst:IsA("MeshPart") then
                    inst.RenderFidelity = data.RenderFidelity
                    inst.Reflectance = data.Reflectance
                    inst.Material = data.Material
                    inst.Transparency = data.Transparency
                elseif inst:IsA("SpecialMesh") then
                    inst.MeshId = data.MeshId
                    inst.TextureId = data.TextureId
                elseif inst:IsA("FaceInstance") then
                    inst.Transparency = data.Transparency
                    inst.Shiny = data.Shiny
                elseif inst:IsA("Model") then
                    inst.LevelOfDetail = data.LevelOfDetail
                end
            end)
        end
    end
    
    modifiedInstances = {}
end

-- Verificar si una instancia debe ser ignorada
function ShouldIgnore(Inst)
    if Inst:IsDescendantOf(Players) then return true end
    if ME.Character and Inst:IsDescendantOf(ME.Character) then return true end
    if Inst:IsA("BackpackItem") or Inst:FindFirstAncestorWhichIsA("BackpackItem") then return true end
    
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= ME and v.Character and Inst:IsDescendantOf(v.Character) then
            return true
        end
    end
    
    return false
end

-- Aplicar optimizaciones a una instancia
function OptimizeInstance(Inst)
    if ShouldIgnore(Inst) then return end
    
    pcall(function()
        if Inst:IsA("ParticleEmitter") or Inst:IsA("Trail") or Inst:IsA("Smoke") or Inst:IsA("Fire") or Inst:IsA("Sparkles") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {Enabled = Inst.Enabled}
            end
            Inst.Enabled = false
            
        elseif Inst:IsA("PostEffect") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {Enabled = Inst.Enabled}
            end
            Inst.Enabled = false
            
        elseif Inst:IsA("Explosion") then
            Inst.BlastPressure = 1
            Inst.BlastRadius = 1
            
        elseif Inst:IsA("SpecialMesh") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    MeshId = Inst.MeshId,
                    TextureId = Inst.TextureId
                }
            end
            Inst.TextureId = ""
            
        elseif Inst:IsA("FaceInstance") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    Transparency = Inst.Transparency,
                    Shiny = Inst.Shiny
                }
            end
            Inst.Transparency = 1
            Inst.Shiny = 1
            
        elseif Inst:IsA("BasePart") and not Inst:IsA("MeshPart") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    Material = Inst.Material,
                    Reflectance = Inst.Reflectance
                }
            end
            Inst.Material = Enum.Material.Plastic
            Inst.Reflectance = 0
            
        elseif Inst:IsA("MeshPart") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    RenderFidelity = Inst.RenderFidelity,
                    Reflectance = Inst.Reflectance,
                    Material = Inst.Material,
                    Transparency = Inst.Transparency
                }
            end
            Inst.RenderFidelity = Enum.RenderFidelity.Performance
            Inst.Reflectance = 0
            Inst.Material = Enum.Material.Plastic
            
        elseif Inst:IsA("Model") then
            if not modifiedInstances[Inst] then
                modifiedInstances[Inst] = {
                    LevelOfDetail = Inst.LevelOfDetail
                }
            end
            Inst.LevelOfDetail = Enum.ModelLevelOfDetail.StreamingMesh
        end
    end)
end

-- Aplicar todas las optimizaciones
function ApplyOptimizations()
    -- Optimizaciones de Lighting
    Lighting.GlobalShadows = false
    Lighting.FogEnd = 9e9
    Lighting.ShadowSoftness = 0
    if sethiddenproperty then
        sethiddenproperty(Lighting, "Technology", 2)
    end
    
    -- Optimizaciones de Terrain
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        terrain.WaterWaveSize = 0
        terrain.WaterWaveSpeed = 0
        terrain.WaterReflectance = 0
        terrain.WaterTransparency = 0
        if sethiddenproperty then
            sethiddenproperty(terrain, "Decoration", false)
        end
    end
    
    -- Optimizaciones de Rendering
    settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level04
    
    -- Optimizaciones de Materials
    MaterialService.Use2022Materials = false
    
    -- FPS Cap
    if setfpscap then
        setfpscap(1e6)
    end
    
    -- Optimizar todas las instancias existentes
    for _, v in pairs(game:GetDescendants()) do
        OptimizeInstance(v)
    end
end

-- Guardar configuraciones originales al inicio
SaveOriginalSettings()



-- Toggle principal
MainTab:CreateToggle({
    Name = "Activar FPS Booster",
    CurrentValue = false,
    Callback = function(state)
        fpsBoosterActive = state
        
        if state then
            -- Activar optimizaciones
            ApplyOptimizations()
            
            -- Conectar evento para nuevas instancias
            if descendantConnection then
                descendantConnection:Disconnect()
            end
            
            descendantConnection = game.DescendantAdded:Connect(function(inst)
                task.wait(0.5)
                if fpsBoosterActive then
                    OptimizeInstance(inst)
                end
            end)
            
        else
            -- Desactivar optimizaciones
            if descendantConnection then
                descendantConnection:Disconnect()
                descendantConnection = nil
            end
            
            RestoreOriginalSettings()
        end
    end
})




local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer



-- FakeLag vars
local FakeLagEnabled = false
local FakeLagThread = nil
local FakeLagWaitTime = 0.05
local FakeLagDelayTime = 0.4

-- Falling vars
local FallingEnabled = false


-- ---------- FakeLag functions ----------
function StartFakeLag()
	if FakeLagThread then return end

	FakeLagThread = task.spawn(function()
		while FakeLagEnabled do
			local char = LocalPlayer.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")

			if hrp then
				hrp.Anchored = true
				task.wait(FakeLagDelayTime)
				hrp.Anchored = false
			end

			task.wait(FakeLagWaitTime)
		end
		FakeLagThread = nil
	end)
end

function StopFakeLag()
	FakeLagEnabled = false

	local char = LocalPlayer.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if hrp then
		hrp.Anchored = false
	end
end


function SetFalling(state)
	local char = LocalPlayer.Character
	local humanoid = char and char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	FallingEnabled = state
	humanoid.PlatformStand = state

	if state then
		humanoid:Move(Vector3.new(0, -50, 0))
	end
end


MainTab:CreateToggle({
	Name = "FakeLag",
	CurrentValue = false,
	Flag = "FakeLagToggle",
	Callback = function(state)
		FakeLagEnabled = state
		if state then
			StartFakeLag()
		else
			StopFakeLag()
		end
	end
})

MainTab:CreateToggle({
	Name = "Caer",
	CurrentValue = false,
	Flag = "FallingToggle",
	Callback = function(state)
		SetFalling(state)
	end
})



-- Equip vars
local ToolsEquipped = false


function ToggleEquipAllTools()
	local char = LocalPlayer.Character
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if not char or not backpack then return end

	if not ToolsEquipped then
		for _, tool in ipairs(backpack:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent = char
			end
		end
		ToolsEquipped = true
	else
		for _, tool in ipairs(char:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent = backpack
			end
		end
		ToolsEquipped = false
	end
end

MainTab:CreateToggle({
	Name = "Equipar todas las herramientas",
	CurrentValue = false,
	Flag = "EquipAllToolsToggle",
	Callback = function(state)
		if state ~= ToolsEquipped then
			ToggleEquipAllTools()
		end
	end
})
